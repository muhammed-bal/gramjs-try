{"ast":null,"code":"\"use strict\";\n\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n    i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getCommentData = exports.markAsRead = exports._pin = exports.unpinMessage = exports.pinMessage = exports.deleteMessages = exports.editMessage = exports.forwardMessages = exports.sendMessage = exports.getMessages = exports.iterMessages = exports._IDsIter = exports._MessagesIter = void 0;\nconst tl_1 = require(\"../tl\");\nconst requestIter_1 = require(\"../requestIter\");\nconst Helpers_1 = require(\"../Helpers\");\nconst Utils_1 = require(\"../Utils\");\nconst __1 = require(\"../\");\nconst messageParse_1 = require(\"./messageParse\");\nconst users_1 = require(\"./users\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst uploads_1 = require(\"./uploads\");\nconst _MAX_CHUNK_SIZE = 100;\nclass _MessagesIter extends requestIter_1.RequestIter {\n  async _init({\n    entity,\n    offsetId,\n    minId,\n    maxId,\n    fromUser,\n    offsetDate,\n    addOffset,\n    filter,\n    search,\n    replyTo\n  }) {\n    var e_1, _a;\n    if (entity) {\n      this.entity = await this.client.getInputEntity(entity);\n    } else {\n      this.entity = undefined;\n      if (this.reverse) {\n        throw new Error(\"Cannot reverse global search\");\n      }\n    }\n    if (this.reverse) {\n      offsetId = Math.max(offsetId, minId);\n      if (offsetId && maxId) {\n        if (maxId - offsetId <= 1) {\n          return false;\n        }\n      }\n      if (!maxId) {\n        maxId = Number.MAX_SAFE_INTEGER;\n      }\n    } else {\n      offsetId = Math.max(offsetId, maxId);\n      if (offsetId && minId) {\n        if (offsetId - minId <= 1) {\n          return false;\n        }\n      }\n    }\n    if (this.reverse) {\n      if (offsetId) {\n        offsetId += 1;\n      } else if (!offsetDate) {\n        offsetId = 1;\n      }\n    }\n    if (fromUser) {\n      fromUser = await this.client.getInputEntity(fromUser);\n    }\n    if (!this.entity && fromUser) {\n      this.entity = new tl_1.Api.InputPeerEmpty();\n    }\n    if (!filter) {\n      filter = new tl_1.Api.InputMessagesFilterEmpty();\n    }\n    if (!this.entity) {\n      this.request = new tl_1.Api.messages.SearchGlobal({\n        q: search || \"\",\n        filter: filter,\n        minDate: undefined,\n        // TODO fix this smh\n        maxDate: offsetDate,\n        offsetRate: undefined,\n        offsetPeer: new tl_1.Api.InputPeerEmpty(),\n        offsetId: offsetId,\n        limit: 1\n      });\n    } else if (replyTo !== undefined) {\n      this.request = new tl_1.Api.messages.GetReplies({\n        peer: this.entity,\n        msgId: replyTo,\n        offsetId: offsetId,\n        offsetDate: offsetDate,\n        addOffset: addOffset,\n        limit: 0,\n        maxId: 0,\n        minId: 0,\n        hash: big_integer_1.default.zero\n      });\n    } else if (search !== undefined || !(filter instanceof tl_1.Api.InputMessagesFilterEmpty) || fromUser !== undefined) {\n      this.request = new tl_1.Api.messages.Search({\n        peer: this.entity,\n        q: search || \"\",\n        filter: typeof filter === \"function\" ? new filter() : filter,\n        minDate: undefined,\n        maxDate: offsetDate,\n        offsetId: offsetId,\n        addOffset: addOffset,\n        limit: 0,\n        maxId: 0,\n        minId: 0,\n        hash: (0, Helpers_1.generateRandomBigInt)(),\n        fromId: fromUser\n      });\n      if (!(filter instanceof tl_1.Api.InputMessagesFilterEmpty) && offsetDate && !search && !offsetId) {\n        try {\n          for (var _b = __asyncValues(this.client.iterMessages(this.entity, {\n              limit: 1,\n              offsetDate: offsetDate\n            })), _c; _c = await _b.next(), !_c.done;) {\n            const m = _c.value;\n            this.request.offsetId = m.id + 1;\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      }\n    } else {\n      this.request = new tl_1.Api.messages.GetHistory({\n        peer: this.entity,\n        limit: 1,\n        offsetDate: offsetDate,\n        offsetId: offsetId,\n        minId: 0,\n        maxId: 0,\n        addOffset: addOffset,\n        hash: big_integer_1.default.zero\n      });\n    }\n    if (this.limit <= 0) {\n      const result = await this.client.invoke(this.request);\n      if (result instanceof tl_1.Api.messages.MessagesNotModified) {\n        this.total = result.count;\n      } else {\n        if (\"count\" in result) {\n          this.total = result.count;\n        } else {\n          this.total = result.messages.length;\n        }\n      }\n      return false;\n    }\n    if (!this.waitTime) {\n      this.waitTime = this.limit > 3000 ? 1 : 0;\n    }\n    if (this.reverse && !(this.request instanceof tl_1.Api.messages.SearchGlobal)) {\n      this.request.addOffset -= _MAX_CHUNK_SIZE;\n    }\n    this.addOffset = addOffset;\n    this.maxId = maxId;\n    this.minId = minId;\n    this.lastId = this.reverse ? 0 : Number.MAX_SAFE_INTEGER;\n  }\n  async _loadNextChunk() {\n    var _a;\n    if (!this.request) {\n      throw new Error(\"Request not set yet\");\n    }\n    this.request.limit = Math.min(this.left, _MAX_CHUNK_SIZE);\n    if (this.reverse && this.request.limit != _MAX_CHUNK_SIZE) {\n      if (!(this.request instanceof tl_1.Api.messages.SearchGlobal)) {\n        this.request.addOffset = this.addOffset - this.request.limit;\n      }\n    }\n    const r = await this.client.invoke(this.request);\n    if (r instanceof tl_1.Api.messages.MessagesNotModified) {\n      return true;\n    }\n    if (\"count\" in r) {\n      this.total = r.count;\n    } else {\n      this.total = r.messages.length;\n    }\n    const entities = new Map();\n    for (const x of [...r.users, ...r.chats]) {\n      entities.set((0, Utils_1.getPeerId)(x), x);\n    }\n    const messages = this.reverse ? r.messages.reverse() : r.messages;\n    for (const message of messages) {\n      if (!this._messageInRange(message)) {\n        return true;\n      }\n      this.lastId = message.id;\n      try {\n        // if this fails it shouldn't be a big problem\n        message._finishInit(this.client, entities, this.entity);\n      } catch (e) {}\n      message._entities = entities;\n      (_a = this.buffer) === null || _a === void 0 ? void 0 : _a.push(message);\n    }\n    if (r.messages.length < this.request.limit) {\n      return true;\n    }\n    if (this.buffer) {\n      this._updateOffset(this.buffer[this.buffer.length - 1], r);\n    } else {\n      return true;\n    }\n  }\n  _messageInRange(message) {\n    if (this.entity) {\n      if (this.reverse) {\n        if (message.id <= this.lastId || message.id >= this.maxId) {\n          return false;\n        }\n      } else {\n        if (message.id >= this.lastId || message.id <= this.minId) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  [Symbol.asyncIterator]() {\n    return super[Symbol.asyncIterator]();\n  }\n  _updateOffset(lastMessage, response) {\n    if (!this.request) {\n      throw new Error(\"Request not set yet\");\n    }\n    this.request.offsetId = Number(lastMessage.id);\n    if (this.reverse) {\n      this.request.offsetId += 1;\n    }\n    if (this.request instanceof tl_1.Api.messages.Search) {\n      this.request.maxDate = -1;\n    } else {\n      if (!(this.request instanceof tl_1.Api.messages.SearchGlobal)) {\n        this.request.offsetDate = lastMessage.date;\n      }\n    }\n    if (this.request instanceof tl_1.Api.messages.SearchGlobal) {\n      if (lastMessage.inputChat) {\n        this.request.offsetPeer = lastMessage.inputChat;\n      } else {\n        this.request.offsetPeer = new tl_1.Api.InputPeerEmpty();\n      }\n      this.request.offsetRate = response.nextRate;\n    }\n  }\n}\nexports._MessagesIter = _MessagesIter;\nclass _IDsIter extends requestIter_1.RequestIter {\n  async _init({\n    entity,\n    ids\n  }) {\n    this.total = ids.length;\n    this._ids = this.reverse ? ids.reverse() : ids;\n    this._offset = 0;\n    this._entity = entity ? await this.client.getInputEntity(entity) : undefined;\n    this._ty = this._entity ? (0, Helpers_1._entityType)(this._entity) : undefined;\n    if (!this.waitTime) {\n      this.waitTime = this.limit > 300 ? 10 : 0;\n    }\n  }\n  [Symbol.asyncIterator]() {\n    return super[Symbol.asyncIterator]();\n  }\n  async _loadNextChunk() {\n    var _a, _b, _c;\n    const ids = this._ids.slice(this._offset, this._offset + _MAX_CHUNK_SIZE);\n    if (!ids.length) {\n      return false;\n    }\n    this._offset += _MAX_CHUNK_SIZE;\n    let fromId;\n    let r;\n    if (this._ty == Helpers_1._EntityType.CHANNEL) {\n      try {\n        r = await this.client.invoke(new tl_1.Api.channels.GetMessages({\n          channel: this._entity,\n          id: ids\n        }));\n      } catch (e) {\n        if (e.errorMessage == \"MESSAGE_IDS_EMPTY\") {\n          r = new tl_1.Api.messages.MessagesNotModified({\n            count: ids.length\n          });\n        } else {\n          throw e;\n        }\n      }\n    } else {\n      r = await this.client.invoke(new tl_1.Api.messages.GetMessages({\n        id: ids\n      }));\n      if (this._entity) {\n        fromId = await (0, users_1._getPeer)(this.client, this._entity);\n      }\n    }\n    if (r instanceof tl_1.Api.messages.MessagesNotModified) {\n      (_a = this.buffer) === null || _a === void 0 ? void 0 : _a.push(...Array(ids.length));\n      return;\n    }\n    const entities = new Map();\n    for (const entity of [...r.users, ...r.chats]) {\n      entities.set(__1.utils.getPeerId(entity), entity);\n    }\n    let message;\n    for (message of r.messages) {\n      if (message instanceof tl_1.Api.MessageEmpty || fromId && __1.utils.getPeerId(message.peerId) != __1.utils.getPeerId(fromId)) {\n        (_b = this.buffer) === null || _b === void 0 ? void 0 : _b.push(undefined);\n      } else {\n        const temp = message;\n        temp._finishInit(this.client, entities, this._entity);\n        temp._entities = entities;\n        (_c = this.buffer) === null || _c === void 0 ? void 0 : _c.push(temp);\n      }\n    }\n  }\n}\nexports._IDsIter = _IDsIter;\nconst IterMessagesDefaults = {\n  limit: undefined,\n  offsetDate: undefined,\n  offsetId: 0,\n  maxId: 0,\n  minId: 0,\n  addOffset: 0,\n  search: undefined,\n  filter: undefined,\n  fromUser: undefined,\n  waitTime: undefined,\n  ids: undefined,\n  reverse: false,\n  replyTo: undefined,\n  scheduled: false\n};\n/** @hidden */\nfunction iterMessages(client, entity, options) {\n  const {\n    limit,\n    offsetDate,\n    offsetId,\n    maxId,\n    minId,\n    addOffset,\n    search,\n    filter,\n    fromUser,\n    waitTime,\n    ids,\n    reverse,\n    replyTo\n  } = Object.assign(Object.assign({}, IterMessagesDefaults), options);\n  if (ids) {\n    let idsArray;\n    if (!(0, Helpers_1.isArrayLike)(ids)) {\n      idsArray = [ids];\n    } else {\n      idsArray = ids;\n    }\n    return new _IDsIter(client, idsArray.length, {\n      reverse: reverse,\n      waitTime: waitTime\n    }, {\n      entity: entity,\n      ids: idsArray\n    });\n  }\n  return new _MessagesIter(client, limit, {\n    waitTime: waitTime,\n    reverse: reverse\n  }, {\n    entity: entity,\n    offsetId: offsetId,\n    minId: minId,\n    maxId: maxId,\n    fromUser: fromUser,\n    offsetDate: offsetDate,\n    addOffset: addOffset,\n    filter: filter,\n    search: search,\n    replyTo: replyTo\n  });\n}\nexports.iterMessages = iterMessages;\n/** @hidden */\nasync function getMessages(client, entity, params) {\n  var e_2, _a;\n  if (Object.keys(params).length == 1 && params.limit === undefined) {\n    if (params.minId === undefined && params.maxId === undefined) {\n      params.limit = undefined;\n    } else {\n      params.limit = 1;\n    }\n  }\n  const it = client.iterMessages(entity, params);\n  const ids = params.ids;\n  if (ids && !(0, Helpers_1.isArrayLike)(ids)) {\n    try {\n      for (var it_1 = __asyncValues(it), it_1_1; it_1_1 = await it_1.next(), !it_1_1.done;) {\n        const message = it_1_1.value;\n        return [message];\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (it_1_1 && !it_1_1.done && (_a = it_1.return)) await _a.call(it_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    return [];\n  }\n  return await it.collect();\n}\nexports.getMessages = getMessages;\n// region Message\n/** @hidden */\nasync function sendMessage(client, /** To who will it be sent. */\nentity,\n/**  The message to be sent, or another message object to resend as a copy.<br/>\r\n * The maximum length for a message is 35,000 bytes or 4,096 characters.<br/>\r\n * Longer messages will not be sliced automatically, and you should slice them manually if the text to send is longer than said length. */\n{\n  message,\n  replyTo,\n  attributes,\n  parseMode,\n  formattingEntities,\n  linkPreview = true,\n  file,\n  thumb,\n  forceDocument,\n  clearDraft,\n  buttons,\n  silent,\n  supportStreaming,\n  schedule,\n  noforwards,\n  commentTo,\n  topMsgId\n} = {}) {\n  if (file) {\n    return client.sendFile(entity, {\n      file: file,\n      caption: message ? typeof message == \"string\" ? message : message.message : \"\",\n      forceDocument: forceDocument,\n      clearDraft: clearDraft,\n      replyTo: replyTo,\n      attributes: attributes,\n      thumb: thumb,\n      supportsStreaming: supportStreaming,\n      parseMode: parseMode,\n      formattingEntities: formattingEntities,\n      silent: silent,\n      scheduleDate: schedule,\n      buttons: buttons,\n      noforwards: noforwards,\n      commentTo: commentTo,\n      topMsgId: topMsgId\n    });\n  }\n  entity = await client.getInputEntity(entity);\n  if (commentTo != undefined) {\n    const discussionData = await getCommentData(client, entity, commentTo);\n    entity = discussionData.entity;\n    replyTo = discussionData.replyTo;\n  }\n  let markup, request;\n  let replyObject = undefined;\n  if (replyTo != undefined) {\n    replyObject = new tl_1.Api.InputReplyToMessage({\n      replyToMsgId: (0, Utils_1.getMessageId)(replyTo),\n      topMsgId: (0, Utils_1.getMessageId)(topMsgId)\n    });\n  }\n  if (message && message instanceof tl_1.Api.Message) {\n    if (buttons == undefined) {\n      markup = message.replyMarkup;\n    } else {\n      markup = client.buildReplyMarkup(buttons);\n    }\n    if (silent == undefined) {\n      silent = message.silent;\n    }\n    if (message.media && !(message.media instanceof tl_1.Api.MessageMediaWebPage)) {\n      return client.sendFile(entity, {\n        file: message.media,\n        caption: message.message,\n        silent: silent,\n        replyTo: replyTo,\n        buttons: markup,\n        formattingEntities: message.entities,\n        scheduleDate: schedule\n      });\n    }\n    request = new tl_1.Api.messages.SendMessage({\n      peer: entity,\n      message: message.message || \"\",\n      silent: silent,\n      replyTo: replyObject,\n      replyMarkup: markup,\n      entities: message.entities,\n      clearDraft: clearDraft,\n      noWebpage: !(message.media instanceof tl_1.Api.MessageMediaWebPage),\n      scheduleDate: schedule,\n      noforwards: noforwards\n    });\n    message = message.message;\n  } else {\n    if (formattingEntities == undefined) {\n      [message, formattingEntities] = await (0, messageParse_1._parseMessageText)(client, message || \"\", parseMode);\n    }\n    if (!message) {\n      throw new Error(\"The message cannot be empty unless a file is provided\");\n    }\n    request = new tl_1.Api.messages.SendMessage({\n      peer: entity,\n      message: message.toString(),\n      entities: formattingEntities,\n      noWebpage: !linkPreview,\n      replyTo: replyObject,\n      clearDraft: clearDraft,\n      silent: silent,\n      replyMarkup: client.buildReplyMarkup(buttons),\n      scheduleDate: schedule,\n      noforwards: noforwards\n    });\n  }\n  const result = await client.invoke(request);\n  if (result instanceof tl_1.Api.UpdateShortSentMessage) {\n    const msg = new tl_1.Api.Message({\n      id: result.id,\n      peerId: await (0, users_1._getPeer)(client, entity),\n      message: message,\n      date: result.date,\n      out: result.out,\n      media: result.media,\n      entities: result.entities,\n      replyMarkup: request.replyMarkup,\n      ttlPeriod: result.ttlPeriod\n    });\n    msg._finishInit(client, new Map(), entity);\n    return msg;\n  }\n  return client._getResponseMessage(request, result, entity);\n}\nexports.sendMessage = sendMessage;\n/** @hidden */\nasync function forwardMessages(client, entity, {\n  messages,\n  fromPeer,\n  silent,\n  schedule,\n  noforwards,\n  dropAuthor\n}) {\n  if (!(0, Helpers_1.isArrayLike)(messages)) {\n    messages = [messages];\n  }\n  entity = await client.getInputEntity(entity);\n  let fromPeerId;\n  if (fromPeer) {\n    fromPeer = await client.getInputEntity(fromPeer);\n    fromPeerId = await client.getPeerId(fromPeer);\n  }\n  const getKey = m => {\n    if (m instanceof tl_1.Api.Message) {\n      return m.chatId;\n    }\n    let msgId = (0, Utils_1.parseID)(m);\n    if (msgId) {\n      if (fromPeerId !== undefined) {\n        return fromPeerId;\n      }\n      throw new Error(\"fromPeer must be given if integer IDs are used\");\n    } else {\n      throw new Error(`Cannot forward ${m}`);\n    }\n  };\n  const sent = [];\n  for (let [chatId, chunk] of (0, Helpers_1.groupBy)(messages, getKey)) {\n    let chat;\n    let numbers = [];\n    if (typeof chunk[0] == \"number\") {\n      chat = fromPeer;\n      numbers = chunk;\n    } else {\n      chat = await chunk[0].getInputChat();\n      numbers = chunk.map(m => m.id);\n    }\n    chunk.push();\n    const request = new tl_1.Api.messages.ForwardMessages({\n      fromPeer: chat,\n      id: numbers,\n      toPeer: entity,\n      silent: silent,\n      scheduleDate: schedule,\n      noforwards: noforwards,\n      dropAuthor: dropAuthor\n    });\n    const result = await client.invoke(request);\n    sent.push(client._getResponseMessage(request, result, entity));\n  }\n  return sent;\n}\nexports.forwardMessages = forwardMessages;\n/** @hidden */\nasync function editMessage(client, entity, {\n  message,\n  text,\n  parseMode,\n  formattingEntities,\n  linkPreview = true,\n  file,\n  forceDocument,\n  buttons,\n  schedule\n}) {\n  if (typeof message === \"number\" && typeof text === \"undefined\" && !file && !schedule) {\n    throw Error(\"You have to provide either file or text or schedule property.\");\n  }\n  entity = await client.getInputEntity(entity);\n  let id;\n  let markup;\n  let entities;\n  let inputMedia;\n  if (file) {\n    const {\n      fileHandle,\n      media,\n      image\n    } = await (0, uploads_1._fileToMedia)(client, {\n      file,\n      forceDocument\n    });\n    inputMedia = media;\n  }\n  if (message instanceof tl_1.Api.Message) {\n    id = (0, Utils_1.getMessageId)(message);\n    text = message.message;\n    entities = message.entities;\n    if (buttons == undefined) {\n      markup = message.replyMarkup;\n    } else {\n      markup = client.buildReplyMarkup(buttons);\n    }\n    if (message.media) {\n      inputMedia = (0, Utils_1.getInputMedia)(message.media, {\n        forceDocument\n      });\n    }\n  } else {\n    if (typeof message !== \"number\") {\n      throw Error(\"editMessageParams.message must be either a number or a Api.Message type\");\n    }\n    id = message;\n    if (formattingEntities == undefined) {\n      [text, entities] = await (0, messageParse_1._parseMessageText)(client, text || \"\", parseMode);\n    } else {\n      entities = formattingEntities;\n    }\n    markup = client.buildReplyMarkup(buttons);\n  }\n  const request = new tl_1.Api.messages.EditMessage({\n    peer: entity,\n    id,\n    message: text,\n    noWebpage: !linkPreview,\n    entities,\n    media: inputMedia,\n    replyMarkup: markup,\n    scheduleDate: schedule\n  });\n  const result = await client.invoke(request);\n  return client._getResponseMessage(request, result, entity);\n}\nexports.editMessage = editMessage;\n/** @hidden */\nasync function deleteMessages(client, entity, messageIds, {\n  revoke = false\n}) {\n  let ty = Helpers_1._EntityType.USER;\n  if (entity) {\n    entity = await client.getInputEntity(entity);\n    ty = (0, Helpers_1._entityType)(entity);\n  }\n  const ids = [];\n  for (const messageId of messageIds) {\n    if (messageId instanceof tl_1.Api.Message || messageId instanceof tl_1.Api.MessageService || messageId instanceof tl_1.Api.MessageEmpty) {\n      ids.push(messageId.id);\n    } else if (typeof messageId === \"number\") {\n      ids.push(messageId);\n    } else {\n      throw new Error(`Cannot convert ${messageId} to an integer`);\n    }\n  }\n  const results = [];\n  if (ty == Helpers_1._EntityType.CHANNEL) {\n    for (const chunk of __1.utils.chunks(ids)) {\n      results.push(client.invoke(new tl_1.Api.channels.DeleteMessages({\n        channel: entity,\n        id: chunk\n      })));\n    }\n  } else {\n    for (const chunk of __1.utils.chunks(ids)) {\n      results.push(client.invoke(new tl_1.Api.messages.DeleteMessages({\n        id: chunk,\n        revoke: revoke\n      })));\n    }\n  }\n  return Promise.all(results);\n}\nexports.deleteMessages = deleteMessages;\n/** @hidden */\nasync function pinMessage(client, entity, message, pinMessageParams) {\n  return await _pin(client, entity, message, false, pinMessageParams === null || pinMessageParams === void 0 ? void 0 : pinMessageParams.notify, pinMessageParams === null || pinMessageParams === void 0 ? void 0 : pinMessageParams.pmOneSide);\n}\nexports.pinMessage = pinMessage;\n/** @hidden */\nasync function unpinMessage(client, entity, message, unpinMessageParams) {\n  return await _pin(client, entity, message, true, unpinMessageParams === null || unpinMessageParams === void 0 ? void 0 : unpinMessageParams.notify, unpinMessageParams === null || unpinMessageParams === void 0 ? void 0 : unpinMessageParams.pmOneSide);\n}\nexports.unpinMessage = unpinMessage;\n/** @hidden */\nasync function _pin(client, entity, message, unpin, notify = false, pmOneSide = false) {\n  message = __1.utils.getMessageId(message) || 0;\n  if (message === 0) {\n    return await client.invoke(new tl_1.Api.messages.UnpinAllMessages({\n      peer: entity\n    }));\n  }\n  entity = await client.getInputEntity(entity);\n  const request = new tl_1.Api.messages.UpdatePinnedMessage({\n    silent: !notify,\n    unpin,\n    pmOneside: pmOneSide,\n    peer: entity,\n    id: message\n  });\n  const result = await client.invoke(request);\n  /**\r\n   * Unpinning does not produce a service message.\r\n   * Pinning a message that was already pinned also produces no service message.\r\n   * Pinning a message in your own chat does not produce a service message,\r\n   * but pinning on a private conversation with someone else does.\r\n   */\n  if (unpin || !(\"updates\" in result) || \"updates\" in result && !result.updates) {\n    return;\n  }\n  // Pinning a message that doesn't exist would RPC-error earlier\n  return client._getResponseMessage(request, result, entity);\n}\nexports._pin = _pin;\n/** @hidden */\nasync function markAsRead(client, entity, message, markAsReadParams) {\n  let maxId = (markAsReadParams === null || markAsReadParams === void 0 ? void 0 : markAsReadParams.maxId) || 0;\n  const maxIdIsUndefined = (markAsReadParams === null || markAsReadParams === void 0 ? void 0 : markAsReadParams.maxId) === undefined;\n  if (maxIdIsUndefined) {\n    if (message) {\n      if (Array.isArray(message)) {\n        maxId = Math.max(...message.map(v => __1.utils.getMessageId(v)));\n      } else {\n        maxId = __1.utils.getMessageId(message);\n      }\n    }\n  }\n  entity = await client.getInputEntity(entity);\n  if (markAsReadParams && !markAsReadParams.clearMentions) {\n    await client.invoke(new tl_1.Api.messages.ReadMentions({\n      peer: entity\n    }));\n    if (maxIdIsUndefined && message === undefined) {\n      return true;\n    }\n  }\n  if ((0, Helpers_1._entityType)(entity) === Helpers_1._EntityType.CHANNEL) {\n    return await client.invoke(new tl_1.Api.channels.ReadHistory({\n      channel: entity,\n      maxId\n    }));\n  } else {\n    await client.invoke(new tl_1.Api.messages.ReadHistory({\n      peer: entity,\n      maxId\n    }));\n    return true;\n  }\n}\nexports.markAsRead = markAsRead;\n/** @hidden */\nasync function getCommentData(client, entity, message) {\n  const result = await client.invoke(new tl_1.Api.messages.GetDiscussionMessage({\n    peer: entity,\n    msgId: __1.utils.getMessageId(message)\n  }));\n  const relevantMessage = result.messages[0];\n  let chat;\n  for (const c of result.chats) {\n    if (relevantMessage.peerId instanceof tl_1.Api.PeerChannel && c.id.eq(relevantMessage.peerId.channelId)) {\n      chat = c;\n      break;\n    }\n  }\n  return {\n    entity: __1.utils.getInputPeer(chat),\n    replyTo: relevantMessage.id\n  };\n}\nexports.getCommentData = getCommentData;\n// TODO do the rest","map":{"version":3,"names":["__asyncValues","o","Symbol","asyncIterator","TypeError","m","i","call","__values","iterator","verb","n","v","Promise","resolve","reject","settle","done","value","d","then","__importDefault","mod","__esModule","Object","defineProperty","exports","getCommentData","markAsRead","_pin","unpinMessage","pinMessage","deleteMessages","editMessage","forwardMessages","sendMessage","getMessages","iterMessages","_IDsIter","_MessagesIter","tl_1","require","requestIter_1","Helpers_1","Utils_1","__1","messageParse_1","users_1","big_integer_1","uploads_1","_MAX_CHUNK_SIZE","RequestIter","_init","entity","offsetId","minId","maxId","fromUser","offsetDate","addOffset","filter","search","replyTo","e_1","_a","client","getInputEntity","undefined","reverse","Error","Math","max","Number","MAX_SAFE_INTEGER","Api","InputPeerEmpty","InputMessagesFilterEmpty","request","messages","SearchGlobal","q","minDate","maxDate","offsetRate","offsetPeer","limit","GetReplies","peer","msgId","hash","default","zero","Search","generateRandomBigInt","fromId","_b","_c","next","id","e_1_1","error","return","GetHistory","result","invoke","MessagesNotModified","total","count","length","waitTime","lastId","_loadNextChunk","min","left","r","entities","Map","x","users","chats","set","getPeerId","message","_messageInRange","_finishInit","e","_entities","buffer","push","_updateOffset","lastMessage","response","date","inputChat","nextRate","ids","_ids","_offset","_entity","_ty","_entityType","slice","_EntityType","CHANNEL","channels","GetMessages","channel","errorMessage","_getPeer","Array","utils","MessageEmpty","peerId","temp","IterMessagesDefaults","scheduled","options","assign","idsArray","isArrayLike","params","e_2","keys","it","it_1","it_1_1","e_2_1","collect","attributes","parseMode","formattingEntities","linkPreview","file","thumb","forceDocument","clearDraft","buttons","silent","supportStreaming","schedule","noforwards","commentTo","topMsgId","sendFile","caption","supportsStreaming","scheduleDate","discussionData","markup","replyObject","InputReplyToMessage","replyToMsgId","getMessageId","Message","replyMarkup","buildReplyMarkup","media","MessageMediaWebPage","SendMessage","noWebpage","_parseMessageText","toString","UpdateShortSentMessage","msg","out","ttlPeriod","_getResponseMessage","fromPeer","dropAuthor","fromPeerId","getKey","chatId","parseID","sent","chunk","groupBy","chat","numbers","getInputChat","map","ForwardMessages","toPeer","text","inputMedia","fileHandle","image","_fileToMedia","getInputMedia","EditMessage","messageIds","revoke","ty","USER","messageId","MessageService","results","chunks","DeleteMessages","all","pinMessageParams","notify","pmOneSide","unpinMessageParams","unpin","UnpinAllMessages","UpdatePinnedMessage","pmOneside","updates","markAsReadParams","maxIdIsUndefined","isArray","clearMentions","ReadMentions","ReadHistory","GetDiscussionMessage","relevantMessage","c","PeerChannel","eq","channelId","getInputPeer"],"sources":["C:/Users/Muhammed/Desktop/REACT_JS/dene-gramjs/node_modules/telegram/client/messages.js"],"sourcesContent":["\"use strict\";\r\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getCommentData = exports.markAsRead = exports._pin = exports.unpinMessage = exports.pinMessage = exports.deleteMessages = exports.editMessage = exports.forwardMessages = exports.sendMessage = exports.getMessages = exports.iterMessages = exports._IDsIter = exports._MessagesIter = void 0;\r\nconst tl_1 = require(\"../tl\");\r\nconst requestIter_1 = require(\"../requestIter\");\r\nconst Helpers_1 = require(\"../Helpers\");\r\nconst Utils_1 = require(\"../Utils\");\r\nconst __1 = require(\"../\");\r\nconst messageParse_1 = require(\"./messageParse\");\r\nconst users_1 = require(\"./users\");\r\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\r\nconst uploads_1 = require(\"./uploads\");\r\nconst _MAX_CHUNK_SIZE = 100;\r\nclass _MessagesIter extends requestIter_1.RequestIter {\r\n    async _init({ entity, offsetId, minId, maxId, fromUser, offsetDate, addOffset, filter, search, replyTo, }) {\r\n        var e_1, _a;\r\n        if (entity) {\r\n            this.entity = await this.client.getInputEntity(entity);\r\n        }\r\n        else {\r\n            this.entity = undefined;\r\n            if (this.reverse) {\r\n                throw new Error(\"Cannot reverse global search\");\r\n            }\r\n        }\r\n        if (this.reverse) {\r\n            offsetId = Math.max(offsetId, minId);\r\n            if (offsetId && maxId) {\r\n                if (maxId - offsetId <= 1) {\r\n                    return false;\r\n                }\r\n            }\r\n            if (!maxId) {\r\n                maxId = Number.MAX_SAFE_INTEGER;\r\n            }\r\n        }\r\n        else {\r\n            offsetId = Math.max(offsetId, maxId);\r\n            if (offsetId && minId) {\r\n                if (offsetId - minId <= 1) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        if (this.reverse) {\r\n            if (offsetId) {\r\n                offsetId += 1;\r\n            }\r\n            else if (!offsetDate) {\r\n                offsetId = 1;\r\n            }\r\n        }\r\n        if (fromUser) {\r\n            fromUser = await this.client.getInputEntity(fromUser);\r\n        }\r\n        if (!this.entity && fromUser) {\r\n            this.entity = new tl_1.Api.InputPeerEmpty();\r\n        }\r\n        if (!filter) {\r\n            filter = new tl_1.Api.InputMessagesFilterEmpty();\r\n        }\r\n        if (!this.entity) {\r\n            this.request = new tl_1.Api.messages.SearchGlobal({\r\n                q: search || \"\",\r\n                filter: filter,\r\n                minDate: undefined,\r\n                // TODO fix this smh\r\n                maxDate: offsetDate,\r\n                offsetRate: undefined,\r\n                offsetPeer: new tl_1.Api.InputPeerEmpty(),\r\n                offsetId: offsetId,\r\n                limit: 1,\r\n            });\r\n        }\r\n        else if (replyTo !== undefined) {\r\n            this.request = new tl_1.Api.messages.GetReplies({\r\n                peer: this.entity,\r\n                msgId: replyTo,\r\n                offsetId: offsetId,\r\n                offsetDate: offsetDate,\r\n                addOffset: addOffset,\r\n                limit: 0,\r\n                maxId: 0,\r\n                minId: 0,\r\n                hash: big_integer_1.default.zero,\r\n            });\r\n        }\r\n        else if (search !== undefined ||\r\n            !(filter instanceof tl_1.Api.InputMessagesFilterEmpty) ||\r\n            fromUser !== undefined) {\r\n            this.request = new tl_1.Api.messages.Search({\r\n                peer: this.entity,\r\n                q: search || \"\",\r\n                filter: typeof filter === \"function\" ? new filter() : filter,\r\n                minDate: undefined,\r\n                maxDate: offsetDate,\r\n                offsetId: offsetId,\r\n                addOffset: addOffset,\r\n                limit: 0,\r\n                maxId: 0,\r\n                minId: 0,\r\n                hash: (0, Helpers_1.generateRandomBigInt)(),\r\n                fromId: fromUser,\r\n            });\r\n            if (!(filter instanceof tl_1.Api.InputMessagesFilterEmpty) &&\r\n                offsetDate &&\r\n                !search &&\r\n                !offsetId) {\r\n                try {\r\n                    for (var _b = __asyncValues(this.client.iterMessages(this.entity, {\r\n                        limit: 1,\r\n                        offsetDate: offsetDate,\r\n                    })), _c; _c = await _b.next(), !_c.done;) {\r\n                        const m = _c.value;\r\n                        this.request.offsetId = m.id + 1;\r\n                    }\r\n                }\r\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n                finally {\r\n                    try {\r\n                        if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);\r\n                    }\r\n                    finally { if (e_1) throw e_1.error; }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this.request = new tl_1.Api.messages.GetHistory({\r\n                peer: this.entity,\r\n                limit: 1,\r\n                offsetDate: offsetDate,\r\n                offsetId: offsetId,\r\n                minId: 0,\r\n                maxId: 0,\r\n                addOffset: addOffset,\r\n                hash: big_integer_1.default.zero,\r\n            });\r\n        }\r\n        if (this.limit <= 0) {\r\n            const result = await this.client.invoke(this.request);\r\n            if (result instanceof tl_1.Api.messages.MessagesNotModified) {\r\n                this.total = result.count;\r\n            }\r\n            else {\r\n                if (\"count\" in result) {\r\n                    this.total = result.count;\r\n                }\r\n                else {\r\n                    this.total = result.messages.length;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        if (!this.waitTime) {\r\n            this.waitTime = this.limit > 3000 ? 1 : 0;\r\n        }\r\n        if (this.reverse &&\r\n            !(this.request instanceof tl_1.Api.messages.SearchGlobal)) {\r\n            this.request.addOffset -= _MAX_CHUNK_SIZE;\r\n        }\r\n        this.addOffset = addOffset;\r\n        this.maxId = maxId;\r\n        this.minId = minId;\r\n        this.lastId = this.reverse ? 0 : Number.MAX_SAFE_INTEGER;\r\n    }\r\n    async _loadNextChunk() {\r\n        var _a;\r\n        if (!this.request) {\r\n            throw new Error(\"Request not set yet\");\r\n        }\r\n        this.request.limit = Math.min(this.left, _MAX_CHUNK_SIZE);\r\n        if (this.reverse && this.request.limit != _MAX_CHUNK_SIZE) {\r\n            if (!(this.request instanceof tl_1.Api.messages.SearchGlobal)) {\r\n                this.request.addOffset = this.addOffset - this.request.limit;\r\n            }\r\n        }\r\n        const r = await this.client.invoke(this.request);\r\n        if (r instanceof tl_1.Api.messages.MessagesNotModified) {\r\n            return true;\r\n        }\r\n        if (\"count\" in r) {\r\n            this.total = r.count;\r\n        }\r\n        else {\r\n            this.total = r.messages.length;\r\n        }\r\n        const entities = new Map();\r\n        for (const x of [...r.users, ...r.chats]) {\r\n            entities.set((0, Utils_1.getPeerId)(x), x);\r\n        }\r\n        const messages = this.reverse\r\n            ? r.messages.reverse()\r\n            : r.messages;\r\n        for (const message of messages) {\r\n            if (!this._messageInRange(message)) {\r\n                return true;\r\n            }\r\n            this.lastId = message.id;\r\n            try {\r\n                // if this fails it shouldn't be a big problem\r\n                message._finishInit(this.client, entities, this.entity);\r\n            }\r\n            catch (e) { }\r\n            message._entities = entities;\r\n            (_a = this.buffer) === null || _a === void 0 ? void 0 : _a.push(message);\r\n        }\r\n        if (r.messages.length < this.request.limit) {\r\n            return true;\r\n        }\r\n        if (this.buffer) {\r\n            this._updateOffset(this.buffer[this.buffer.length - 1], r);\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }\r\n    _messageInRange(message) {\r\n        if (this.entity) {\r\n            if (this.reverse) {\r\n                if (message.id <= this.lastId || message.id >= this.maxId) {\r\n                    return false;\r\n                }\r\n            }\r\n            else {\r\n                if (message.id >= this.lastId || message.id <= this.minId) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    [Symbol.asyncIterator]() {\r\n        return super[Symbol.asyncIterator]();\r\n    }\r\n    _updateOffset(lastMessage, response) {\r\n        if (!this.request) {\r\n            throw new Error(\"Request not set yet\");\r\n        }\r\n        this.request.offsetId = Number(lastMessage.id);\r\n        if (this.reverse) {\r\n            this.request.offsetId += 1;\r\n        }\r\n        if (this.request instanceof tl_1.Api.messages.Search) {\r\n            this.request.maxDate = -1;\r\n        }\r\n        else {\r\n            if (!(this.request instanceof tl_1.Api.messages.SearchGlobal)) {\r\n                this.request.offsetDate = lastMessage.date;\r\n            }\r\n        }\r\n        if (this.request instanceof tl_1.Api.messages.SearchGlobal) {\r\n            if (lastMessage.inputChat) {\r\n                this.request.offsetPeer = lastMessage.inputChat;\r\n            }\r\n            else {\r\n                this.request.offsetPeer = new tl_1.Api.InputPeerEmpty();\r\n            }\r\n            this.request.offsetRate = response.nextRate;\r\n        }\r\n    }\r\n}\r\nexports._MessagesIter = _MessagesIter;\r\nclass _IDsIter extends requestIter_1.RequestIter {\r\n    async _init({ entity, ids }) {\r\n        this.total = ids.length;\r\n        this._ids = this.reverse ? ids.reverse() : ids;\r\n        this._offset = 0;\r\n        this._entity = entity\r\n            ? await this.client.getInputEntity(entity)\r\n            : undefined;\r\n        this._ty = this._entity ? (0, Helpers_1._entityType)(this._entity) : undefined;\r\n        if (!this.waitTime) {\r\n            this.waitTime = this.limit > 300 ? 10 : 0;\r\n        }\r\n    }\r\n    [Symbol.asyncIterator]() {\r\n        return super[Symbol.asyncIterator]();\r\n    }\r\n    async _loadNextChunk() {\r\n        var _a, _b, _c;\r\n        const ids = this._ids.slice(this._offset, this._offset + _MAX_CHUNK_SIZE);\r\n        if (!ids.length) {\r\n            return false;\r\n        }\r\n        this._offset += _MAX_CHUNK_SIZE;\r\n        let fromId;\r\n        let r;\r\n        if (this._ty == Helpers_1._EntityType.CHANNEL) {\r\n            try {\r\n                r = await this.client.invoke(new tl_1.Api.channels.GetMessages({\r\n                    channel: this._entity,\r\n                    id: ids,\r\n                }));\r\n            }\r\n            catch (e) {\r\n                if (e.errorMessage == \"MESSAGE_IDS_EMPTY\") {\r\n                    r = new tl_1.Api.messages.MessagesNotModified({\r\n                        count: ids.length,\r\n                    });\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            r = await this.client.invoke(new tl_1.Api.messages.GetMessages({\r\n                id: ids,\r\n            }));\r\n            if (this._entity) {\r\n                fromId = await (0, users_1._getPeer)(this.client, this._entity);\r\n            }\r\n        }\r\n        if (r instanceof tl_1.Api.messages.MessagesNotModified) {\r\n            (_a = this.buffer) === null || _a === void 0 ? void 0 : _a.push(...Array(ids.length));\r\n            return;\r\n        }\r\n        const entities = new Map();\r\n        for (const entity of [...r.users, ...r.chats]) {\r\n            entities.set(__1.utils.getPeerId(entity), entity);\r\n        }\r\n        let message;\r\n        for (message of r.messages) {\r\n            if (message instanceof tl_1.Api.MessageEmpty ||\r\n                (fromId &&\r\n                    __1.utils.getPeerId(message.peerId) != __1.utils.getPeerId(fromId))) {\r\n                (_b = this.buffer) === null || _b === void 0 ? void 0 : _b.push(undefined);\r\n            }\r\n            else {\r\n                const temp = message;\r\n                temp._finishInit(this.client, entities, this._entity);\r\n                temp._entities = entities;\r\n                (_c = this.buffer) === null || _c === void 0 ? void 0 : _c.push(temp);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports._IDsIter = _IDsIter;\r\nconst IterMessagesDefaults = {\r\n    limit: undefined,\r\n    offsetDate: undefined,\r\n    offsetId: 0,\r\n    maxId: 0,\r\n    minId: 0,\r\n    addOffset: 0,\r\n    search: undefined,\r\n    filter: undefined,\r\n    fromUser: undefined,\r\n    waitTime: undefined,\r\n    ids: undefined,\r\n    reverse: false,\r\n    replyTo: undefined,\r\n    scheduled: false,\r\n};\r\n/** @hidden */\r\nfunction iterMessages(client, entity, options) {\r\n    const { limit, offsetDate, offsetId, maxId, minId, addOffset, search, filter, fromUser, waitTime, ids, reverse, replyTo, } = Object.assign(Object.assign({}, IterMessagesDefaults), options);\r\n    if (ids) {\r\n        let idsArray;\r\n        if (!(0, Helpers_1.isArrayLike)(ids)) {\r\n            idsArray = [ids];\r\n        }\r\n        else {\r\n            idsArray = ids;\r\n        }\r\n        return new _IDsIter(client, idsArray.length, {\r\n            reverse: reverse,\r\n            waitTime: waitTime,\r\n        }, {\r\n            entity: entity,\r\n            ids: idsArray,\r\n        });\r\n    }\r\n    return new _MessagesIter(client, limit, {\r\n        waitTime: waitTime,\r\n        reverse: reverse,\r\n    }, {\r\n        entity: entity,\r\n        offsetId: offsetId,\r\n        minId: minId,\r\n        maxId: maxId,\r\n        fromUser: fromUser,\r\n        offsetDate: offsetDate,\r\n        addOffset: addOffset,\r\n        filter: filter,\r\n        search: search,\r\n        replyTo: replyTo,\r\n    });\r\n}\r\nexports.iterMessages = iterMessages;\r\n/** @hidden */\r\nasync function getMessages(client, entity, params) {\r\n    var e_2, _a;\r\n    if (Object.keys(params).length == 1 && params.limit === undefined) {\r\n        if (params.minId === undefined && params.maxId === undefined) {\r\n            params.limit = undefined;\r\n        }\r\n        else {\r\n            params.limit = 1;\r\n        }\r\n    }\r\n    const it = client.iterMessages(entity, params);\r\n    const ids = params.ids;\r\n    if (ids && !(0, Helpers_1.isArrayLike)(ids)) {\r\n        try {\r\n            for (var it_1 = __asyncValues(it), it_1_1; it_1_1 = await it_1.next(), !it_1_1.done;) {\r\n                const message = it_1_1.value;\r\n                return [message];\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (it_1_1 && !it_1_1.done && (_a = it_1.return)) await _a.call(it_1);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        return [];\r\n    }\r\n    return (await it.collect());\r\n}\r\nexports.getMessages = getMessages;\r\n// region Message\r\n/** @hidden */\r\nasync function sendMessage(client, \r\n/** To who will it be sent. */\r\nentity, \r\n/**  The message to be sent, or another message object to resend as a copy.<br/>\r\n * The maximum length for a message is 35,000 bytes or 4,096 characters.<br/>\r\n * Longer messages will not be sliced automatically, and you should slice them manually if the text to send is longer than said length. */\r\n{ message, replyTo, attributes, parseMode, formattingEntities, linkPreview = true, file, thumb, forceDocument, clearDraft, buttons, silent, supportStreaming, schedule, noforwards, commentTo, topMsgId, } = {}) {\r\n    if (file) {\r\n        return client.sendFile(entity, {\r\n            file: file,\r\n            caption: message\r\n                ? typeof message == \"string\"\r\n                    ? message\r\n                    : message.message\r\n                : \"\",\r\n            forceDocument: forceDocument,\r\n            clearDraft: clearDraft,\r\n            replyTo: replyTo,\r\n            attributes: attributes,\r\n            thumb: thumb,\r\n            supportsStreaming: supportStreaming,\r\n            parseMode: parseMode,\r\n            formattingEntities: formattingEntities,\r\n            silent: silent,\r\n            scheduleDate: schedule,\r\n            buttons: buttons,\r\n            noforwards: noforwards,\r\n            commentTo: commentTo,\r\n            topMsgId: topMsgId,\r\n        });\r\n    }\r\n    entity = await client.getInputEntity(entity);\r\n    if (commentTo != undefined) {\r\n        const discussionData = await getCommentData(client, entity, commentTo);\r\n        entity = discussionData.entity;\r\n        replyTo = discussionData.replyTo;\r\n    }\r\n    let markup, request;\r\n    let replyObject = undefined;\r\n    if (replyTo != undefined) {\r\n        replyObject = new tl_1.Api.InputReplyToMessage({\r\n            replyToMsgId: (0, Utils_1.getMessageId)(replyTo),\r\n            topMsgId: (0, Utils_1.getMessageId)(topMsgId),\r\n        });\r\n    }\r\n    if (message && message instanceof tl_1.Api.Message) {\r\n        if (buttons == undefined) {\r\n            markup = message.replyMarkup;\r\n        }\r\n        else {\r\n            markup = client.buildReplyMarkup(buttons);\r\n        }\r\n        if (silent == undefined) {\r\n            silent = message.silent;\r\n        }\r\n        if (message.media &&\r\n            !(message.media instanceof tl_1.Api.MessageMediaWebPage)) {\r\n            return client.sendFile(entity, {\r\n                file: message.media,\r\n                caption: message.message,\r\n                silent: silent,\r\n                replyTo: replyTo,\r\n                buttons: markup,\r\n                formattingEntities: message.entities,\r\n                scheduleDate: schedule,\r\n            });\r\n        }\r\n        request = new tl_1.Api.messages.SendMessage({\r\n            peer: entity,\r\n            message: message.message || \"\",\r\n            silent: silent,\r\n            replyTo: replyObject,\r\n            replyMarkup: markup,\r\n            entities: message.entities,\r\n            clearDraft: clearDraft,\r\n            noWebpage: !(message.media instanceof tl_1.Api.MessageMediaWebPage),\r\n            scheduleDate: schedule,\r\n            noforwards: noforwards,\r\n        });\r\n        message = message.message;\r\n    }\r\n    else {\r\n        if (formattingEntities == undefined) {\r\n            [message, formattingEntities] = await (0, messageParse_1._parseMessageText)(client, message || \"\", parseMode);\r\n        }\r\n        if (!message) {\r\n            throw new Error(\"The message cannot be empty unless a file is provided\");\r\n        }\r\n        request = new tl_1.Api.messages.SendMessage({\r\n            peer: entity,\r\n            message: message.toString(),\r\n            entities: formattingEntities,\r\n            noWebpage: !linkPreview,\r\n            replyTo: replyObject,\r\n            clearDraft: clearDraft,\r\n            silent: silent,\r\n            replyMarkup: client.buildReplyMarkup(buttons),\r\n            scheduleDate: schedule,\r\n            noforwards: noforwards,\r\n        });\r\n    }\r\n    const result = await client.invoke(request);\r\n    if (result instanceof tl_1.Api.UpdateShortSentMessage) {\r\n        const msg = new tl_1.Api.Message({\r\n            id: result.id,\r\n            peerId: await (0, users_1._getPeer)(client, entity),\r\n            message: message,\r\n            date: result.date,\r\n            out: result.out,\r\n            media: result.media,\r\n            entities: result.entities,\r\n            replyMarkup: request.replyMarkup,\r\n            ttlPeriod: result.ttlPeriod,\r\n        });\r\n        msg._finishInit(client, new Map(), entity);\r\n        return msg;\r\n    }\r\n    return client._getResponseMessage(request, result, entity);\r\n}\r\nexports.sendMessage = sendMessage;\r\n/** @hidden */\r\nasync function forwardMessages(client, entity, { messages, fromPeer, silent, schedule, noforwards, dropAuthor, }) {\r\n    if (!(0, Helpers_1.isArrayLike)(messages)) {\r\n        messages = [messages];\r\n    }\r\n    entity = await client.getInputEntity(entity);\r\n    let fromPeerId;\r\n    if (fromPeer) {\r\n        fromPeer = await client.getInputEntity(fromPeer);\r\n        fromPeerId = await client.getPeerId(fromPeer);\r\n    }\r\n    const getKey = (m) => {\r\n        if (m instanceof tl_1.Api.Message) {\r\n            return m.chatId;\r\n        }\r\n        let msgId = (0, Utils_1.parseID)(m);\r\n        if (msgId) {\r\n            if (fromPeerId !== undefined) {\r\n                return fromPeerId;\r\n            }\r\n            throw new Error(\"fromPeer must be given if integer IDs are used\");\r\n        }\r\n        else {\r\n            throw new Error(`Cannot forward ${m}`);\r\n        }\r\n    };\r\n    const sent = [];\r\n    for (let [chatId, chunk] of (0, Helpers_1.groupBy)(messages, getKey)) {\r\n        let chat;\r\n        let numbers = [];\r\n        if (typeof chunk[0] == \"number\") {\r\n            chat = fromPeer;\r\n            numbers = chunk;\r\n        }\r\n        else {\r\n            chat = await chunk[0].getInputChat();\r\n            numbers = chunk.map((m) => m.id);\r\n        }\r\n        chunk.push();\r\n        const request = new tl_1.Api.messages.ForwardMessages({\r\n            fromPeer: chat,\r\n            id: numbers,\r\n            toPeer: entity,\r\n            silent: silent,\r\n            scheduleDate: schedule,\r\n            noforwards: noforwards,\r\n            dropAuthor: dropAuthor,\r\n        });\r\n        const result = await client.invoke(request);\r\n        sent.push(client._getResponseMessage(request, result, entity));\r\n    }\r\n    return sent;\r\n}\r\nexports.forwardMessages = forwardMessages;\r\n/** @hidden */\r\nasync function editMessage(client, entity, { message, text, parseMode, formattingEntities, linkPreview = true, file, forceDocument, buttons, schedule, }) {\r\n    if (typeof message === \"number\" &&\r\n        typeof text === \"undefined\" &&\r\n        !file &&\r\n        !schedule) {\r\n        throw Error(\"You have to provide either file or text or schedule property.\");\r\n    }\r\n    entity = await client.getInputEntity(entity);\r\n    let id;\r\n    let markup;\r\n    let entities;\r\n    let inputMedia;\r\n    if (file) {\r\n        const { fileHandle, media, image } = await (0, uploads_1._fileToMedia)(client, {\r\n            file,\r\n            forceDocument,\r\n        });\r\n        inputMedia = media;\r\n    }\r\n    if (message instanceof tl_1.Api.Message) {\r\n        id = (0, Utils_1.getMessageId)(message);\r\n        text = message.message;\r\n        entities = message.entities;\r\n        if (buttons == undefined) {\r\n            markup = message.replyMarkup;\r\n        }\r\n        else {\r\n            markup = client.buildReplyMarkup(buttons);\r\n        }\r\n        if (message.media) {\r\n            inputMedia = (0, Utils_1.getInputMedia)(message.media, { forceDocument });\r\n        }\r\n    }\r\n    else {\r\n        if (typeof message !== \"number\") {\r\n            throw Error(\"editMessageParams.message must be either a number or a Api.Message type\");\r\n        }\r\n        id = message;\r\n        if (formattingEntities == undefined) {\r\n            [text, entities] = await (0, messageParse_1._parseMessageText)(client, text || \"\", parseMode);\r\n        }\r\n        else {\r\n            entities = formattingEntities;\r\n        }\r\n        markup = client.buildReplyMarkup(buttons);\r\n    }\r\n    const request = new tl_1.Api.messages.EditMessage({\r\n        peer: entity,\r\n        id,\r\n        message: text,\r\n        noWebpage: !linkPreview,\r\n        entities,\r\n        media: inputMedia,\r\n        replyMarkup: markup,\r\n        scheduleDate: schedule,\r\n    });\r\n    const result = await client.invoke(request);\r\n    return client._getResponseMessage(request, result, entity);\r\n}\r\nexports.editMessage = editMessage;\r\n/** @hidden */\r\nasync function deleteMessages(client, entity, messageIds, { revoke = false }) {\r\n    let ty = Helpers_1._EntityType.USER;\r\n    if (entity) {\r\n        entity = await client.getInputEntity(entity);\r\n        ty = (0, Helpers_1._entityType)(entity);\r\n    }\r\n    const ids = [];\r\n    for (const messageId of messageIds) {\r\n        if (messageId instanceof tl_1.Api.Message ||\r\n            messageId instanceof tl_1.Api.MessageService ||\r\n            messageId instanceof tl_1.Api.MessageEmpty) {\r\n            ids.push(messageId.id);\r\n        }\r\n        else if (typeof messageId === \"number\") {\r\n            ids.push(messageId);\r\n        }\r\n        else {\r\n            throw new Error(`Cannot convert ${messageId} to an integer`);\r\n        }\r\n    }\r\n    const results = [];\r\n    if (ty == Helpers_1._EntityType.CHANNEL) {\r\n        for (const chunk of __1.utils.chunks(ids)) {\r\n            results.push(client.invoke(new tl_1.Api.channels.DeleteMessages({\r\n                channel: entity,\r\n                id: chunk,\r\n            })));\r\n        }\r\n    }\r\n    else {\r\n        for (const chunk of __1.utils.chunks(ids)) {\r\n            results.push(client.invoke(new tl_1.Api.messages.DeleteMessages({\r\n                id: chunk,\r\n                revoke: revoke,\r\n            })));\r\n        }\r\n    }\r\n    return Promise.all(results);\r\n}\r\nexports.deleteMessages = deleteMessages;\r\n/** @hidden */\r\nasync function pinMessage(client, entity, message, pinMessageParams) {\r\n    return await _pin(client, entity, message, false, pinMessageParams === null || pinMessageParams === void 0 ? void 0 : pinMessageParams.notify, pinMessageParams === null || pinMessageParams === void 0 ? void 0 : pinMessageParams.pmOneSide);\r\n}\r\nexports.pinMessage = pinMessage;\r\n/** @hidden */\r\nasync function unpinMessage(client, entity, message, unpinMessageParams) {\r\n    return await _pin(client, entity, message, true, unpinMessageParams === null || unpinMessageParams === void 0 ? void 0 : unpinMessageParams.notify, unpinMessageParams === null || unpinMessageParams === void 0 ? void 0 : unpinMessageParams.pmOneSide);\r\n}\r\nexports.unpinMessage = unpinMessage;\r\n/** @hidden */\r\nasync function _pin(client, entity, message, unpin, notify = false, pmOneSide = false) {\r\n    message = __1.utils.getMessageId(message) || 0;\r\n    if (message === 0) {\r\n        return await client.invoke(new tl_1.Api.messages.UnpinAllMessages({\r\n            peer: entity,\r\n        }));\r\n    }\r\n    entity = await client.getInputEntity(entity);\r\n    const request = new tl_1.Api.messages.UpdatePinnedMessage({\r\n        silent: !notify,\r\n        unpin,\r\n        pmOneside: pmOneSide,\r\n        peer: entity,\r\n        id: message,\r\n    });\r\n    const result = await client.invoke(request);\r\n    /**\r\n     * Unpinning does not produce a service message.\r\n     * Pinning a message that was already pinned also produces no service message.\r\n     * Pinning a message in your own chat does not produce a service message,\r\n     * but pinning on a private conversation with someone else does.\r\n     */\r\n    if (unpin ||\r\n        !(\"updates\" in result) ||\r\n        (\"updates\" in result && !result.updates)) {\r\n        return;\r\n    }\r\n    // Pinning a message that doesn't exist would RPC-error earlier\r\n    return client._getResponseMessage(request, result, entity);\r\n}\r\nexports._pin = _pin;\r\n/** @hidden */\r\nasync function markAsRead(client, entity, message, markAsReadParams) {\r\n    let maxId = (markAsReadParams === null || markAsReadParams === void 0 ? void 0 : markAsReadParams.maxId) || 0;\r\n    const maxIdIsUndefined = (markAsReadParams === null || markAsReadParams === void 0 ? void 0 : markAsReadParams.maxId) === undefined;\r\n    if (maxIdIsUndefined) {\r\n        if (message) {\r\n            if (Array.isArray(message)) {\r\n                maxId = Math.max(...message.map((v) => __1.utils.getMessageId(v)));\r\n            }\r\n            else {\r\n                maxId = __1.utils.getMessageId(message);\r\n            }\r\n        }\r\n    }\r\n    entity = await client.getInputEntity(entity);\r\n    if (markAsReadParams && !markAsReadParams.clearMentions) {\r\n        await client.invoke(new tl_1.Api.messages.ReadMentions({ peer: entity }));\r\n        if (maxIdIsUndefined && message === undefined) {\r\n            return true;\r\n        }\r\n    }\r\n    if ((0, Helpers_1._entityType)(entity) === Helpers_1._EntityType.CHANNEL) {\r\n        return await client.invoke(new tl_1.Api.channels.ReadHistory({ channel: entity, maxId }));\r\n    }\r\n    else {\r\n        await client.invoke(new tl_1.Api.messages.ReadHistory({ peer: entity, maxId }));\r\n        return true;\r\n    }\r\n}\r\nexports.markAsRead = markAsRead;\r\n/** @hidden */\r\nasync function getCommentData(client, entity, message) {\r\n    const result = await client.invoke(new tl_1.Api.messages.GetDiscussionMessage({\r\n        peer: entity,\r\n        msgId: __1.utils.getMessageId(message),\r\n    }));\r\n    const relevantMessage = result.messages[0];\r\n    let chat;\r\n    for (const c of result.chats) {\r\n        if (relevantMessage.peerId instanceof tl_1.Api.PeerChannel &&\r\n            c.id.eq(relevantMessage.peerId.channelId)) {\r\n            chat = c;\r\n            break;\r\n        }\r\n    }\r\n    return {\r\n        entity: __1.utils.getInputPeer(chat),\r\n        replyTo: relevantMessage.id,\r\n    };\r\n}\r\nexports.getCommentData = getCommentData;\r\n// TODO do the rest\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}