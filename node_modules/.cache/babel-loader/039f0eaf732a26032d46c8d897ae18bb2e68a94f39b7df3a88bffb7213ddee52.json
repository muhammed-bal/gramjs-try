{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.variableSnakeToCamelCase = exports.snakeToCamelCase = exports.CORE_TYPES = exports.fromLine = exports.buildArgConfig = exports.parseTl = exports.findAll = exports.serializeDate = exports.serializeBytes = void 0;\nconst buffer_1 = require(\"buffer/\");\nconst Helpers_1 = require(\"../Helpers\");\nconst snakeToCamelCase = name => {\n  const result = name.replace(/(?:^|_)([a-z])/g, (_, g) => g.toUpperCase());\n  return result.replace(/_/g, \"\");\n};\nexports.snakeToCamelCase = snakeToCamelCase;\nconst variableSnakeToCamelCase = str => str.replace(/([-_][a-z])/g, group => group.toUpperCase().replace(\"-\", \"\").replace(\"_\", \"\"));\nexports.variableSnakeToCamelCase = variableSnakeToCamelCase;\nconst CORE_TYPES = new Set([0xbc799737, 0x997275b5, 0x3fedd339, 0xc4b9f9bb, 0x56730bcc // null#56730bcc = Null;\n]);\n\nexports.CORE_TYPES = CORE_TYPES;\nconst AUTH_KEY_TYPES = new Set([0x05162463, 0x83c95aec, 0xa9f55f95, 0x3c6a84d4, 0x56fddf88, 0xd0e8075c, 0xb5890dba, 0x6643b654, 0xd712e4be, 0xf5045f1f, 0x3072cfa1 // gzip_packed\n]);\n\nconst fromLine = (line, isFunction) => {\n  const match = line.match(/([\\w.]+)(?:#([0-9a-fA-F]+))?(?:\\s{?\\w+:[\\w\\d<>#.?!]+}?)*\\s=\\s([\\w\\d<>#.?]+);$/);\n  if (!match) {\n    // Probably \"vector#1cb5c415 {t:Type} # [ t ] = Vector t;\"\n    throw new Error(`Cannot parse TLObject ${line}`);\n  }\n  const argsMatch = findAll(/({)?(\\w+):([\\w\\d<>#.?!]+)}?/, line);\n  const currentConfig = {\n    name: match[1],\n    constructorId: parseInt(match[2], 16),\n    argsConfig: {},\n    subclassOfId: (0, Helpers_1.crc32)(match[3]),\n    result: match[3],\n    isFunction: isFunction,\n    namespace: undefined\n  };\n  if (!currentConfig.constructorId) {\n    const hexId = \"\";\n    let args;\n    if (Object.values(currentConfig.argsConfig).length) {\n      args = ` ${Object.keys(currentConfig.argsConfig).map(arg => arg.toString()).join(\" \")}`;\n    } else {\n      args = \"\";\n    }\n    const representation = `${currentConfig.name}${hexId}${args} = ${currentConfig.result}`.replace(/(:|\\?)bytes /g, \"$1string \").replace(/</g, \" \").replace(/>|{|}/g, \"\").replace(/ \\w+:flags(\\d+)?\\.\\d+\\?true/g, \"\");\n    if (currentConfig.name === \"inputMediaInvoice\") {\n      // eslint-disable-next-line no-empty\n      if (currentConfig.name === \"inputMediaInvoice\") {}\n    }\n    currentConfig.constructorId = (0, Helpers_1.crc32)(buffer_1.Buffer.from(representation, \"utf8\"));\n  }\n  for (const [brace, name, argType] of argsMatch) {\n    if (brace === undefined) {\n      // @ts-ignore\n      currentConfig.argsConfig[variableSnakeToCamelCase(name)] = buildArgConfig(name, argType);\n    }\n  }\n  if (currentConfig.name.includes(\".\")) {\n    [currentConfig.namespace, currentConfig.name] = currentConfig.name.split(/\\.(.+)/);\n  }\n  currentConfig.name = snakeToCamelCase(currentConfig.name);\n  /*\r\n  for (const arg in currentConfig.argsConfig){\r\n    if (currentConfig.argsConfig.hasOwnProperty(arg)){\r\n      if (currentConfig.argsConfig[arg].flagIndicator){\r\n        delete  currentConfig.argsConfig[arg]\r\n      }\r\n    }\r\n  }*/\n  return currentConfig;\n};\nexports.fromLine = fromLine;\nfunction buildArgConfig(name, argType) {\n  name = name === \"self\" ? \"is_self\" : name;\n  // Default values\n  const currentConfig = {\n    isVector: false,\n    isFlag: false,\n    skipConstructorId: false,\n    flagName: null,\n    flagIndex: -1,\n    flagIndicator: true,\n    type: null,\n    useVectorId: null\n  };\n  // Special case: some types can be inferred, which makes it\n  // less annoying to type. Currently the only type that can\n  // be inferred is if the name is 'random_id', to which a\n  // random ID will be assigned if left as None (the default)\n  const canBeInferred = name === \"random_id\";\n  // The type can be an indicator that other arguments will be flags\n  if (argType !== \"#\") {\n    currentConfig.flagIndicator = false;\n    // Strip the exclamation mark always to have only the name\n    currentConfig.type = argType.replace(/^!+/, \"\");\n    // The type may be a flag (flags.IDX?REAL_TYPE)\n    // Note that 'flags' is NOT the flags name; this\n    // is determined by a previous argument\n    // However, we assume that the argument will always be starts with 'flags'\n    // @ts-ignore\n    const flagMatch = currentConfig.type.match(/(flags(?:\\d+)?).(\\d+)\\?([\\w<>.]+)/);\n    if (flagMatch) {\n      currentConfig.isFlag = true;\n      // As of layer 140, flagName can be \"flags\" or \"flags2\"\n      currentConfig.flagName = flagMatch[1];\n      currentConfig.flagIndex = Number(flagMatch[2]);\n      // Update the type to match the exact type, not the \"flagged\" one\n      currentConfig.type = flagMatch[3];\n    }\n    // Then check if the type is a Vector<REAL_TYPE>\n    // @ts-ignore\n    const vectorMatch = currentConfig.type.match(/[Vv]ector<([\\w\\d.]+)>/);\n    if (vectorMatch) {\n      currentConfig.isVector = true;\n      // If the type's first letter is not uppercase, then\n      // it is a constructor and we use (read/write) its ID.\n      // @ts-ignore\n      currentConfig.useVectorId = currentConfig.type.charAt(0) === \"V\";\n      // Update the type to match the one inside the vector\n      [, currentConfig.type] = vectorMatch;\n    }\n    // See use_vector_id. An example of such case is ipPort in\n    // help.configSpecial\n    // @ts-ignore\n    if (/^[a-z]$/.test(currentConfig.type.split(\".\").pop().charAt(0))) {\n      currentConfig.skipConstructorId = true;\n    }\n    // The name may contain \"date\" in it, if this is the case and\n    // the type is \"int\", we can safely assume that this should be\n    // treated as a \"date\" object. Note that this is not a valid\n    // Telegram object, but it's easier to work with\n    // if (\n    //     this.type === 'int' &&\n    //     (/(\\b|_)([dr]ate|until|since)(\\b|_)/.test(name) ||\n    //         ['expires', 'expires_at', 'was_online'].includes(name))\n    // ) {\n    //     this.type = 'date';\n    // }\n  }\n  // workaround\n  if (currentConfig.type == \"future_salt\") {\n    currentConfig.type = \"FutureSalt\";\n  }\n  return currentConfig;\n}\nexports.buildArgConfig = buildArgConfig;\nconst parseTl = function* (content, layer, methods = [], ignoreIds = CORE_TYPES) {\n  const methodInfo = (methods || []).reduce((o, m) => Object.assign(Object.assign({}, o), {\n    [m.name]: m\n  }), {});\n  const objAll = [];\n  const objByName = {};\n  const objByType = {};\n  const file = content;\n  let isFunction = false;\n  for (let line of file.split(\"\\n\")) {\n    const commentIndex = line.indexOf(\"//\");\n    if (commentIndex !== -1) {\n      line = line.slice(0, commentIndex);\n    }\n    line = line.trim();\n    if (!line) {\n      continue;\n    }\n    const match = line.match(/---(\\w+)---/);\n    if (match) {\n      const [, followingTypes] = match;\n      isFunction = followingTypes === \"functions\";\n      continue;\n    }\n    try {\n      const result = fromLine(line, isFunction);\n      if (ignoreIds.has(result.constructorId)) {\n        continue;\n      }\n      objAll.push(result);\n      if (!result.isFunction) {\n        if (!objByType[result.result]) {\n          objByType[result.result] = [];\n        }\n        objByName[result.name] = result;\n        objByType[result.result].push(result);\n      }\n    } catch (e) {\n      if (!e.toString().includes(\"vector#1cb5c415\")) {\n        throw e;\n      }\n    }\n  }\n  // Once all objects have been parsed, replace the\n  // string type from the arguments with references\n  for (const obj of objAll) {\n    if (AUTH_KEY_TYPES.has(obj.constructorId)) {\n      for (const arg in obj.argsConfig) {\n        if (obj.argsConfig[arg].type === \"string\") {\n          obj.argsConfig[arg].type = \"bytes\";\n        }\n      }\n    }\n  }\n  for (const obj of objAll) {\n    yield obj;\n  }\n};\nexports.parseTl = parseTl;\nconst findAll = (regex, str, matches = []) => {\n  if (!regex.flags.includes(\"g\")) {\n    regex = new RegExp(regex.source, \"g\");\n  }\n  const res = regex.exec(str);\n  if (res) {\n    matches.push(res.slice(1));\n    findAll(regex, str, matches);\n  }\n  return matches;\n};\nexports.findAll = findAll;\nfunction serializeBytes(data) {\n  if (!(data instanceof buffer_1.Buffer)) {\n    if (typeof data == \"string\") {\n      data = buffer_1.Buffer.from(data);\n    } else {\n      throw Error(`Bytes or str expected, not ${data.constructor.name}`);\n    }\n  }\n  const r = [];\n  let padding;\n  if (data.length < 254) {\n    padding = (data.length + 1) % 4;\n    if (padding !== 0) {\n      padding = 4 - padding;\n    }\n    r.push(buffer_1.Buffer.from([data.length]));\n    r.push(data);\n  } else {\n    padding = data.length % 4;\n    if (padding !== 0) {\n      padding = 4 - padding;\n    }\n    r.push(buffer_1.Buffer.from([254, data.length % 256, (data.length >> 8) % 256, (data.length >> 16) % 256]));\n    r.push(data);\n  }\n  r.push(buffer_1.Buffer.alloc(padding).fill(0));\n  return buffer_1.Buffer.concat(r);\n}\nexports.serializeBytes = serializeBytes;\nfunction serializeDate(dt) {\n  if (!dt) {\n    return buffer_1.Buffer.alloc(4).fill(0);\n  }\n  if (dt instanceof Date) {\n    dt = Math.floor((Date.now() - dt.getTime()) / 1000);\n  }\n  if (typeof dt == \"number\") {\n    const t = buffer_1.Buffer.alloc(4);\n    t.writeInt32LE(dt, 0);\n    return t;\n  }\n  throw Error(`Cannot interpret \"${dt}\" as a date`);\n}\nexports.serializeDate = serializeDate;","map":{"version":3,"names":["Object","defineProperty","exports","value","variableSnakeToCamelCase","snakeToCamelCase","CORE_TYPES","fromLine","buildArgConfig","parseTl","findAll","serializeDate","serializeBytes","buffer_1","require","Helpers_1","name","result","replace","_","g","toUpperCase","str","group","Set","AUTH_KEY_TYPES","line","isFunction","match","Error","argsMatch","currentConfig","constructorId","parseInt","argsConfig","subclassOfId","crc32","namespace","undefined","hexId","args","values","length","keys","map","arg","toString","join","representation","Buffer","from","brace","argType","includes","split","isVector","isFlag","skipConstructorId","flagName","flagIndex","flagIndicator","type","useVectorId","canBeInferred","flagMatch","Number","vectorMatch","charAt","test","pop","content","layer","methods","ignoreIds","methodInfo","reduce","o","m","assign","objAll","objByName","objByType","file","commentIndex","indexOf","slice","trim","followingTypes","has","push","e","obj","regex","matches","flags","RegExp","source","res","exec","data","constructor","r","padding","alloc","fill","concat","dt","Date","Math","floor","now","getTime","t","writeInt32LE"],"sources":["C:/Users/Muhammed/Desktop/REACT_JS/dene-gramjs/node_modules/telegram/tl/generationHelpers.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.variableSnakeToCamelCase = exports.snakeToCamelCase = exports.CORE_TYPES = exports.fromLine = exports.buildArgConfig = exports.parseTl = exports.findAll = exports.serializeDate = exports.serializeBytes = void 0;\r\nconst buffer_1 = require(\"buffer/\");\r\nconst Helpers_1 = require(\"../Helpers\");\r\nconst snakeToCamelCase = (name) => {\r\n    const result = name.replace(/(?:^|_)([a-z])/g, (_, g) => g.toUpperCase());\r\n    return result.replace(/_/g, \"\");\r\n};\r\nexports.snakeToCamelCase = snakeToCamelCase;\r\nconst variableSnakeToCamelCase = (str) => str.replace(/([-_][a-z])/g, (group) => group.toUpperCase().replace(\"-\", \"\").replace(\"_\", \"\"));\r\nexports.variableSnakeToCamelCase = variableSnakeToCamelCase;\r\nconst CORE_TYPES = new Set([\r\n    0xbc799737,\r\n    0x997275b5,\r\n    0x3fedd339,\r\n    0xc4b9f9bb,\r\n    0x56730bcc, // null#56730bcc = Null;\r\n]);\r\nexports.CORE_TYPES = CORE_TYPES;\r\nconst AUTH_KEY_TYPES = new Set([\r\n    0x05162463,\r\n    0x83c95aec,\r\n    0xa9f55f95,\r\n    0x3c6a84d4,\r\n    0x56fddf88,\r\n    0xd0e8075c,\r\n    0xb5890dba,\r\n    0x6643b654,\r\n    0xd712e4be,\r\n    0xf5045f1f,\r\n    0x3072cfa1, // gzip_packed\r\n]);\r\nconst fromLine = (line, isFunction) => {\r\n    const match = line.match(/([\\w.]+)(?:#([0-9a-fA-F]+))?(?:\\s{?\\w+:[\\w\\d<>#.?!]+}?)*\\s=\\s([\\w\\d<>#.?]+);$/);\r\n    if (!match) {\r\n        // Probably \"vector#1cb5c415 {t:Type} # [ t ] = Vector t;\"\r\n        throw new Error(`Cannot parse TLObject ${line}`);\r\n    }\r\n    const argsMatch = findAll(/({)?(\\w+):([\\w\\d<>#.?!]+)}?/, line);\r\n    const currentConfig = {\r\n        name: match[1],\r\n        constructorId: parseInt(match[2], 16),\r\n        argsConfig: {},\r\n        subclassOfId: (0, Helpers_1.crc32)(match[3]),\r\n        result: match[3],\r\n        isFunction: isFunction,\r\n        namespace: undefined,\r\n    };\r\n    if (!currentConfig.constructorId) {\r\n        const hexId = \"\";\r\n        let args;\r\n        if (Object.values(currentConfig.argsConfig).length) {\r\n            args = ` ${Object.keys(currentConfig.argsConfig)\r\n                .map((arg) => arg.toString())\r\n                .join(\" \")}`;\r\n        }\r\n        else {\r\n            args = \"\";\r\n        }\r\n        const representation = `${currentConfig.name}${hexId}${args} = ${currentConfig.result}`\r\n            .replace(/(:|\\?)bytes /g, \"$1string \")\r\n            .replace(/</g, \" \")\r\n            .replace(/>|{|}/g, \"\")\r\n            .replace(/ \\w+:flags(\\d+)?\\.\\d+\\?true/g, \"\");\r\n        if (currentConfig.name === \"inputMediaInvoice\") {\r\n            // eslint-disable-next-line no-empty\r\n            if (currentConfig.name === \"inputMediaInvoice\") {\r\n            }\r\n        }\r\n        currentConfig.constructorId = (0, Helpers_1.crc32)(buffer_1.Buffer.from(representation, \"utf8\"));\r\n    }\r\n    for (const [brace, name, argType] of argsMatch) {\r\n        if (brace === undefined) {\r\n            // @ts-ignore\r\n            currentConfig.argsConfig[variableSnakeToCamelCase(name)] =\r\n                buildArgConfig(name, argType);\r\n        }\r\n    }\r\n    if (currentConfig.name.includes(\".\")) {\r\n        [currentConfig.namespace, currentConfig.name] =\r\n            currentConfig.name.split(/\\.(.+)/);\r\n    }\r\n    currentConfig.name = snakeToCamelCase(currentConfig.name);\r\n    /*\r\n    for (const arg in currentConfig.argsConfig){\r\n      if (currentConfig.argsConfig.hasOwnProperty(arg)){\r\n        if (currentConfig.argsConfig[arg].flagIndicator){\r\n          delete  currentConfig.argsConfig[arg]\r\n        }\r\n      }\r\n    }*/\r\n    return currentConfig;\r\n};\r\nexports.fromLine = fromLine;\r\nfunction buildArgConfig(name, argType) {\r\n    name = name === \"self\" ? \"is_self\" : name;\r\n    // Default values\r\n    const currentConfig = {\r\n        isVector: false,\r\n        isFlag: false,\r\n        skipConstructorId: false,\r\n        flagName: null,\r\n        flagIndex: -1,\r\n        flagIndicator: true,\r\n        type: null,\r\n        useVectorId: null,\r\n    };\r\n    // Special case: some types can be inferred, which makes it\r\n    // less annoying to type. Currently the only type that can\r\n    // be inferred is if the name is 'random_id', to which a\r\n    // random ID will be assigned if left as None (the default)\r\n    const canBeInferred = name === \"random_id\";\r\n    // The type can be an indicator that other arguments will be flags\r\n    if (argType !== \"#\") {\r\n        currentConfig.flagIndicator = false;\r\n        // Strip the exclamation mark always to have only the name\r\n        currentConfig.type = argType.replace(/^!+/, \"\");\r\n        // The type may be a flag (flags.IDX?REAL_TYPE)\r\n        // Note that 'flags' is NOT the flags name; this\r\n        // is determined by a previous argument\r\n        // However, we assume that the argument will always be starts with 'flags'\r\n        // @ts-ignore\r\n        const flagMatch = currentConfig.type.match(/(flags(?:\\d+)?).(\\d+)\\?([\\w<>.]+)/);\r\n        if (flagMatch) {\r\n            currentConfig.isFlag = true;\r\n            // As of layer 140, flagName can be \"flags\" or \"flags2\"\r\n            currentConfig.flagName = flagMatch[1];\r\n            currentConfig.flagIndex = Number(flagMatch[2]);\r\n            // Update the type to match the exact type, not the \"flagged\" one\r\n            currentConfig.type = flagMatch[3];\r\n        }\r\n        // Then check if the type is a Vector<REAL_TYPE>\r\n        // @ts-ignore\r\n        const vectorMatch = currentConfig.type.match(/[Vv]ector<([\\w\\d.]+)>/);\r\n        if (vectorMatch) {\r\n            currentConfig.isVector = true;\r\n            // If the type's first letter is not uppercase, then\r\n            // it is a constructor and we use (read/write) its ID.\r\n            // @ts-ignore\r\n            currentConfig.useVectorId = currentConfig.type.charAt(0) === \"V\";\r\n            // Update the type to match the one inside the vector\r\n            [, currentConfig.type] = vectorMatch;\r\n        }\r\n        // See use_vector_id. An example of such case is ipPort in\r\n        // help.configSpecial\r\n        // @ts-ignore\r\n        if (/^[a-z]$/.test(currentConfig.type.split(\".\").pop().charAt(0))) {\r\n            currentConfig.skipConstructorId = true;\r\n        }\r\n        // The name may contain \"date\" in it, if this is the case and\r\n        // the type is \"int\", we can safely assume that this should be\r\n        // treated as a \"date\" object. Note that this is not a valid\r\n        // Telegram object, but it's easier to work with\r\n        // if (\r\n        //     this.type === 'int' &&\r\n        //     (/(\\b|_)([dr]ate|until|since)(\\b|_)/.test(name) ||\r\n        //         ['expires', 'expires_at', 'was_online'].includes(name))\r\n        // ) {\r\n        //     this.type = 'date';\r\n        // }\r\n    }\r\n    // workaround\r\n    if (currentConfig.type == \"future_salt\") {\r\n        currentConfig.type = \"FutureSalt\";\r\n    }\r\n    return currentConfig;\r\n}\r\nexports.buildArgConfig = buildArgConfig;\r\nconst parseTl = function* (content, layer, methods = [], ignoreIds = CORE_TYPES) {\r\n    const methodInfo = (methods || []).reduce((o, m) => (Object.assign(Object.assign({}, o), { [m.name]: m })), {});\r\n    const objAll = [];\r\n    const objByName = {};\r\n    const objByType = {};\r\n    const file = content;\r\n    let isFunction = false;\r\n    for (let line of file.split(\"\\n\")) {\r\n        const commentIndex = line.indexOf(\"//\");\r\n        if (commentIndex !== -1) {\r\n            line = line.slice(0, commentIndex);\r\n        }\r\n        line = line.trim();\r\n        if (!line) {\r\n            continue;\r\n        }\r\n        const match = line.match(/---(\\w+)---/);\r\n        if (match) {\r\n            const [, followingTypes] = match;\r\n            isFunction = followingTypes === \"functions\";\r\n            continue;\r\n        }\r\n        try {\r\n            const result = fromLine(line, isFunction);\r\n            if (ignoreIds.has(result.constructorId)) {\r\n                continue;\r\n            }\r\n            objAll.push(result);\r\n            if (!result.isFunction) {\r\n                if (!objByType[result.result]) {\r\n                    objByType[result.result] = [];\r\n                }\r\n                objByName[result.name] = result;\r\n                objByType[result.result].push(result);\r\n            }\r\n        }\r\n        catch (e) {\r\n            if (!e.toString().includes(\"vector#1cb5c415\")) {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n    // Once all objects have been parsed, replace the\r\n    // string type from the arguments with references\r\n    for (const obj of objAll) {\r\n        if (AUTH_KEY_TYPES.has(obj.constructorId)) {\r\n            for (const arg in obj.argsConfig) {\r\n                if (obj.argsConfig[arg].type === \"string\") {\r\n                    obj.argsConfig[arg].type = \"bytes\";\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (const obj of objAll) {\r\n        yield obj;\r\n    }\r\n};\r\nexports.parseTl = parseTl;\r\nconst findAll = (regex, str, matches = []) => {\r\n    if (!regex.flags.includes(\"g\")) {\r\n        regex = new RegExp(regex.source, \"g\");\r\n    }\r\n    const res = regex.exec(str);\r\n    if (res) {\r\n        matches.push(res.slice(1));\r\n        findAll(regex, str, matches);\r\n    }\r\n    return matches;\r\n};\r\nexports.findAll = findAll;\r\nfunction serializeBytes(data) {\r\n    if (!(data instanceof buffer_1.Buffer)) {\r\n        if (typeof data == \"string\") {\r\n            data = buffer_1.Buffer.from(data);\r\n        }\r\n        else {\r\n            throw Error(`Bytes or str expected, not ${data.constructor.name}`);\r\n        }\r\n    }\r\n    const r = [];\r\n    let padding;\r\n    if (data.length < 254) {\r\n        padding = (data.length + 1) % 4;\r\n        if (padding !== 0) {\r\n            padding = 4 - padding;\r\n        }\r\n        r.push(buffer_1.Buffer.from([data.length]));\r\n        r.push(data);\r\n    }\r\n    else {\r\n        padding = data.length % 4;\r\n        if (padding !== 0) {\r\n            padding = 4 - padding;\r\n        }\r\n        r.push(buffer_1.Buffer.from([\r\n            254,\r\n            data.length % 256,\r\n            (data.length >> 8) % 256,\r\n            (data.length >> 16) % 256,\r\n        ]));\r\n        r.push(data);\r\n    }\r\n    r.push(buffer_1.Buffer.alloc(padding).fill(0));\r\n    return buffer_1.Buffer.concat(r);\r\n}\r\nexports.serializeBytes = serializeBytes;\r\nfunction serializeDate(dt) {\r\n    if (!dt) {\r\n        return buffer_1.Buffer.alloc(4).fill(0);\r\n    }\r\n    if (dt instanceof Date) {\r\n        dt = Math.floor((Date.now() - dt.getTime()) / 1000);\r\n    }\r\n    if (typeof dt == \"number\") {\r\n        const t = buffer_1.Buffer.alloc(4);\r\n        t.writeInt32LE(dt, 0);\r\n        return t;\r\n    }\r\n    throw Error(`Cannot interpret \"${dt}\" as a date`);\r\n}\r\nexports.serializeDate = serializeDate;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}