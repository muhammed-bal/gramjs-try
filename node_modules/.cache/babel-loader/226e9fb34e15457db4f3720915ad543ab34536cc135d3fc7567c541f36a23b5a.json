{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._authFlow = exports.signInBot = exports.signInWithPassword = exports.sendCode = exports.signInUserWithQrCode = exports.signInUser = exports.checkAuthorization = exports.start = void 0;\nconst tl_1 = require(\"../tl\");\nconst utils = __importStar(require(\"../Utils\"));\nconst Helpers_1 = require(\"../Helpers\");\nconst Password_1 = require(\"../Password\");\nconst QR_CODE_TIMEOUT = 30000;\n// region public methods\n/** @hidden */\nasync function start(client, authParams) {\n  if (!client.connected) {\n    await client.connect();\n  }\n  if (await client.checkAuthorization()) {\n    return;\n  }\n  const apiCredentials = {\n    apiId: client.apiId,\n    apiHash: client.apiHash\n  };\n  await _authFlow(client, apiCredentials, authParams);\n}\nexports.start = start;\n/** @hidden */\nasync function checkAuthorization(client) {\n  try {\n    await client.invoke(new tl_1.Api.updates.GetState());\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nexports.checkAuthorization = checkAuthorization;\n/** @hidden */\nasync function signInUser(client, apiCredentials, authParams) {\n  let phoneNumber;\n  let phoneCodeHash;\n  let isCodeViaApp = false;\n  while (1) {\n    try {\n      if (typeof authParams.phoneNumber === \"function\") {\n        try {\n          phoneNumber = await authParams.phoneNumber();\n        } catch (err) {\n          if (err.errorMessage === \"RESTART_AUTH_WITH_QR\") {\n            return client.signInUserWithQrCode(apiCredentials, authParams);\n          }\n          throw err;\n        }\n      } else {\n        phoneNumber = authParams.phoneNumber;\n      }\n      const sendCodeResult = await client.sendCode(apiCredentials, phoneNumber, authParams.forceSMS);\n      phoneCodeHash = sendCodeResult.phoneCodeHash;\n      isCodeViaApp = sendCodeResult.isCodeViaApp;\n      if (typeof phoneCodeHash !== \"string\") {\n        throw new Error(\"Failed to retrieve phone code hash\");\n      }\n      break;\n    } catch (err) {\n      if (typeof authParams.phoneNumber !== \"function\") {\n        throw err;\n      }\n      const shouldWeStop = await authParams.onError(err);\n      if (shouldWeStop) {\n        throw new Error(\"AUTH_USER_CANCEL\");\n      }\n    }\n  }\n  let phoneCode;\n  let isRegistrationRequired = false;\n  let termsOfService;\n  while (1) {\n    try {\n      try {\n        phoneCode = await authParams.phoneCode(isCodeViaApp);\n      } catch (err) {\n        // This is the support for changing phone number from the phone code screen.\n        if (err.errorMessage === \"RESTART_AUTH\") {\n          return client.signInUser(apiCredentials, authParams);\n        }\n      }\n      if (!phoneCode) {\n        throw new Error(\"Code is empty\");\n      }\n      // May raise PhoneCodeEmptyError, PhoneCodeExpiredError,\n      // PhoneCodeHashEmptyError or PhoneCodeInvalidError.\n      const result = await client.invoke(new tl_1.Api.auth.SignIn({\n        phoneNumber,\n        phoneCodeHash,\n        phoneCode\n      }));\n      if (result instanceof tl_1.Api.auth.AuthorizationSignUpRequired) {\n        isRegistrationRequired = true;\n        termsOfService = result.termsOfService;\n        break;\n      }\n      return result.user;\n    } catch (err) {\n      if (err.errorMessage === \"SESSION_PASSWORD_NEEDED\") {\n        return client.signInWithPassword(apiCredentials, authParams);\n      } else {\n        const shouldWeStop = await authParams.onError(err);\n        if (shouldWeStop) {\n          throw new Error(\"AUTH_USER_CANCEL\");\n        }\n      }\n    }\n  }\n  if (isRegistrationRequired) {\n    while (1) {\n      try {\n        let lastName;\n        let firstName = \"first name\";\n        if (authParams.firstAndLastNames) {\n          const result = await authParams.firstAndLastNames();\n          firstName = result[0];\n          lastName = result[1];\n        }\n        if (!firstName) {\n          throw new Error(\"First name is required\");\n        }\n        const {\n          user\n        } = await client.invoke(new tl_1.Api.auth.SignUp({\n          phoneNumber,\n          phoneCodeHash,\n          firstName,\n          lastName\n        }));\n        if (termsOfService) {\n          // This is a violation of Telegram rules: the user should be presented with and accept TOS.\n          await client.invoke(new tl_1.Api.help.AcceptTermsOfService({\n            id: termsOfService.id\n          }));\n        }\n        return user;\n      } catch (err) {\n        const shouldWeStop = await authParams.onError(err);\n        if (shouldWeStop) {\n          throw new Error(\"AUTH_USER_CANCEL\");\n        }\n      }\n    }\n  }\n  await authParams.onError(new Error(\"Auth failed\"));\n  return client.signInUser(apiCredentials, authParams);\n}\nexports.signInUser = signInUser;\n/** @hidden */\nasync function signInUserWithQrCode(client, apiCredentials, authParams) {\n  let isScanningComplete = false;\n  if (authParams.qrCode == undefined) {\n    throw new Error(\"qrCode callback not defined\");\n  }\n  const inputPromise = (async () => {\n    while (1) {\n      if (isScanningComplete) {\n        break;\n      }\n      const result = await client.invoke(new tl_1.Api.auth.ExportLoginToken({\n        apiId: Number(apiCredentials.apiId),\n        apiHash: apiCredentials.apiHash,\n        exceptIds: []\n      }));\n      if (!(result instanceof tl_1.Api.auth.LoginToken)) {\n        throw new Error(\"Unexpected\");\n      }\n      const {\n        token,\n        expires\n      } = result;\n      await Promise.race([authParams.qrCode({\n        token,\n        expires\n      }), (0, Helpers_1.sleep)(QR_CODE_TIMEOUT)]);\n      await (0, Helpers_1.sleep)(QR_CODE_TIMEOUT);\n    }\n  })();\n  const updatePromise = new Promise(resolve => {\n    client.addEventHandler(update => {\n      if (update instanceof tl_1.Api.UpdateLoginToken) {\n        resolve(undefined);\n      }\n    });\n  });\n  try {\n    await Promise.race([updatePromise, inputPromise]);\n  } catch (err) {\n    throw err;\n  } finally {\n    isScanningComplete = true;\n  }\n  try {\n    const result2 = await client.invoke(new tl_1.Api.auth.ExportLoginToken({\n      apiId: Number(apiCredentials.apiId),\n      apiHash: apiCredentials.apiHash,\n      exceptIds: []\n    }));\n    if (result2 instanceof tl_1.Api.auth.LoginTokenSuccess && result2.authorization instanceof tl_1.Api.auth.Authorization) {\n      return result2.authorization.user;\n    } else if (result2 instanceof tl_1.Api.auth.LoginTokenMigrateTo) {\n      await client._switchDC(result2.dcId);\n      const migratedResult = await client.invoke(new tl_1.Api.auth.ImportLoginToken({\n        token: result2.token\n      }));\n      if (migratedResult instanceof tl_1.Api.auth.LoginTokenSuccess && migratedResult.authorization instanceof tl_1.Api.auth.Authorization) {\n        return migratedResult.authorization.user;\n      } else {\n        client._log.error(`Received unknown result while scanning QR ${result2.className}`);\n        throw new Error(`Received unknown result while scanning QR ${result2.className}`);\n      }\n    } else {\n      client._log.error(`Received unknown result while scanning QR ${result2.className}`);\n      throw new Error(`Received unknown result while scanning QR ${result2.className}`);\n    }\n  } catch (err) {\n    if (err.errorMessage === \"SESSION_PASSWORD_NEEDED\") {\n      return client.signInWithPassword(apiCredentials, authParams);\n    }\n    throw err;\n  }\n  await authParams.onError(new Error(\"QR auth failed\"));\n  throw new Error(\"QR auth failed\");\n}\nexports.signInUserWithQrCode = signInUserWithQrCode;\n/** @hidden */\nasync function sendCode(client, apiCredentials, phoneNumber, forceSMS = false) {\n  try {\n    const {\n      apiId,\n      apiHash\n    } = apiCredentials;\n    const sendResult = await client.invoke(new tl_1.Api.auth.SendCode({\n      phoneNumber,\n      apiId,\n      apiHash,\n      settings: new tl_1.Api.CodeSettings({})\n    }));\n    if (sendResult instanceof tl_1.Api.auth.SentCodeSuccess) throw new Error(\"logged in right after sending the code\");\n    // If we already sent a SMS, do not resend the phoneCode (hash may be empty)\n    if (!forceSMS || sendResult.type instanceof tl_1.Api.auth.SentCodeTypeSms) {\n      return {\n        phoneCodeHash: sendResult.phoneCodeHash,\n        isCodeViaApp: sendResult.type instanceof tl_1.Api.auth.SentCodeTypeApp\n      };\n    }\n    const resendResult = await client.invoke(new tl_1.Api.auth.ResendCode({\n      phoneNumber,\n      phoneCodeHash: sendResult.phoneCodeHash\n    }));\n    if (resendResult instanceof tl_1.Api.auth.SentCodeSuccess) throw new Error(\"logged in right after resending the code\");\n    return {\n      phoneCodeHash: resendResult.phoneCodeHash,\n      isCodeViaApp: resendResult.type instanceof tl_1.Api.auth.SentCodeTypeApp\n    };\n  } catch (err) {\n    if (err.errorMessage === \"AUTH_RESTART\") {\n      return client.sendCode(apiCredentials, phoneNumber, forceSMS);\n    } else {\n      throw err;\n    }\n  }\n}\nexports.sendCode = sendCode;\n/** @hidden */\nasync function signInWithPassword(client, apiCredentials, authParams) {\n  let emptyPassword = false;\n  while (1) {\n    try {\n      const passwordSrpResult = await client.invoke(new tl_1.Api.account.GetPassword());\n      if (!authParams.password) {\n        emptyPassword = true;\n        break;\n      }\n      const password = await authParams.password(passwordSrpResult.hint);\n      if (!password) {\n        throw new Error(\"Password is empty\");\n      }\n      const passwordSrpCheck = await (0, Password_1.computeCheck)(passwordSrpResult, password);\n      const {\n        user\n      } = await client.invoke(new tl_1.Api.auth.CheckPassword({\n        password: passwordSrpCheck\n      }));\n      return user;\n    } catch (err) {\n      const shouldWeStop = await authParams.onError(err);\n      if (shouldWeStop) {\n        throw new Error(\"AUTH_USER_CANCEL\");\n      }\n    }\n  }\n  if (emptyPassword) {\n    throw new Error(\"Account has 2FA enabled.\");\n  }\n  return undefined; // Never reached (TypeScript fix)\n}\n\nexports.signInWithPassword = signInWithPassword;\n/** @hidden */\nasync function signInBot(client, apiCredentials, authParams) {\n  const {\n    apiId,\n    apiHash\n  } = apiCredentials;\n  let {\n    botAuthToken\n  } = authParams;\n  if (!botAuthToken) {\n    throw new Error(\"a valid BotToken is required\");\n  }\n  if (typeof botAuthToken === \"function\") {\n    let token;\n    while (true) {\n      token = await botAuthToken();\n      if (token) {\n        botAuthToken = token;\n        break;\n      }\n    }\n  }\n  const {\n    user\n  } = await client.invoke(new tl_1.Api.auth.ImportBotAuthorization({\n    apiId,\n    apiHash,\n    botAuthToken\n  }));\n  return user;\n}\nexports.signInBot = signInBot;\n/** @hidden */\nasync function _authFlow(client, apiCredentials, authParams) {\n  const me = \"phoneNumber\" in authParams ? await client.signInUser(apiCredentials, authParams) : await client.signInBot(apiCredentials, authParams);\n  client._log.info(\"Signed in successfully as \" + utils.getDisplayName(me));\n}\nexports._authFlow = _authFlow;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","exports","_authFlow","signInBot","signInWithPassword","sendCode","signInUserWithQrCode","signInUser","checkAuthorization","start","tl_1","require","utils","Helpers_1","Password_1","QR_CODE_TIMEOUT","client","authParams","connected","connect","apiCredentials","apiId","apiHash","invoke","Api","updates","GetState","e","phoneNumber","phoneCodeHash","isCodeViaApp","err","errorMessage","sendCodeResult","forceSMS","Error","shouldWeStop","onError","phoneCode","isRegistrationRequired","termsOfService","auth","SignIn","AuthorizationSignUpRequired","user","lastName","firstName","firstAndLastNames","SignUp","help","AcceptTermsOfService","id","isScanningComplete","qrCode","inputPromise","ExportLoginToken","Number","exceptIds","LoginToken","token","expires","Promise","race","sleep","updatePromise","resolve","addEventHandler","update","UpdateLoginToken","result2","LoginTokenSuccess","authorization","Authorization","LoginTokenMigrateTo","_switchDC","dcId","migratedResult","ImportLoginToken","_log","error","className","sendResult","SendCode","settings","CodeSettings","SentCodeSuccess","type","SentCodeTypeSms","SentCodeTypeApp","resendResult","ResendCode","emptyPassword","passwordSrpResult","account","GetPassword","password","hint","passwordSrpCheck","computeCheck","CheckPassword","botAuthToken","ImportBotAuthorization","me","info","getDisplayName"],"sources":["C:/Users/Muhammed/Desktop/REACT_JS/dene-gramjs/node_modules/telegram/client/auth.js"],"sourcesContent":["\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports._authFlow = exports.signInBot = exports.signInWithPassword = exports.sendCode = exports.signInUserWithQrCode = exports.signInUser = exports.checkAuthorization = exports.start = void 0;\r\nconst tl_1 = require(\"../tl\");\r\nconst utils = __importStar(require(\"../Utils\"));\r\nconst Helpers_1 = require(\"../Helpers\");\r\nconst Password_1 = require(\"../Password\");\r\nconst QR_CODE_TIMEOUT = 30000;\r\n// region public methods\r\n/** @hidden */\r\nasync function start(client, authParams) {\r\n    if (!client.connected) {\r\n        await client.connect();\r\n    }\r\n    if (await client.checkAuthorization()) {\r\n        return;\r\n    }\r\n    const apiCredentials = {\r\n        apiId: client.apiId,\r\n        apiHash: client.apiHash,\r\n    };\r\n    await _authFlow(client, apiCredentials, authParams);\r\n}\r\nexports.start = start;\r\n/** @hidden */\r\nasync function checkAuthorization(client) {\r\n    try {\r\n        await client.invoke(new tl_1.Api.updates.GetState());\r\n        return true;\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n}\r\nexports.checkAuthorization = checkAuthorization;\r\n/** @hidden */\r\nasync function signInUser(client, apiCredentials, authParams) {\r\n    let phoneNumber;\r\n    let phoneCodeHash;\r\n    let isCodeViaApp = false;\r\n    while (1) {\r\n        try {\r\n            if (typeof authParams.phoneNumber === \"function\") {\r\n                try {\r\n                    phoneNumber = await authParams.phoneNumber();\r\n                }\r\n                catch (err) {\r\n                    if (err.errorMessage === \"RESTART_AUTH_WITH_QR\") {\r\n                        return client.signInUserWithQrCode(apiCredentials, authParams);\r\n                    }\r\n                    throw err;\r\n                }\r\n            }\r\n            else {\r\n                phoneNumber = authParams.phoneNumber;\r\n            }\r\n            const sendCodeResult = await client.sendCode(apiCredentials, phoneNumber, authParams.forceSMS);\r\n            phoneCodeHash = sendCodeResult.phoneCodeHash;\r\n            isCodeViaApp = sendCodeResult.isCodeViaApp;\r\n            if (typeof phoneCodeHash !== \"string\") {\r\n                throw new Error(\"Failed to retrieve phone code hash\");\r\n            }\r\n            break;\r\n        }\r\n        catch (err) {\r\n            if (typeof authParams.phoneNumber !== \"function\") {\r\n                throw err;\r\n            }\r\n            const shouldWeStop = await authParams.onError(err);\r\n            if (shouldWeStop) {\r\n                throw new Error(\"AUTH_USER_CANCEL\");\r\n            }\r\n        }\r\n    }\r\n    let phoneCode;\r\n    let isRegistrationRequired = false;\r\n    let termsOfService;\r\n    while (1) {\r\n        try {\r\n            try {\r\n                phoneCode = await authParams.phoneCode(isCodeViaApp);\r\n            }\r\n            catch (err) {\r\n                // This is the support for changing phone number from the phone code screen.\r\n                if (err.errorMessage === \"RESTART_AUTH\") {\r\n                    return client.signInUser(apiCredentials, authParams);\r\n                }\r\n            }\r\n            if (!phoneCode) {\r\n                throw new Error(\"Code is empty\");\r\n            }\r\n            // May raise PhoneCodeEmptyError, PhoneCodeExpiredError,\r\n            // PhoneCodeHashEmptyError or PhoneCodeInvalidError.\r\n            const result = await client.invoke(new tl_1.Api.auth.SignIn({\r\n                phoneNumber,\r\n                phoneCodeHash,\r\n                phoneCode,\r\n            }));\r\n            if (result instanceof tl_1.Api.auth.AuthorizationSignUpRequired) {\r\n                isRegistrationRequired = true;\r\n                termsOfService = result.termsOfService;\r\n                break;\r\n            }\r\n            return result.user;\r\n        }\r\n        catch (err) {\r\n            if (err.errorMessage === \"SESSION_PASSWORD_NEEDED\") {\r\n                return client.signInWithPassword(apiCredentials, authParams);\r\n            }\r\n            else {\r\n                const shouldWeStop = await authParams.onError(err);\r\n                if (shouldWeStop) {\r\n                    throw new Error(\"AUTH_USER_CANCEL\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (isRegistrationRequired) {\r\n        while (1) {\r\n            try {\r\n                let lastName;\r\n                let firstName = \"first name\";\r\n                if (authParams.firstAndLastNames) {\r\n                    const result = await authParams.firstAndLastNames();\r\n                    firstName = result[0];\r\n                    lastName = result[1];\r\n                }\r\n                if (!firstName) {\r\n                    throw new Error(\"First name is required\");\r\n                }\r\n                const { user } = (await client.invoke(new tl_1.Api.auth.SignUp({\r\n                    phoneNumber,\r\n                    phoneCodeHash,\r\n                    firstName,\r\n                    lastName,\r\n                })));\r\n                if (termsOfService) {\r\n                    // This is a violation of Telegram rules: the user should be presented with and accept TOS.\r\n                    await client.invoke(new tl_1.Api.help.AcceptTermsOfService({\r\n                        id: termsOfService.id,\r\n                    }));\r\n                }\r\n                return user;\r\n            }\r\n            catch (err) {\r\n                const shouldWeStop = await authParams.onError(err);\r\n                if (shouldWeStop) {\r\n                    throw new Error(\"AUTH_USER_CANCEL\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n    await authParams.onError(new Error(\"Auth failed\"));\r\n    return client.signInUser(apiCredentials, authParams);\r\n}\r\nexports.signInUser = signInUser;\r\n/** @hidden */\r\nasync function signInUserWithQrCode(client, apiCredentials, authParams) {\r\n    let isScanningComplete = false;\r\n    if (authParams.qrCode == undefined) {\r\n        throw new Error(\"qrCode callback not defined\");\r\n    }\r\n    const inputPromise = (async () => {\r\n        while (1) {\r\n            if (isScanningComplete) {\r\n                break;\r\n            }\r\n            const result = await client.invoke(new tl_1.Api.auth.ExportLoginToken({\r\n                apiId: Number(apiCredentials.apiId),\r\n                apiHash: apiCredentials.apiHash,\r\n                exceptIds: [],\r\n            }));\r\n            if (!(result instanceof tl_1.Api.auth.LoginToken)) {\r\n                throw new Error(\"Unexpected\");\r\n            }\r\n            const { token, expires } = result;\r\n            await Promise.race([\r\n                authParams.qrCode({ token, expires }),\r\n                (0, Helpers_1.sleep)(QR_CODE_TIMEOUT),\r\n            ]);\r\n            await (0, Helpers_1.sleep)(QR_CODE_TIMEOUT);\r\n        }\r\n    })();\r\n    const updatePromise = new Promise((resolve) => {\r\n        client.addEventHandler((update) => {\r\n            if (update instanceof tl_1.Api.UpdateLoginToken) {\r\n                resolve(undefined);\r\n            }\r\n        });\r\n    });\r\n    try {\r\n        await Promise.race([updatePromise, inputPromise]);\r\n    }\r\n    catch (err) {\r\n        throw err;\r\n    }\r\n    finally {\r\n        isScanningComplete = true;\r\n    }\r\n    try {\r\n        const result2 = await client.invoke(new tl_1.Api.auth.ExportLoginToken({\r\n            apiId: Number(apiCredentials.apiId),\r\n            apiHash: apiCredentials.apiHash,\r\n            exceptIds: [],\r\n        }));\r\n        if (result2 instanceof tl_1.Api.auth.LoginTokenSuccess &&\r\n            result2.authorization instanceof tl_1.Api.auth.Authorization) {\r\n            return result2.authorization.user;\r\n        }\r\n        else if (result2 instanceof tl_1.Api.auth.LoginTokenMigrateTo) {\r\n            await client._switchDC(result2.dcId);\r\n            const migratedResult = await client.invoke(new tl_1.Api.auth.ImportLoginToken({\r\n                token: result2.token,\r\n            }));\r\n            if (migratedResult instanceof tl_1.Api.auth.LoginTokenSuccess &&\r\n                migratedResult.authorization instanceof tl_1.Api.auth.Authorization) {\r\n                return migratedResult.authorization.user;\r\n            }\r\n            else {\r\n                client._log.error(`Received unknown result while scanning QR ${result2.className}`);\r\n                throw new Error(`Received unknown result while scanning QR ${result2.className}`);\r\n            }\r\n        }\r\n        else {\r\n            client._log.error(`Received unknown result while scanning QR ${result2.className}`);\r\n            throw new Error(`Received unknown result while scanning QR ${result2.className}`);\r\n        }\r\n    }\r\n    catch (err) {\r\n        if (err.errorMessage === \"SESSION_PASSWORD_NEEDED\") {\r\n            return client.signInWithPassword(apiCredentials, authParams);\r\n        }\r\n        throw err;\r\n    }\r\n    await authParams.onError(new Error(\"QR auth failed\"));\r\n    throw new Error(\"QR auth failed\");\r\n}\r\nexports.signInUserWithQrCode = signInUserWithQrCode;\r\n/** @hidden */\r\nasync function sendCode(client, apiCredentials, phoneNumber, forceSMS = false) {\r\n    try {\r\n        const { apiId, apiHash } = apiCredentials;\r\n        const sendResult = await client.invoke(new tl_1.Api.auth.SendCode({\r\n            phoneNumber,\r\n            apiId,\r\n            apiHash,\r\n            settings: new tl_1.Api.CodeSettings({}),\r\n        }));\r\n        if (sendResult instanceof tl_1.Api.auth.SentCodeSuccess)\r\n            throw new Error(\"logged in right after sending the code\");\r\n        // If we already sent a SMS, do not resend the phoneCode (hash may be empty)\r\n        if (!forceSMS || sendResult.type instanceof tl_1.Api.auth.SentCodeTypeSms) {\r\n            return {\r\n                phoneCodeHash: sendResult.phoneCodeHash,\r\n                isCodeViaApp: sendResult.type instanceof tl_1.Api.auth.SentCodeTypeApp,\r\n            };\r\n        }\r\n        const resendResult = await client.invoke(new tl_1.Api.auth.ResendCode({\r\n            phoneNumber,\r\n            phoneCodeHash: sendResult.phoneCodeHash,\r\n        }));\r\n        if (resendResult instanceof tl_1.Api.auth.SentCodeSuccess)\r\n            throw new Error(\"logged in right after resending the code\");\r\n        return {\r\n            phoneCodeHash: resendResult.phoneCodeHash,\r\n            isCodeViaApp: resendResult.type instanceof tl_1.Api.auth.SentCodeTypeApp,\r\n        };\r\n    }\r\n    catch (err) {\r\n        if (err.errorMessage === \"AUTH_RESTART\") {\r\n            return client.sendCode(apiCredentials, phoneNumber, forceSMS);\r\n        }\r\n        else {\r\n            throw err;\r\n        }\r\n    }\r\n}\r\nexports.sendCode = sendCode;\r\n/** @hidden */\r\nasync function signInWithPassword(client, apiCredentials, authParams) {\r\n    let emptyPassword = false;\r\n    while (1) {\r\n        try {\r\n            const passwordSrpResult = await client.invoke(new tl_1.Api.account.GetPassword());\r\n            if (!authParams.password) {\r\n                emptyPassword = true;\r\n                break;\r\n            }\r\n            const password = await authParams.password(passwordSrpResult.hint);\r\n            if (!password) {\r\n                throw new Error(\"Password is empty\");\r\n            }\r\n            const passwordSrpCheck = await (0, Password_1.computeCheck)(passwordSrpResult, password);\r\n            const { user } = (await client.invoke(new tl_1.Api.auth.CheckPassword({\r\n                password: passwordSrpCheck,\r\n            })));\r\n            return user;\r\n        }\r\n        catch (err) {\r\n            const shouldWeStop = await authParams.onError(err);\r\n            if (shouldWeStop) {\r\n                throw new Error(\"AUTH_USER_CANCEL\");\r\n            }\r\n        }\r\n    }\r\n    if (emptyPassword) {\r\n        throw new Error(\"Account has 2FA enabled.\");\r\n    }\r\n    return undefined; // Never reached (TypeScript fix)\r\n}\r\nexports.signInWithPassword = signInWithPassword;\r\n/** @hidden */\r\nasync function signInBot(client, apiCredentials, authParams) {\r\n    const { apiId, apiHash } = apiCredentials;\r\n    let { botAuthToken } = authParams;\r\n    if (!botAuthToken) {\r\n        throw new Error(\"a valid BotToken is required\");\r\n    }\r\n    if (typeof botAuthToken === \"function\") {\r\n        let token;\r\n        while (true) {\r\n            token = await botAuthToken();\r\n            if (token) {\r\n                botAuthToken = token;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    const { user } = (await client.invoke(new tl_1.Api.auth.ImportBotAuthorization({\r\n        apiId,\r\n        apiHash,\r\n        botAuthToken,\r\n    })));\r\n    return user;\r\n}\r\nexports.signInBot = signInBot;\r\n/** @hidden */\r\nasync function _authFlow(client, apiCredentials, authParams) {\r\n    const me = \"phoneNumber\" in authParams\r\n        ? await client.signInUser(apiCredentials, authParams)\r\n        : await client.signInBot(apiCredentials, authParams);\r\n    client._log.info(\"Signed in successfully as \" + utils.getDisplayName(me));\r\n}\r\nexports._authFlow = _authFlow;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}