{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConnectionTCPAbridged = exports.AbridgedPacketCodec = void 0;\nconst buffer_1 = require(\"buffer/\");\nconst Helpers_1 = require(\"../../Helpers\");\nconst Connection_1 = require(\"./Connection\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nclass AbridgedPacketCodec extends Connection_1.PacketCodec {\n  constructor(props) {\n    super(props);\n    this.tag = AbridgedPacketCodec.tag;\n    this.obfuscateTag = AbridgedPacketCodec.obfuscateTag;\n  }\n  encodePacket(data) {\n    let length = data.length >> 2;\n    let temp;\n    if (length < 127) {\n      const b = buffer_1.Buffer.alloc(1);\n      b.writeUInt8(length, 0);\n      temp = b;\n    } else {\n      temp = buffer_1.Buffer.concat([buffer_1.Buffer.from(\"7f\", \"hex\"), (0, Helpers_1.readBufferFromBigInt)((0, big_integer_1.default)(length), 3)]);\n    }\n    return buffer_1.Buffer.concat([temp, data]);\n  }\n  async readPacket(reader) {\n    const readData = await reader.read(1);\n    let length = readData[0];\n    if (length >= 127) {\n      length = buffer_1.Buffer.concat([await reader.read(3), buffer_1.Buffer.alloc(1)]).readInt32LE(0);\n    }\n    return reader.read(length << 2);\n  }\n}\nexports.AbridgedPacketCodec = AbridgedPacketCodec;\nAbridgedPacketCodec.tag = buffer_1.Buffer.from(\"ef\", \"hex\");\nAbridgedPacketCodec.obfuscateTag = buffer_1.Buffer.from(\"efefefef\", \"hex\");\n/**\r\n * This is the mode with the lowest overhead, as it will\r\n * only require 1 byte if the packet length is less than\r\n * 508 bytes (127 << 2, which is very common).\r\n */\nclass ConnectionTCPAbridged extends Connection_1.Connection {\n  constructor() {\n    super(...arguments);\n    this.PacketCodecClass = AbridgedPacketCodec;\n  }\n}\nexports.ConnectionTCPAbridged = ConnectionTCPAbridged;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","ConnectionTCPAbridged","AbridgedPacketCodec","buffer_1","require","Helpers_1","Connection_1","big_integer_1","PacketCodec","constructor","props","tag","obfuscateTag","encodePacket","data","length","temp","b","Buffer","alloc","writeUInt8","concat","from","readBufferFromBigInt","default","readPacket","reader","readData","read","readInt32LE","Connection","arguments","PacketCodecClass"],"sources":["C:/Users/Muhammed/Desktop/REACT_JS/dene-gramjs/node_modules/telegram/network/connection/TCPAbridged.js"],"sourcesContent":["\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ConnectionTCPAbridged = exports.AbridgedPacketCodec = void 0;\r\nconst buffer_1 = require(\"buffer/\");\r\nconst Helpers_1 = require(\"../../Helpers\");\r\nconst Connection_1 = require(\"./Connection\");\r\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\r\nclass AbridgedPacketCodec extends Connection_1.PacketCodec {\r\n    constructor(props) {\r\n        super(props);\r\n        this.tag = AbridgedPacketCodec.tag;\r\n        this.obfuscateTag = AbridgedPacketCodec.obfuscateTag;\r\n    }\r\n    encodePacket(data) {\r\n        let length = data.length >> 2;\r\n        let temp;\r\n        if (length < 127) {\r\n            const b = buffer_1.Buffer.alloc(1);\r\n            b.writeUInt8(length, 0);\r\n            temp = b;\r\n        }\r\n        else {\r\n            temp = buffer_1.Buffer.concat([\r\n                buffer_1.Buffer.from(\"7f\", \"hex\"),\r\n                (0, Helpers_1.readBufferFromBigInt)((0, big_integer_1.default)(length), 3),\r\n            ]);\r\n        }\r\n        return buffer_1.Buffer.concat([temp, data]);\r\n    }\r\n    async readPacket(reader) {\r\n        const readData = await reader.read(1);\r\n        let length = readData[0];\r\n        if (length >= 127) {\r\n            length = buffer_1.Buffer.concat([\r\n                await reader.read(3),\r\n                buffer_1.Buffer.alloc(1),\r\n            ]).readInt32LE(0);\r\n        }\r\n        return reader.read(length << 2);\r\n    }\r\n}\r\nexports.AbridgedPacketCodec = AbridgedPacketCodec;\r\nAbridgedPacketCodec.tag = buffer_1.Buffer.from(\"ef\", \"hex\");\r\nAbridgedPacketCodec.obfuscateTag = buffer_1.Buffer.from(\"efefefef\", \"hex\");\r\n/**\r\n * This is the mode with the lowest overhead, as it will\r\n * only require 1 byte if the packet length is less than\r\n * 508 bytes (127 << 2, which is very common).\r\n */\r\nclass ConnectionTCPAbridged extends Connection_1.Connection {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.PacketCodecClass = AbridgedPacketCodec;\r\n    }\r\n}\r\nexports.ConnectionTCPAbridged = ConnectionTCPAbridged;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}