{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._selfId = exports._getInputNotify = exports._getInputDialog = exports._getPeer = exports.getPeerId = exports._getEntityFromString = exports.getInputEntity = exports.getEntity = exports.isUserAuthorized = exports.isBot = exports.getMe = exports.invoke = void 0;\nconst tl_1 = require(\"../tl\");\nconst Utils_1 = require(\"../Utils\");\nconst Helpers_1 = require(\"../Helpers\");\nconst __1 = require(\"../\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst Logger_1 = require(\"../extensions/Logger\");\nconst RequestState_1 = require(\"../network/RequestState\");\n// UserMethods {\n// region Invoking Telegram request\n/** @hidden */\nasync function invoke(client, request, dcId, otherSender) {\n  if (request.classType !== \"request\") {\n    throw new Error(\"You can only invoke MTProtoRequests\");\n  }\n  let sender = client._sender;\n  if (dcId) {\n    sender = await client.getSender(dcId);\n  }\n  if (otherSender != undefined) {\n    sender = otherSender;\n  }\n  if (sender == undefined) {\n    throw new Error(\"Cannot send requests while disconnected. You need to call .connect()\");\n  }\n  await client._connectedDeferred.promise;\n  await request.resolve(client, __1.utils);\n  client._lastRequest = new Date().getTime();\n  const state = new RequestState_1.RequestState(request);\n  let attempt = 0;\n  for (attempt = 0; attempt < client._requestRetries; attempt++) {\n    sender.addStateToQueue(state);\n    try {\n      const result = await state.promise;\n      state.finished.resolve();\n      client.session.processEntities(result);\n      client._entityCache.add(result);\n      return result;\n    } catch (e) {\n      if (e instanceof __1.errors.ServerError || e.errorMessage === \"RPC_CALL_FAIL\" || e.errorMessage === \"RPC_MCGET_FAIL\") {\n        client._log.warn(`Telegram is having internal issues ${e.constructor.name}`);\n        await (0, Helpers_1.sleep)(2000);\n      } else if (e instanceof __1.errors.FloodWaitError || e instanceof __1.errors.FloodTestPhoneWaitError) {\n        if (e.seconds <= client.floodSleepThreshold) {\n          client._log.info(`Sleeping for ${e.seconds}s on flood wait (Caused by ${request.className})`);\n          await (0, Helpers_1.sleep)(e.seconds * 1000);\n        } else {\n          state.finished.resolve();\n          throw e;\n        }\n      } else if (e instanceof __1.errors.PhoneMigrateError || e instanceof __1.errors.NetworkMigrateError || e instanceof __1.errors.UserMigrateError) {\n        client._log.info(`Phone migrated to ${e.newDc}`);\n        const shouldRaise = e instanceof __1.errors.PhoneMigrateError || e instanceof __1.errors.NetworkMigrateError;\n        if (shouldRaise && (await client.isUserAuthorized())) {\n          state.finished.resolve();\n          throw e;\n        }\n        await client._switchDC(e.newDc);\n        sender = dcId === undefined ? client._sender : await client.getSender(dcId);\n      } else if (e instanceof __1.errors.MsgWaitError) {\n        // We need to resend this after the old one was confirmed.\n        await state.isReady();\n        state.after = undefined;\n      } else if (e.message === \"CONNECTION_NOT_INITED\") {\n        await client.disconnect();\n        await (0, Helpers_1.sleep)(2000);\n        await client.connect();\n      } else {\n        state.finished.resolve();\n        throw e;\n      }\n    }\n    state.resetPromise();\n  }\n  throw new Error(`Request was unsuccessful ${attempt} time(s)`);\n}\nexports.invoke = invoke;\n/** @hidden */\nasync function getMe(client, inputPeer = false) {\n  if (inputPeer && client._selfInputPeer) {\n    return client._selfInputPeer;\n  }\n  const me = (await client.invoke(new tl_1.Api.users.GetUsers({\n    id: [new tl_1.Api.InputUserSelf()]\n  })))[0];\n  client._bot = me.bot;\n  if (!client._selfInputPeer) {\n    client._selfInputPeer = __1.utils.getInputPeer(me, false);\n  }\n  return inputPeer ? client._selfInputPeer : me;\n}\nexports.getMe = getMe;\n/** @hidden */\nasync function isBot(client) {\n  if (client._bot === undefined) {\n    const me = await client.getMe();\n    if (me) {\n      return !(me instanceof tl_1.Api.InputPeerUser) ? me.bot : undefined;\n    }\n  }\n  return client._bot;\n}\nexports.isBot = isBot;\n/** @hidden */\nasync function isUserAuthorized(client) {\n  try {\n    await client.invoke(new tl_1.Api.updates.GetState());\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nexports.isUserAuthorized = isUserAuthorized;\n/** @hidden */\nasync function getEntity(client, entity) {\n  const single = !(0, Helpers_1.isArrayLike)(entity);\n  let entityArray = [];\n  if ((0, Helpers_1.isArrayLike)(entity)) {\n    entityArray = entity;\n  } else {\n    entityArray.push(entity);\n  }\n  const inputs = [];\n  for (const x of entityArray) {\n    if (typeof x === \"string\") {\n      const valid = (0, Utils_1.parseID)(x);\n      if (valid) {\n        inputs.push(await client.getInputEntity(valid));\n      } else {\n        inputs.push(x);\n      }\n    } else {\n      inputs.push(await client.getInputEntity(x));\n    }\n  }\n  const lists = new Map([[Helpers_1._EntityType.USER, []], [Helpers_1._EntityType.CHAT, []], [Helpers_1._EntityType.CHANNEL, []]]);\n  for (const x of inputs) {\n    try {\n      lists.get((0, Helpers_1._entityType)(x)).push(x);\n    } catch (e) {}\n  }\n  let users = lists.get(Helpers_1._EntityType.USER);\n  let chats = lists.get(Helpers_1._EntityType.CHAT);\n  let channels = lists.get(Helpers_1._EntityType.CHANNEL);\n  if (users.length) {\n    users = await client.invoke(new tl_1.Api.users.GetUsers({\n      id: users\n    }));\n  }\n  if (chats.length) {\n    const chatIds = chats.map(x => x.chatId);\n    chats = (await client.invoke(new tl_1.Api.messages.GetChats({\n      id: chatIds\n    }))).chats;\n  }\n  if (channels.length) {\n    channels = (await client.invoke(new tl_1.Api.channels.GetChannels({\n      id: channels\n    }))).chats;\n  }\n  const idEntity = new Map();\n  for (const user of users) {\n    idEntity.set((0, Utils_1.getPeerId)(user), user);\n  }\n  for (const channel of channels) {\n    idEntity.set((0, Utils_1.getPeerId)(channel), channel);\n  }\n  for (const chat of chats) {\n    idEntity.set((0, Utils_1.getPeerId)(chat), chat);\n  }\n  const result = [];\n  for (const x of inputs) {\n    if (typeof x === \"string\") {\n      result.push(await _getEntityFromString(client, x));\n    } else if (!(x instanceof tl_1.Api.InputPeerSelf)) {\n      result.push(idEntity.get((0, Utils_1.getPeerId)(x)));\n    } else {\n      for (const [key, u] of idEntity.entries()) {\n        if (u instanceof tl_1.Api.User && u.self) {\n          result.push(u);\n          break;\n        }\n      }\n    }\n  }\n  return single ? result[0] : result;\n}\nexports.getEntity = getEntity;\n/** @hidden */\nasync function getInputEntity(client, peer) {\n  // Short-circuit if the input parameter directly maps to an InputPeer\n  try {\n    return __1.utils.getInputPeer(peer);\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n  // Next in priority is having a peer (or its ID) cached in-memory\n  try {\n    if (typeof peer == \"string\") {\n      const valid = (0, Utils_1.parseID)(peer);\n      if (valid) {\n        const res = client._entityCache.get(peer);\n        if (res) {\n          return res;\n        }\n      }\n    }\n    if (typeof peer === \"number\" || typeof peer === \"bigint\" || big_integer_1.default.isInstance(peer)) {\n      const res = client._entityCache.get(peer.toString());\n      if (res) {\n        return res;\n      }\n    }\n    // 0x2d45687 == crc32(b'Peer')\n    if (typeof peer == \"object\" && !big_integer_1.default.isInstance(peer) && peer.SUBCLASS_OF_ID === 0x2d45687) {\n      const res = client._entityCache.get(__1.utils.getPeerId(peer));\n      if (res) {\n        return res;\n      }\n    }\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n  // Then come known strings that take precedence\n  if (typeof peer == \"string\") {\n    if ([\"me\", \"this\", \"self\"].includes(peer)) {\n      return new tl_1.Api.InputPeerSelf();\n    }\n  }\n  // No InputPeer, cached peer, or known string. Fetch from disk cache\n  try {\n    if (peer != undefined) {\n      return client.session.getInputEntity(peer);\n    }\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n  // Only network left to try\n  if (typeof peer === \"string\") {\n    return __1.utils.getInputPeer(await _getEntityFromString(client, peer));\n  }\n  // If we're a bot and the user has messaged us privately users.getUsers\n  // will work with accessHash = 0. Similar for channels.getChannels.\n  // If we're not a bot but the user is in our contacts, it seems to work\n  // regardless. These are the only two special-cased requests.\n  if (typeof peer === \"number\") {\n    peer = (0, Helpers_1.returnBigInt)(peer);\n  }\n  peer = __1.utils.getPeer(peer);\n  if (peer instanceof tl_1.Api.PeerUser) {\n    const users = await client.invoke(new tl_1.Api.users.GetUsers({\n      id: [new tl_1.Api.InputUser({\n        userId: peer.userId,\n        accessHash: big_integer_1.default.zero\n      })]\n    }));\n    if (users.length && !(users[0] instanceof tl_1.Api.UserEmpty)) {\n      // If the user passed a valid ID they expect to work for\n      // channels but would be valid for users, we get UserEmpty.\n      // Avoid returning the invalid empty input peer for that.\n      //\n      // We *could* try to guess if it's a channel first, and if\n      // it's not, work as a chat and try to validate it through\n      // another request, but that becomes too much work.\n      return __1.utils.getInputPeer(users[0]);\n    }\n  } else if (peer instanceof tl_1.Api.PeerChat) {\n    return new tl_1.Api.InputPeerChat({\n      chatId: peer.chatId\n    });\n  } else if (peer instanceof tl_1.Api.PeerChannel) {\n    try {\n      const channels = await client.invoke(new tl_1.Api.channels.GetChannels({\n        id: [new tl_1.Api.InputChannel({\n          channelId: peer.channelId,\n          accessHash: big_integer_1.default.zero\n        })]\n      }));\n      return __1.utils.getInputPeer(channels.chats[0]);\n    } catch (e) {\n      if (client._log.canSend(Logger_1.LogLevel.ERROR)) {\n        console.error(e);\n      }\n    }\n  }\n  throw new Error(`Could not find the input entity for ${JSON.stringify(peer)}.\n         Please read https://` + \"docs.telethon.dev/en/stable/concepts/entities.html to\" + \" find out more details.\");\n}\nexports.getInputEntity = getInputEntity;\n/** @hidden */\nasync function _getEntityFromString(client, string) {\n  const phone = __1.utils.parsePhone(string);\n  if (phone) {\n    try {\n      const result = await client.invoke(new tl_1.Api.contacts.GetContacts({\n        hash: big_integer_1.default.zero\n      }));\n      if (!(result instanceof tl_1.Api.contacts.ContactsNotModified)) {\n        for (const user of result.users) {\n          if (user instanceof tl_1.Api.User && user.phone === phone) {\n            return user;\n          }\n        }\n      }\n    } catch (e) {\n      if (e.errorMessage === \"BOT_METHOD_INVALID\") {\n        throw new Error(\"Cannot get entity by phone number as a \" + \"bot (try using integer IDs, not strings)\");\n      }\n      throw e;\n    }\n  }\n  const id = __1.utils.parseID(string);\n  if (id != undefined) {\n    return getInputEntity(client, id);\n  } else if ([\"me\", \"this\"].includes(string.toLowerCase())) {\n    return client.getMe();\n  } else {\n    const {\n      username,\n      isInvite\n    } = __1.utils.parseUsername(string);\n    if (isInvite) {\n      const invite = await client.invoke(new tl_1.Api.messages.CheckChatInvite({\n        hash: username\n      }));\n      if (invite instanceof tl_1.Api.ChatInvite) {\n        throw new Error(\"Cannot get entity from a channel (or group) \" + \"that you are not part of. Join the group and retry\");\n      } else if (invite instanceof tl_1.Api.ChatInviteAlready) {\n        return invite.chat;\n      }\n    } else if (username) {\n      try {\n        const result = await client.invoke(new tl_1.Api.contacts.ResolveUsername({\n          username: username\n        }));\n        const pid = __1.utils.getPeerId(result.peer, false);\n        if (result.peer instanceof tl_1.Api.PeerUser) {\n          for (const x of result.users) {\n            if ((0, Helpers_1.returnBigInt)(x.id).equals((0, Helpers_1.returnBigInt)(pid))) {\n              return x;\n            }\n          }\n        } else {\n          for (const x of result.chats) {\n            if ((0, Helpers_1.returnBigInt)(x.id).equals((0, Helpers_1.returnBigInt)(pid))) {\n              return x;\n            }\n          }\n        }\n      } catch (e) {\n        if (e.errorMessage === \"USERNAME_NOT_OCCUPIED\") {\n          throw new Error(`No user has \"${username}\" as username`);\n        }\n        throw e;\n      }\n    }\n  }\n  throw new Error(`Cannot find any entity corresponding to \"${string}\"`);\n}\nexports._getEntityFromString = _getEntityFromString;\n/** @hidden */\nasync function getPeerId(client, peer, addMark = true) {\n  if (typeof peer == \"string\") {\n    const valid = (0, Utils_1.parseID)(peer);\n    if (valid) {\n      return __1.utils.getPeerId(peer, addMark);\n    } else {\n      peer = await client.getInputEntity(peer);\n    }\n  }\n  if (typeof peer == \"number\" || typeof peer == \"bigint\" || big_integer_1.default.isInstance(peer)) {\n    return __1.utils.getPeerId(peer, addMark);\n  }\n  if (peer.SUBCLASS_OF_ID == 0x2d45687 || peer.SUBCLASS_OF_ID == 0xc91c90b6) {\n    peer = await client.getInputEntity(peer);\n  }\n  if (peer instanceof tl_1.Api.InputPeerSelf) {\n    peer = await client.getMe(true);\n  }\n  return __1.utils.getPeerId(peer, addMark);\n}\nexports.getPeerId = getPeerId;\n/** @hidden */\nasync function _getPeer(client, peer) {\n  if (!peer) {\n    return undefined;\n  }\n  const [i, cls] = __1.utils.resolveId((0, Helpers_1.returnBigInt)(await client.getPeerId(peer)));\n  return new cls({\n    userId: i,\n    channelId: i,\n    chatId: i\n  });\n}\nexports._getPeer = _getPeer;\n/** @hidden */\nasync function _getInputDialog(client, dialog) {\n  try {\n    if (dialog.SUBCLASS_OF_ID == 0xa21c9795) {\n      // crc32(b'InputDialogPeer')\n      dialog.peer = await client.getInputEntity(dialog.peer);\n      return dialog;\n    } else if (dialog.SUBCLASS_OF_ID == 0xc91c90b6) {\n      //crc32(b'InputPeer')\n      return new tl_1.Api.InputDialogPeer({\n        peer: dialog\n      });\n    }\n  } catch (e) {}\n  return new tl_1.Api.InputDialogPeer({\n    peer: dialog\n  });\n}\nexports._getInputDialog = _getInputDialog;\n/** @hidden */\nasync function _getInputNotify(client, notify) {\n  try {\n    if (notify.SUBCLASS_OF_ID == 0x58981615) {\n      if (notify instanceof tl_1.Api.InputNotifyPeer) {\n        notify.peer = await client.getInputEntity(notify.peer);\n      }\n      return notify;\n    }\n  } catch (e) {}\n  return new tl_1.Api.InputNotifyPeer({\n    peer: await client.getInputEntity(notify)\n  });\n}\nexports._getInputNotify = _getInputNotify;\n/** @hidden */\nfunction _selfId(client) {\n  return client._selfInputPeer ? client._selfInputPeer.userId : undefined;\n}\nexports._selfId = _selfId;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","_selfId","_getInputNotify","_getInputDialog","_getPeer","getPeerId","_getEntityFromString","getInputEntity","getEntity","isUserAuthorized","isBot","getMe","invoke","tl_1","require","Utils_1","Helpers_1","__1","big_integer_1","Logger_1","RequestState_1","client","request","dcId","otherSender","classType","Error","sender","_sender","getSender","undefined","_connectedDeferred","promise","resolve","utils","_lastRequest","Date","getTime","state","RequestState","attempt","_requestRetries","addStateToQueue","result","finished","session","processEntities","_entityCache","add","e","errors","ServerError","errorMessage","_log","warn","constructor","name","sleep","FloodWaitError","FloodTestPhoneWaitError","seconds","floodSleepThreshold","info","className","PhoneMigrateError","NetworkMigrateError","UserMigrateError","newDc","shouldRaise","_switchDC","MsgWaitError","isReady","after","message","disconnect","connect","resetPromise","inputPeer","_selfInputPeer","me","Api","users","GetUsers","id","InputUserSelf","_bot","bot","getInputPeer","InputPeerUser","updates","GetState","entity","single","isArrayLike","entityArray","push","inputs","x","valid","parseID","lists","Map","_EntityType","USER","CHAT","CHANNEL","get","_entityType","chats","channels","length","chatIds","map","chatId","messages","GetChats","GetChannels","idEntity","user","set","channel","chat","InputPeerSelf","key","u","entries","User","self","peer","res","default","isInstance","toString","SUBCLASS_OF_ID","includes","returnBigInt","getPeer","PeerUser","InputUser","userId","accessHash","zero","UserEmpty","PeerChat","InputPeerChat","PeerChannel","InputChannel","channelId","canSend","LogLevel","ERROR","console","error","JSON","stringify","string","phone","parsePhone","contacts","GetContacts","hash","ContactsNotModified","toLowerCase","username","isInvite","parseUsername","invite","CheckChatInvite","ChatInvite","ChatInviteAlready","ResolveUsername","pid","equals","addMark","i","cls","resolveId","dialog","InputDialogPeer","notify","InputNotifyPeer"],"sources":["C:/Users/Muhammed/Desktop/REACT_JS/dene-gramjs/node_modules/telegram/client/users.js"],"sourcesContent":["\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports._selfId = exports._getInputNotify = exports._getInputDialog = exports._getPeer = exports.getPeerId = exports._getEntityFromString = exports.getInputEntity = exports.getEntity = exports.isUserAuthorized = exports.isBot = exports.getMe = exports.invoke = void 0;\r\nconst tl_1 = require(\"../tl\");\r\nconst Utils_1 = require(\"../Utils\");\r\nconst Helpers_1 = require(\"../Helpers\");\r\nconst __1 = require(\"../\");\r\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\r\nconst Logger_1 = require(\"../extensions/Logger\");\r\nconst RequestState_1 = require(\"../network/RequestState\");\r\n// UserMethods {\r\n// region Invoking Telegram request\r\n/** @hidden */\r\nasync function invoke(client, request, dcId, otherSender) {\r\n    if (request.classType !== \"request\") {\r\n        throw new Error(\"You can only invoke MTProtoRequests\");\r\n    }\r\n    let sender = client._sender;\r\n    if (dcId) {\r\n        sender = await client.getSender(dcId);\r\n    }\r\n    if (otherSender != undefined) {\r\n        sender = otherSender;\r\n    }\r\n    if (sender == undefined) {\r\n        throw new Error(\"Cannot send requests while disconnected. You need to call .connect()\");\r\n    }\r\n    await client._connectedDeferred.promise;\r\n    await request.resolve(client, __1.utils);\r\n    client._lastRequest = new Date().getTime();\r\n    const state = new RequestState_1.RequestState(request);\r\n    let attempt = 0;\r\n    for (attempt = 0; attempt < client._requestRetries; attempt++) {\r\n        sender.addStateToQueue(state);\r\n        try {\r\n            const result = await state.promise;\r\n            state.finished.resolve();\r\n            client.session.processEntities(result);\r\n            client._entityCache.add(result);\r\n            return result;\r\n        }\r\n        catch (e) {\r\n            if (e instanceof __1.errors.ServerError ||\r\n                e.errorMessage === \"RPC_CALL_FAIL\" ||\r\n                e.errorMessage === \"RPC_MCGET_FAIL\") {\r\n                client._log.warn(`Telegram is having internal issues ${e.constructor.name}`);\r\n                await (0, Helpers_1.sleep)(2000);\r\n            }\r\n            else if (e instanceof __1.errors.FloodWaitError ||\r\n                e instanceof __1.errors.FloodTestPhoneWaitError) {\r\n                if (e.seconds <= client.floodSleepThreshold) {\r\n                    client._log.info(`Sleeping for ${e.seconds}s on flood wait (Caused by ${request.className})`);\r\n                    await (0, Helpers_1.sleep)(e.seconds * 1000);\r\n                }\r\n                else {\r\n                    state.finished.resolve();\r\n                    throw e;\r\n                }\r\n            }\r\n            else if (e instanceof __1.errors.PhoneMigrateError ||\r\n                e instanceof __1.errors.NetworkMigrateError ||\r\n                e instanceof __1.errors.UserMigrateError) {\r\n                client._log.info(`Phone migrated to ${e.newDc}`);\r\n                const shouldRaise = e instanceof __1.errors.PhoneMigrateError ||\r\n                    e instanceof __1.errors.NetworkMigrateError;\r\n                if (shouldRaise && (await client.isUserAuthorized())) {\r\n                    state.finished.resolve();\r\n                    throw e;\r\n                }\r\n                await client._switchDC(e.newDc);\r\n                sender =\r\n                    dcId === undefined\r\n                        ? client._sender\r\n                        : await client.getSender(dcId);\r\n            }\r\n            else if (e instanceof __1.errors.MsgWaitError) {\r\n                // We need to resend this after the old one was confirmed.\r\n                await state.isReady();\r\n                state.after = undefined;\r\n            }\r\n            else if (e.message === \"CONNECTION_NOT_INITED\") {\r\n                await client.disconnect();\r\n                await (0, Helpers_1.sleep)(2000);\r\n                await client.connect();\r\n            }\r\n            else {\r\n                state.finished.resolve();\r\n                throw e;\r\n            }\r\n        }\r\n        state.resetPromise();\r\n    }\r\n    throw new Error(`Request was unsuccessful ${attempt} time(s)`);\r\n}\r\nexports.invoke = invoke;\r\n/** @hidden */\r\nasync function getMe(client, inputPeer = false) {\r\n    if (inputPeer && client._selfInputPeer) {\r\n        return client._selfInputPeer;\r\n    }\r\n    const me = (await client.invoke(new tl_1.Api.users.GetUsers({ id: [new tl_1.Api.InputUserSelf()] })))[0];\r\n    client._bot = me.bot;\r\n    if (!client._selfInputPeer) {\r\n        client._selfInputPeer = __1.utils.getInputPeer(me, false);\r\n    }\r\n    return inputPeer ? client._selfInputPeer : me;\r\n}\r\nexports.getMe = getMe;\r\n/** @hidden */\r\nasync function isBot(client) {\r\n    if (client._bot === undefined) {\r\n        const me = await client.getMe();\r\n        if (me) {\r\n            return !(me instanceof tl_1.Api.InputPeerUser) ? me.bot : undefined;\r\n        }\r\n    }\r\n    return client._bot;\r\n}\r\nexports.isBot = isBot;\r\n/** @hidden */\r\nasync function isUserAuthorized(client) {\r\n    try {\r\n        await client.invoke(new tl_1.Api.updates.GetState());\r\n        return true;\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n}\r\nexports.isUserAuthorized = isUserAuthorized;\r\n/** @hidden */\r\nasync function getEntity(client, entity) {\r\n    const single = !(0, Helpers_1.isArrayLike)(entity);\r\n    let entityArray = [];\r\n    if ((0, Helpers_1.isArrayLike)(entity)) {\r\n        entityArray = entity;\r\n    }\r\n    else {\r\n        entityArray.push(entity);\r\n    }\r\n    const inputs = [];\r\n    for (const x of entityArray) {\r\n        if (typeof x === \"string\") {\r\n            const valid = (0, Utils_1.parseID)(x);\r\n            if (valid) {\r\n                inputs.push(await client.getInputEntity(valid));\r\n            }\r\n            else {\r\n                inputs.push(x);\r\n            }\r\n        }\r\n        else {\r\n            inputs.push(await client.getInputEntity(x));\r\n        }\r\n    }\r\n    const lists = new Map([\r\n        [Helpers_1._EntityType.USER, []],\r\n        [Helpers_1._EntityType.CHAT, []],\r\n        [Helpers_1._EntityType.CHANNEL, []],\r\n    ]);\r\n    for (const x of inputs) {\r\n        try {\r\n            lists.get((0, Helpers_1._entityType)(x)).push(x);\r\n        }\r\n        catch (e) { }\r\n    }\r\n    let users = lists.get(Helpers_1._EntityType.USER);\r\n    let chats = lists.get(Helpers_1._EntityType.CHAT);\r\n    let channels = lists.get(Helpers_1._EntityType.CHANNEL);\r\n    if (users.length) {\r\n        users = await client.invoke(new tl_1.Api.users.GetUsers({\r\n            id: users,\r\n        }));\r\n    }\r\n    if (chats.length) {\r\n        const chatIds = chats.map((x) => x.chatId);\r\n        chats = (await client.invoke(new tl_1.Api.messages.GetChats({ id: chatIds }))).chats;\r\n    }\r\n    if (channels.length) {\r\n        channels = (await client.invoke(new tl_1.Api.channels.GetChannels({ id: channels }))).chats;\r\n    }\r\n    const idEntity = new Map();\r\n    for (const user of users) {\r\n        idEntity.set((0, Utils_1.getPeerId)(user), user);\r\n    }\r\n    for (const channel of channels) {\r\n        idEntity.set((0, Utils_1.getPeerId)(channel), channel);\r\n    }\r\n    for (const chat of chats) {\r\n        idEntity.set((0, Utils_1.getPeerId)(chat), chat);\r\n    }\r\n    const result = [];\r\n    for (const x of inputs) {\r\n        if (typeof x === \"string\") {\r\n            result.push(await _getEntityFromString(client, x));\r\n        }\r\n        else if (!(x instanceof tl_1.Api.InputPeerSelf)) {\r\n            result.push(idEntity.get((0, Utils_1.getPeerId)(x)));\r\n        }\r\n        else {\r\n            for (const [key, u] of idEntity.entries()) {\r\n                if (u instanceof tl_1.Api.User && u.self) {\r\n                    result.push(u);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return single ? result[0] : result;\r\n}\r\nexports.getEntity = getEntity;\r\n/** @hidden */\r\nasync function getInputEntity(client, peer) {\r\n    // Short-circuit if the input parameter directly maps to an InputPeer\r\n    try {\r\n        return __1.utils.getInputPeer(peer);\r\n        // eslint-disable-next-line no-empty\r\n    }\r\n    catch (e) { }\r\n    // Next in priority is having a peer (or its ID) cached in-memory\r\n    try {\r\n        if (typeof peer == \"string\") {\r\n            const valid = (0, Utils_1.parseID)(peer);\r\n            if (valid) {\r\n                const res = client._entityCache.get(peer);\r\n                if (res) {\r\n                    return res;\r\n                }\r\n            }\r\n        }\r\n        if (typeof peer === \"number\" ||\r\n            typeof peer === \"bigint\" ||\r\n            big_integer_1.default.isInstance(peer)) {\r\n            const res = client._entityCache.get(peer.toString());\r\n            if (res) {\r\n                return res;\r\n            }\r\n        }\r\n        // 0x2d45687 == crc32(b'Peer')\r\n        if (typeof peer == \"object\" &&\r\n            !big_integer_1.default.isInstance(peer) &&\r\n            peer.SUBCLASS_OF_ID === 0x2d45687) {\r\n            const res = client._entityCache.get(__1.utils.getPeerId(peer));\r\n            if (res) {\r\n                return res;\r\n            }\r\n        }\r\n        // eslint-disable-next-line no-empty\r\n    }\r\n    catch (e) { }\r\n    // Then come known strings that take precedence\r\n    if (typeof peer == \"string\") {\r\n        if ([\"me\", \"this\", \"self\"].includes(peer)) {\r\n            return new tl_1.Api.InputPeerSelf();\r\n        }\r\n    }\r\n    // No InputPeer, cached peer, or known string. Fetch from disk cache\r\n    try {\r\n        if (peer != undefined) {\r\n            return client.session.getInputEntity(peer);\r\n        }\r\n        // eslint-disable-next-line no-empty\r\n    }\r\n    catch (e) { }\r\n    // Only network left to try\r\n    if (typeof peer === \"string\") {\r\n        return __1.utils.getInputPeer(await _getEntityFromString(client, peer));\r\n    }\r\n    // If we're a bot and the user has messaged us privately users.getUsers\r\n    // will work with accessHash = 0. Similar for channels.getChannels.\r\n    // If we're not a bot but the user is in our contacts, it seems to work\r\n    // regardless. These are the only two special-cased requests.\r\n    if (typeof peer === \"number\") {\r\n        peer = (0, Helpers_1.returnBigInt)(peer);\r\n    }\r\n    peer = __1.utils.getPeer(peer);\r\n    if (peer instanceof tl_1.Api.PeerUser) {\r\n        const users = await client.invoke(new tl_1.Api.users.GetUsers({\r\n            id: [\r\n                new tl_1.Api.InputUser({\r\n                    userId: peer.userId,\r\n                    accessHash: big_integer_1.default.zero,\r\n                }),\r\n            ],\r\n        }));\r\n        if (users.length && !(users[0] instanceof tl_1.Api.UserEmpty)) {\r\n            // If the user passed a valid ID they expect to work for\r\n            // channels but would be valid for users, we get UserEmpty.\r\n            // Avoid returning the invalid empty input peer for that.\r\n            //\r\n            // We *could* try to guess if it's a channel first, and if\r\n            // it's not, work as a chat and try to validate it through\r\n            // another request, but that becomes too much work.\r\n            return __1.utils.getInputPeer(users[0]);\r\n        }\r\n    }\r\n    else if (peer instanceof tl_1.Api.PeerChat) {\r\n        return new tl_1.Api.InputPeerChat({\r\n            chatId: peer.chatId,\r\n        });\r\n    }\r\n    else if (peer instanceof tl_1.Api.PeerChannel) {\r\n        try {\r\n            const channels = await client.invoke(new tl_1.Api.channels.GetChannels({\r\n                id: [\r\n                    new tl_1.Api.InputChannel({\r\n                        channelId: peer.channelId,\r\n                        accessHash: big_integer_1.default.zero,\r\n                    }),\r\n                ],\r\n            }));\r\n            return __1.utils.getInputPeer(channels.chats[0]);\r\n        }\r\n        catch (e) {\r\n            if (client._log.canSend(Logger_1.LogLevel.ERROR)) {\r\n                console.error(e);\r\n            }\r\n        }\r\n    }\r\n    throw new Error(`Could not find the input entity for ${JSON.stringify(peer)}.\r\n         Please read https://` +\r\n        \"docs.telethon.dev/en/stable/concepts/entities.html to\" +\r\n        \" find out more details.\");\r\n}\r\nexports.getInputEntity = getInputEntity;\r\n/** @hidden */\r\nasync function _getEntityFromString(client, string) {\r\n    const phone = __1.utils.parsePhone(string);\r\n    if (phone) {\r\n        try {\r\n            const result = await client.invoke(new tl_1.Api.contacts.GetContacts({\r\n                hash: big_integer_1.default.zero,\r\n            }));\r\n            if (!(result instanceof tl_1.Api.contacts.ContactsNotModified)) {\r\n                for (const user of result.users) {\r\n                    if (user instanceof tl_1.Api.User && user.phone === phone) {\r\n                        return user;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            if (e.errorMessage === \"BOT_METHOD_INVALID\") {\r\n                throw new Error(\"Cannot get entity by phone number as a \" +\r\n                    \"bot (try using integer IDs, not strings)\");\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n    const id = __1.utils.parseID(string);\r\n    if (id != undefined) {\r\n        return getInputEntity(client, id);\r\n    }\r\n    else if ([\"me\", \"this\"].includes(string.toLowerCase())) {\r\n        return client.getMe();\r\n    }\r\n    else {\r\n        const { username, isInvite } = __1.utils.parseUsername(string);\r\n        if (isInvite) {\r\n            const invite = await client.invoke(new tl_1.Api.messages.CheckChatInvite({\r\n                hash: username,\r\n            }));\r\n            if (invite instanceof tl_1.Api.ChatInvite) {\r\n                throw new Error(\"Cannot get entity from a channel (or group) \" +\r\n                    \"that you are not part of. Join the group and retry\");\r\n            }\r\n            else if (invite instanceof tl_1.Api.ChatInviteAlready) {\r\n                return invite.chat;\r\n            }\r\n        }\r\n        else if (username) {\r\n            try {\r\n                const result = await client.invoke(new tl_1.Api.contacts.ResolveUsername({ username: username }));\r\n                const pid = __1.utils.getPeerId(result.peer, false);\r\n                if (result.peer instanceof tl_1.Api.PeerUser) {\r\n                    for (const x of result.users) {\r\n                        if ((0, Helpers_1.returnBigInt)(x.id).equals((0, Helpers_1.returnBigInt)(pid))) {\r\n                            return x;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    for (const x of result.chats) {\r\n                        if ((0, Helpers_1.returnBigInt)(x.id).equals((0, Helpers_1.returnBigInt)(pid))) {\r\n                            return x;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            catch (e) {\r\n                if (e.errorMessage === \"USERNAME_NOT_OCCUPIED\") {\r\n                    throw new Error(`No user has \"${username}\" as username`);\r\n                }\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n    throw new Error(`Cannot find any entity corresponding to \"${string}\"`);\r\n}\r\nexports._getEntityFromString = _getEntityFromString;\r\n/** @hidden */\r\nasync function getPeerId(client, peer, addMark = true) {\r\n    if (typeof peer == \"string\") {\r\n        const valid = (0, Utils_1.parseID)(peer);\r\n        if (valid) {\r\n            return __1.utils.getPeerId(peer, addMark);\r\n        }\r\n        else {\r\n            peer = await client.getInputEntity(peer);\r\n        }\r\n    }\r\n    if (typeof peer == \"number\" ||\r\n        typeof peer == \"bigint\" ||\r\n        big_integer_1.default.isInstance(peer)) {\r\n        return __1.utils.getPeerId(peer, addMark);\r\n    }\r\n    if (peer.SUBCLASS_OF_ID == 0x2d45687 || peer.SUBCLASS_OF_ID == 0xc91c90b6) {\r\n        peer = await client.getInputEntity(peer);\r\n    }\r\n    if (peer instanceof tl_1.Api.InputPeerSelf) {\r\n        peer = await client.getMe(true);\r\n    }\r\n    return __1.utils.getPeerId(peer, addMark);\r\n}\r\nexports.getPeerId = getPeerId;\r\n/** @hidden */\r\nasync function _getPeer(client, peer) {\r\n    if (!peer) {\r\n        return undefined;\r\n    }\r\n    const [i, cls] = __1.utils.resolveId((0, Helpers_1.returnBigInt)(await client.getPeerId(peer)));\r\n    return new cls({\r\n        userId: i,\r\n        channelId: i,\r\n        chatId: i,\r\n    });\r\n}\r\nexports._getPeer = _getPeer;\r\n/** @hidden */\r\nasync function _getInputDialog(client, dialog) {\r\n    try {\r\n        if (dialog.SUBCLASS_OF_ID == 0xa21c9795) {\r\n            // crc32(b'InputDialogPeer')\r\n            dialog.peer = await client.getInputEntity(dialog.peer);\r\n            return dialog;\r\n        }\r\n        else if (dialog.SUBCLASS_OF_ID == 0xc91c90b6) {\r\n            //crc32(b'InputPeer')\r\n            return new tl_1.Api.InputDialogPeer({\r\n                peer: dialog,\r\n            });\r\n        }\r\n    }\r\n    catch (e) { }\r\n    return new tl_1.Api.InputDialogPeer({\r\n        peer: dialog,\r\n    });\r\n}\r\nexports._getInputDialog = _getInputDialog;\r\n/** @hidden */\r\nasync function _getInputNotify(client, notify) {\r\n    try {\r\n        if (notify.SUBCLASS_OF_ID == 0x58981615) {\r\n            if (notify instanceof tl_1.Api.InputNotifyPeer) {\r\n                notify.peer = await client.getInputEntity(notify.peer);\r\n            }\r\n            return notify;\r\n        }\r\n    }\r\n    catch (e) { }\r\n    return new tl_1.Api.InputNotifyPeer({\r\n        peer: await client.getInputEntity(notify),\r\n    });\r\n}\r\nexports._getInputNotify = _getInputNotify;\r\n/** @hidden */\r\nfunction _selfId(client) {\r\n    return client._selfInputPeer ? client._selfInputPeer.userId : undefined;\r\n}\r\nexports._selfId = _selfId;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}