{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StringSession = void 0;\nconst buffer_1 = require(\"buffer/\");\nconst Memory_1 = require(\"./Memory\");\nconst extensions_1 = require(\"../extensions\");\nconst AuthKey_1 = require(\"../crypto/AuthKey\");\nconst CURRENT_VERSION = \"1\";\nclass StringSession extends Memory_1.MemorySession {\n  /**\r\n   * This session file can be easily saved and loaded as a string. According\r\n   * to the initial design, it contains only the data that is necessary for\r\n   * successful connection and authentication, so takeout ID is not stored.\r\n     * It is thought to be used where you don't want to create any on-disk\r\n   * files but would still like to be able to save and load existing sessions\r\n   * by other means.\r\n     * You can use custom `encode` and `decode` functions, if present:\r\n     * `encode` definition must be ``function encode(value: Buffer) -> string:``.\r\n   * `decode` definition must be ``function decode(value: string) -> Buffer:``.\r\n   * @param session {string|null}\r\n   */\n  constructor(session) {\n    super();\n    if (session) {\n      if (session[0] !== CURRENT_VERSION) {\n        throw new Error(\"Not a valid string\");\n      }\n      session = session.slice(1);\n      const r = StringSession.decode(session);\n      const reader = new extensions_1.BinaryReader(r);\n      this._dcId = reader.read(1).readUInt8(0);\n      if (session.length == 352) {\n        // Telethon session\n        const ip_v4 = reader.read(4);\n        // TODO looks ugly smh\n        this._serverAddress = ip_v4[0].toString() + \".\" + ip_v4[1].toString() + \".\" + ip_v4[2].toString() + \".\" + ip_v4[3].toString();\n      } else {\n        // TODO find a better of doing this\n        const serverAddressLen = reader.read(2).readInt16BE(0);\n        if (serverAddressLen > 100) {\n          reader.offset -= 2;\n          this._serverAddress = reader.read(16).toString(\"hex\").match(/.{1,4}/g).map(val => val.replace(/^0+/, \"\")).join(\":\").replace(/0000\\:/g, \":\").replace(/:{2,}/g, \"::\");\n        } else {\n          this._serverAddress = reader.read(serverAddressLen).toString();\n        }\n      }\n      this._port = reader.read(2).readInt16BE(0);\n      this._key = reader.read(-1);\n    }\n  }\n  /**\r\n   * @param x {Buffer}\r\n   * @returns {string}\r\n   */\n  static encode(x) {\n    return x.toString(\"base64\");\n  }\n  /**\r\n   * @param x {string}\r\n   * @returns {Buffer}\r\n   */\n  static decode(x) {\n    return buffer_1.Buffer.from(x, \"base64\");\n  }\n  async load() {\n    if (this._key) {\n      this._authKey = new AuthKey_1.AuthKey();\n      await this._authKey.setKey(this._key);\n    }\n  }\n  save() {\n    if (!this.authKey || !this.serverAddress || !this.port) {\n      return \"\";\n    }\n    // TS is weird\n    const key = this.authKey.getKey();\n    if (!key) {\n      return \"\";\n    }\n    const dcBuffer = buffer_1.Buffer.from([this.dcId]);\n    const addressBuffer = buffer_1.Buffer.from(this.serverAddress);\n    const addressLengthBuffer = buffer_1.Buffer.alloc(2);\n    addressLengthBuffer.writeInt16BE(addressBuffer.length, 0);\n    const portBuffer = buffer_1.Buffer.alloc(2);\n    portBuffer.writeInt16BE(this.port, 0);\n    return CURRENT_VERSION + StringSession.encode(buffer_1.Buffer.concat([dcBuffer, addressLengthBuffer, addressBuffer, portBuffer, key]));\n  }\n}\nexports.StringSession = StringSession;","map":{"version":3,"names":["Object","defineProperty","exports","value","StringSession","buffer_1","require","Memory_1","extensions_1","AuthKey_1","CURRENT_VERSION","MemorySession","constructor","session","Error","slice","r","decode","reader","BinaryReader","_dcId","read","readUInt8","length","ip_v4","_serverAddress","toString","serverAddressLen","readInt16BE","offset","match","map","val","replace","join","_port","_key","encode","x","Buffer","from","load","_authKey","AuthKey","setKey","save","authKey","serverAddress","port","key","getKey","dcBuffer","dcId","addressBuffer","addressLengthBuffer","alloc","writeInt16BE","portBuffer","concat"],"sources":["C:/Users/Muhammed/Desktop/REACT_JS/dene-gramjs/node_modules/telegram/sessions/StringSession.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.StringSession = void 0;\r\nconst buffer_1 = require(\"buffer/\");\r\nconst Memory_1 = require(\"./Memory\");\r\nconst extensions_1 = require(\"../extensions\");\r\nconst AuthKey_1 = require(\"../crypto/AuthKey\");\r\nconst CURRENT_VERSION = \"1\";\r\nclass StringSession extends Memory_1.MemorySession {\r\n    /**\r\n     * This session file can be easily saved and loaded as a string. According\r\n     * to the initial design, it contains only the data that is necessary for\r\n     * successful connection and authentication, so takeout ID is not stored.\r\n\r\n     * It is thought to be used where you don't want to create any on-disk\r\n     * files but would still like to be able to save and load existing sessions\r\n     * by other means.\r\n\r\n     * You can use custom `encode` and `decode` functions, if present:\r\n\r\n     * `encode` definition must be ``function encode(value: Buffer) -> string:``.\r\n     * `decode` definition must be ``function decode(value: string) -> Buffer:``.\r\n     * @param session {string|null}\r\n     */\r\n    constructor(session) {\r\n        super();\r\n        if (session) {\r\n            if (session[0] !== CURRENT_VERSION) {\r\n                throw new Error(\"Not a valid string\");\r\n            }\r\n            session = session.slice(1);\r\n            const r = StringSession.decode(session);\r\n            const reader = new extensions_1.BinaryReader(r);\r\n            this._dcId = reader.read(1).readUInt8(0);\r\n            if (session.length == 352) {\r\n                // Telethon session\r\n                const ip_v4 = reader.read(4);\r\n                // TODO looks ugly smh\r\n                this._serverAddress =\r\n                    ip_v4[0].toString() +\r\n                        \".\" +\r\n                        ip_v4[1].toString() +\r\n                        \".\" +\r\n                        ip_v4[2].toString() +\r\n                        \".\" +\r\n                        ip_v4[3].toString();\r\n            }\r\n            else {\r\n                // TODO find a better of doing this\r\n                const serverAddressLen = reader.read(2).readInt16BE(0);\r\n                if (serverAddressLen > 100) {\r\n                    reader.offset -= 2;\r\n                    this._serverAddress = reader\r\n                        .read(16)\r\n                        .toString(\"hex\")\r\n                        .match(/.{1,4}/g)\r\n                        .map((val) => val.replace(/^0+/, \"\"))\r\n                        .join(\":\")\r\n                        .replace(/0000\\:/g, \":\")\r\n                        .replace(/:{2,}/g, \"::\");\r\n                }\r\n                else {\r\n                    this._serverAddress = reader\r\n                        .read(serverAddressLen)\r\n                        .toString();\r\n                }\r\n            }\r\n            this._port = reader.read(2).readInt16BE(0);\r\n            this._key = reader.read(-1);\r\n        }\r\n    }\r\n    /**\r\n     * @param x {Buffer}\r\n     * @returns {string}\r\n     */\r\n    static encode(x) {\r\n        return x.toString(\"base64\");\r\n    }\r\n    /**\r\n     * @param x {string}\r\n     * @returns {Buffer}\r\n     */\r\n    static decode(x) {\r\n        return buffer_1.Buffer.from(x, \"base64\");\r\n    }\r\n    async load() {\r\n        if (this._key) {\r\n            this._authKey = new AuthKey_1.AuthKey();\r\n            await this._authKey.setKey(this._key);\r\n        }\r\n    }\r\n    save() {\r\n        if (!this.authKey || !this.serverAddress || !this.port) {\r\n            return \"\";\r\n        }\r\n        // TS is weird\r\n        const key = this.authKey.getKey();\r\n        if (!key) {\r\n            return \"\";\r\n        }\r\n        const dcBuffer = buffer_1.Buffer.from([this.dcId]);\r\n        const addressBuffer = buffer_1.Buffer.from(this.serverAddress);\r\n        const addressLengthBuffer = buffer_1.Buffer.alloc(2);\r\n        addressLengthBuffer.writeInt16BE(addressBuffer.length, 0);\r\n        const portBuffer = buffer_1.Buffer.alloc(2);\r\n        portBuffer.writeInt16BE(this.port, 0);\r\n        return (CURRENT_VERSION +\r\n            StringSession.encode(buffer_1.Buffer.concat([\r\n                dcBuffer,\r\n                addressLengthBuffer,\r\n                addressBuffer,\r\n                portBuffer,\r\n                key,\r\n            ])));\r\n    }\r\n}\r\nexports.StringSession = StringSession;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}