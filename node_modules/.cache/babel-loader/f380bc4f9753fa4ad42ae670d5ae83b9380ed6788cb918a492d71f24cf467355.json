{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MessagePacker = void 0;\nconst buffer_1 = require(\"buffer/\");\nconst core_1 = require(\"../tl/core\");\nconst core_2 = require(\"../tl/core\");\nconst BinaryWriter_1 = require(\"./BinaryWriter\");\nconst USE_INVOKE_AFTER_WITH = new Set([\"messages.SendMessage\", \"messages.SendMedia\", \"messages.SendMultiMedia\", \"messages.ForwardMessages\", \"messages.SendInlineBotResult\"]);\nclass MessagePacker {\n  constructor(state, logger) {\n    this._state = state;\n    this._queue = [];\n    this._pendingStates = [];\n    this._ready = new Promise(resolve => {\n      this.setReady = resolve;\n    });\n    this._log = logger;\n  }\n  values() {\n    return this._queue;\n  }\n  append(state, setReady = true, atStart = false) {\n    var _a, _b;\n    // We need to check if there is already a `USE_INVOKE_AFTER_WITH` request\n    if (state && USE_INVOKE_AFTER_WITH.has(state.request.className)) {\n      if (atStart) {\n        // Assign `after` for the previously first `USE_INVOKE_AFTER_WITH` request\n        for (let i = 0; i < this._queue.length; i++) {\n          if (USE_INVOKE_AFTER_WITH.has((_a = this._queue[i]) === null || _a === void 0 ? void 0 : _a.request.className)) {\n            this._queue[i].after = state;\n            break;\n          }\n        }\n      } else {\n        // Assign after for the previous `USE_INVOKE_AFTER_WITH` request\n        for (let i = this._queue.length - 1; i >= 0; i--) {\n          if (USE_INVOKE_AFTER_WITH.has((_b = this._queue[i]) === null || _b === void 0 ? void 0 : _b.request.className)) {\n            state.after = this._queue[i];\n            break;\n          }\n        }\n      }\n    }\n    if (atStart) {\n      this._queue.unshift(state);\n    } else {\n      this._queue.push(state);\n    }\n    if (setReady && this.setReady) {\n      this.setReady(true);\n    }\n    // 1658238041=MsgsAck, we don't care about MsgsAck here because they never resolve anyway.\n    if (state && state.request.CONSTRUCTOR_ID !== 1658238041) {\n      this._pendingStates.push(state);\n      state.promise // Using finally causes triggering `unhandledrejection` event\n      .catch(() => {}).finally(() => {\n        this._pendingStates = this._pendingStates.filter(s => s !== state);\n      });\n    }\n  }\n  prepend(states) {\n    states.reverse().forEach(state => {\n      this.append(state, false, true);\n    });\n    if (this.setReady) {\n      this.setReady(true);\n    }\n  }\n  extend(states) {\n    states.forEach(state => {\n      this.append(state, false);\n    });\n    if (this.setReady) {\n      this.setReady(true);\n    }\n  }\n  clear() {\n    this._queue = [];\n    this.append(undefined);\n  }\n  async wait() {\n    if (!this._queue.length) {\n      this._ready = new Promise(resolve => {\n        this.setReady = resolve;\n      });\n      await this._ready;\n    }\n  }\n  async get() {\n    if (!this._queue[this._queue.length - 1]) {\n      this._queue = this._queue.filter(Boolean);\n      return undefined;\n    }\n    let data;\n    let buffer = new BinaryWriter_1.BinaryWriter(buffer_1.Buffer.alloc(0));\n    const batch = [];\n    let size = 0;\n    while (this._queue.length && batch.length <= core_1.MessageContainer.MAXIMUM_LENGTH) {\n      const state = this._queue.shift();\n      if (!state) {\n        continue;\n      }\n      size += state.data.length + core_2.TLMessage.SIZE_OVERHEAD;\n      if (size <= core_1.MessageContainer.MAXIMUM_SIZE) {\n        let afterId;\n        if (state.after) {\n          afterId = state.after.msgId;\n        }\n        if (state.after) {\n          afterId = state.after.msgId;\n        }\n        state.msgId = await this._state.writeDataAsMessage(buffer, state.data, state.request.classType === \"request\", afterId);\n        this._log.debug(`Assigned msgId = ${state.msgId} to ${state.request.className || state.request.constructor.name}`);\n        batch.push(state);\n        continue;\n      }\n      if (batch.length) {\n        this._queue.unshift(state);\n        break;\n      }\n      this._log.warn(`Message payload for ${state.request.className || state.request.constructor.name} is too long ${state.data.length} and cannot be sent`);\n      state.promise.reject(\"Request Payload is too big\");\n      size = 0;\n    }\n    if (!batch.length) {\n      return null;\n    }\n    if (batch.length > 1) {\n      const b = buffer_1.Buffer.alloc(8);\n      b.writeUInt32LE(core_1.MessageContainer.CONSTRUCTOR_ID, 0);\n      b.writeInt32LE(batch.length, 4);\n      data = buffer_1.Buffer.concat([b, buffer.getValue()]);\n      buffer = new BinaryWriter_1.BinaryWriter(buffer_1.Buffer.alloc(0));\n      const containerId = await this._state.writeDataAsMessage(buffer, data, false);\n      for (const s of batch) {\n        s.containerId = containerId;\n      }\n    }\n    data = buffer.getValue();\n    return {\n      batch,\n      data\n    };\n  }\n}\nexports.MessagePacker = MessagePacker;","map":{"version":3,"names":["Object","defineProperty","exports","value","MessagePacker","buffer_1","require","core_1","core_2","BinaryWriter_1","USE_INVOKE_AFTER_WITH","Set","constructor","state","logger","_state","_queue","_pendingStates","_ready","Promise","resolve","setReady","_log","values","append","atStart","_a","_b","has","request","className","i","length","after","unshift","push","CONSTRUCTOR_ID","promise","catch","finally","filter","s","prepend","states","reverse","forEach","extend","clear","undefined","wait","get","Boolean","data","buffer","BinaryWriter","Buffer","alloc","batch","size","MessageContainer","MAXIMUM_LENGTH","shift","TLMessage","SIZE_OVERHEAD","MAXIMUM_SIZE","afterId","msgId","writeDataAsMessage","classType","debug","name","warn","reject","b","writeUInt32LE","writeInt32LE","concat","getValue","containerId"],"sources":["C:/Users/Muhammed/Desktop/REACT_JS/dene-gramjs/node_modules/telegram/extensions/MessagePacker.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MessagePacker = void 0;\r\nconst buffer_1 = require(\"buffer/\");\r\nconst core_1 = require(\"../tl/core\");\r\nconst core_2 = require(\"../tl/core\");\r\nconst BinaryWriter_1 = require(\"./BinaryWriter\");\r\nconst USE_INVOKE_AFTER_WITH = new Set([\r\n    \"messages.SendMessage\",\r\n    \"messages.SendMedia\",\r\n    \"messages.SendMultiMedia\",\r\n    \"messages.ForwardMessages\",\r\n    \"messages.SendInlineBotResult\",\r\n]);\r\nclass MessagePacker {\r\n    constructor(state, logger) {\r\n        this._state = state;\r\n        this._queue = [];\r\n        this._pendingStates = [];\r\n        this._ready = new Promise((resolve) => {\r\n            this.setReady = resolve;\r\n        });\r\n        this._log = logger;\r\n    }\r\n    values() {\r\n        return this._queue;\r\n    }\r\n    append(state, setReady = true, atStart = false) {\r\n        var _a, _b;\r\n        // We need to check if there is already a `USE_INVOKE_AFTER_WITH` request\r\n        if (state && USE_INVOKE_AFTER_WITH.has(state.request.className)) {\r\n            if (atStart) {\r\n                // Assign `after` for the previously first `USE_INVOKE_AFTER_WITH` request\r\n                for (let i = 0; i < this._queue.length; i++) {\r\n                    if (USE_INVOKE_AFTER_WITH.has((_a = this._queue[i]) === null || _a === void 0 ? void 0 : _a.request.className)) {\r\n                        this._queue[i].after = state;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Assign after for the previous `USE_INVOKE_AFTER_WITH` request\r\n                for (let i = this._queue.length - 1; i >= 0; i--) {\r\n                    if (USE_INVOKE_AFTER_WITH.has((_b = this._queue[i]) === null || _b === void 0 ? void 0 : _b.request.className)) {\r\n                        state.after = this._queue[i];\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (atStart) {\r\n            this._queue.unshift(state);\r\n        }\r\n        else {\r\n            this._queue.push(state);\r\n        }\r\n        if (setReady && this.setReady) {\r\n            this.setReady(true);\r\n        }\r\n        // 1658238041=MsgsAck, we don't care about MsgsAck here because they never resolve anyway.\r\n        if (state && state.request.CONSTRUCTOR_ID !== 1658238041) {\r\n            this._pendingStates.push(state);\r\n            state\r\n                .promise // Using finally causes triggering `unhandledrejection` event\r\n                .catch(() => { })\r\n                .finally(() => {\r\n                this._pendingStates = this._pendingStates.filter((s) => s !== state);\r\n            });\r\n        }\r\n    }\r\n    prepend(states) {\r\n        states.reverse().forEach((state) => {\r\n            this.append(state, false, true);\r\n        });\r\n        if (this.setReady) {\r\n            this.setReady(true);\r\n        }\r\n    }\r\n    extend(states) {\r\n        states.forEach((state) => {\r\n            this.append(state, false);\r\n        });\r\n        if (this.setReady) {\r\n            this.setReady(true);\r\n        }\r\n    }\r\n    clear() {\r\n        this._queue = [];\r\n        this.append(undefined);\r\n    }\r\n    async wait() {\r\n        if (!this._queue.length) {\r\n            this._ready = new Promise((resolve) => {\r\n                this.setReady = resolve;\r\n            });\r\n            await this._ready;\r\n        }\r\n    }\r\n    async get() {\r\n        if (!this._queue[this._queue.length - 1]) {\r\n            this._queue = this._queue.filter(Boolean);\r\n            return undefined;\r\n        }\r\n        let data;\r\n        let buffer = new BinaryWriter_1.BinaryWriter(buffer_1.Buffer.alloc(0));\r\n        const batch = [];\r\n        let size = 0;\r\n        while (this._queue.length &&\r\n            batch.length <= core_1.MessageContainer.MAXIMUM_LENGTH) {\r\n            const state = this._queue.shift();\r\n            if (!state) {\r\n                continue;\r\n            }\r\n            size += state.data.length + core_2.TLMessage.SIZE_OVERHEAD;\r\n            if (size <= core_1.MessageContainer.MAXIMUM_SIZE) {\r\n                let afterId;\r\n                if (state.after) {\r\n                    afterId = state.after.msgId;\r\n                }\r\n                if (state.after) {\r\n                    afterId = state.after.msgId;\r\n                }\r\n                state.msgId = await this._state.writeDataAsMessage(buffer, state.data, state.request.classType === \"request\", afterId);\r\n                this._log.debug(`Assigned msgId = ${state.msgId} to ${state.request.className ||\r\n                    state.request.constructor.name}`);\r\n                batch.push(state);\r\n                continue;\r\n            }\r\n            if (batch.length) {\r\n                this._queue.unshift(state);\r\n                break;\r\n            }\r\n            this._log.warn(`Message payload for ${state.request.className || state.request.constructor.name} is too long ${state.data.length} and cannot be sent`);\r\n            state.promise.reject(\"Request Payload is too big\");\r\n            size = 0;\r\n        }\r\n        if (!batch.length) {\r\n            return null;\r\n        }\r\n        if (batch.length > 1) {\r\n            const b = buffer_1.Buffer.alloc(8);\r\n            b.writeUInt32LE(core_1.MessageContainer.CONSTRUCTOR_ID, 0);\r\n            b.writeInt32LE(batch.length, 4);\r\n            data = buffer_1.Buffer.concat([b, buffer.getValue()]);\r\n            buffer = new BinaryWriter_1.BinaryWriter(buffer_1.Buffer.alloc(0));\r\n            const containerId = await this._state.writeDataAsMessage(buffer, data, false);\r\n            for (const s of batch) {\r\n                s.containerId = containerId;\r\n            }\r\n        }\r\n        data = buffer.getValue();\r\n        return { batch, data };\r\n    }\r\n}\r\nexports.MessagePacker = MessagePacker;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}