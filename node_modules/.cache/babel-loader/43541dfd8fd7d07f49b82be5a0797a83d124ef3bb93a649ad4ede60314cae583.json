{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._updateLoop = exports._dispatchUpdate = exports._processUpdate = exports._handleUpdate = exports.catchUp = exports.listEventHandlers = exports.removeEventHandler = exports.addEventHandler = exports.on = exports.StopPropagation = void 0;\nconst tl_1 = require(\"../tl\");\nconst network_1 = require(\"../network\");\nconst index_1 = require(\"../index\");\nconst Helpers_1 = require(\"../Helpers\");\nconst Logger_1 = require(\"../extensions/Logger\");\nconst PING_INTERVAL = 9000; // 9 sec\nconst PING_TIMEOUT = 10000; // 10 sec\nconst PING_FAIL_ATTEMPTS = 3;\nconst PING_FAIL_INTERVAL = 100; // ms\nconst PING_DISCONNECT_DELAY = 60000; // 1 min\n// An unusually long interval is a sign of returning from background mode...\nconst PING_INTERVAL_TO_WAKE_UP = 5000; // 5 sec\n// ... so we send a quick \"wake-up\" ping to confirm than connection was dropped ASAP\nconst PING_WAKE_UP_TIMEOUT = 3000; // 3 sec\n// We also send a warning to the user even a bit more quickly\nconst PING_WAKE_UP_WARNING_TIMEOUT = 1000; // 1 sec\n/**\r\n If this exception is raised in any of the handlers for a given event,\r\n it will stop the execution of all other registered event handlers.\r\n It can be seen as the ``StopIteration`` in a for loop but for events.\r\n */\nclass StopPropagation extends Error {}\nexports.StopPropagation = StopPropagation;\n/** @hidden */\nfunction on(client, event) {\n  return f => {\n    client.addEventHandler(f, event);\n    return f;\n  };\n}\nexports.on = on;\n/** @hidden */\nfunction addEventHandler(client, callback, event) {\n  if (event == undefined) {\n    // recursive imports :(\n    const raw = require(\"../events/Raw\").Raw;\n    event = new raw({});\n  }\n  event.client = client;\n  client._eventBuilders.push([event, callback]);\n}\nexports.addEventHandler = addEventHandler;\n/** @hidden */\nfunction removeEventHandler(client, callback, event) {\n  client._eventBuilders = client._eventBuilders.filter(function (item) {\n    return item[0] !== event && item[1] !== callback;\n  });\n}\nexports.removeEventHandler = removeEventHandler;\n/** @hidden */\nfunction listEventHandlers(client) {\n  return client._eventBuilders;\n}\nexports.listEventHandlers = listEventHandlers;\n/** @hidden */\nfunction catchUp() {\n  // TODO\n}\nexports.catchUp = catchUp;\n/** @hidden */\nfunction _handleUpdate(client, update) {\n  if (typeof update === \"number\") {\n    if ([-1, 0, 1].includes(update)) {\n      _dispatchUpdate(client, {\n        update: new network_1.UpdateConnectionState(update)\n      });\n      return;\n    }\n  }\n  //this.session.processEntities(update)\n  client._entityCache.add(update);\n  client.session.processEntities(update);\n  if (update instanceof tl_1.Api.Updates || update instanceof tl_1.Api.UpdatesCombined) {\n    // TODO deal with entities\n    const entities = new Map();\n    for (const x of [...update.users, ...update.chats]) {\n      entities.set(index_1.utils.getPeerId(x), x);\n    }\n    for (const u of update.updates) {\n      _processUpdate(client, u, update.updates, entities);\n    }\n  } else if (update instanceof tl_1.Api.UpdateShort) {\n    _processUpdate(client, update.update, null);\n  } else {\n    _processUpdate(client, update, null);\n  }\n}\nexports._handleUpdate = _handleUpdate;\n/** @hidden */\nfunction _processUpdate(client, update, others, entities) {\n  update._entities = entities || new Map();\n  const args = {\n    update: update,\n    others: others\n  };\n  _dispatchUpdate(client, args);\n}\nexports._processUpdate = _processUpdate;\n/** @hidden */\nasync function _dispatchUpdate(client, args) {\n  for (const [builder, callback] of client._eventBuilders) {\n    if (!builder || !callback) {\n      continue;\n    }\n    if (!builder.resolved) {\n      await builder.resolve(client);\n    }\n    let event = args.update;\n    if (event) {\n      if (!client._selfInputPeer) {\n        try {\n          await client.getMe(true);\n        } catch (e) {\n          // do nothing\n        }\n      }\n      if (!(event instanceof network_1.UpdateConnectionState)) {\n        // TODO fix me\n      }\n      // TODO fix others not being passed\n      event = builder.build(event, callback, client._selfInputPeer ? (0, Helpers_1.returnBigInt)(client._selfInputPeer.userId) : undefined);\n      if (event) {\n        event._client = client;\n        if (\"_eventName\" in event) {\n          event._setClient(client);\n          event.originalUpdate = args.update;\n          event._entities = args.update._entities;\n        }\n        const filter = await builder.filter(event);\n        if (!filter) {\n          continue;\n        }\n        try {\n          await callback(event);\n        } catch (e) {\n          if (e instanceof StopPropagation) {\n            break;\n          }\n          if (client._log.canSend(Logger_1.LogLevel.ERROR)) {\n            console.error(e);\n          }\n        }\n      }\n    }\n  }\n}\nexports._dispatchUpdate = _dispatchUpdate;\n/** @hidden */\nasync function _updateLoop(client) {\n  let lastPongAt;\n  while (!client._destroyed) {\n    await (0, Helpers_1.sleep)(PING_INTERVAL, true);\n    if (client._destroyed) break;\n    if (client._sender.isReconnecting || client._isSwitchingDc) {\n      lastPongAt = undefined;\n      continue;\n    }\n    try {\n      const ping = () => {\n        return client._sender.send(new tl_1.Api.PingDelayDisconnect({\n          pingId: (0, Helpers_1.returnBigInt)((0, Helpers_1.getRandomInt)(Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)),\n          disconnectDelay: PING_DISCONNECT_DELAY\n        }));\n      };\n      const pingAt = Date.now();\n      const lastInterval = lastPongAt ? pingAt - lastPongAt : undefined;\n      if (!lastInterval || lastInterval < PING_INTERVAL_TO_WAKE_UP) {\n        await attempts(() => timeout(ping, PING_TIMEOUT), PING_FAIL_ATTEMPTS, PING_FAIL_INTERVAL);\n      } else {\n        let wakeUpWarningTimeout = setTimeout(() => {\n          _handleUpdate(client, network_1.UpdateConnectionState.disconnected);\n          wakeUpWarningTimeout = undefined;\n        }, PING_WAKE_UP_WARNING_TIMEOUT);\n        await timeout(ping, PING_WAKE_UP_TIMEOUT);\n        if (wakeUpWarningTimeout) {\n          clearTimeout(wakeUpWarningTimeout);\n          wakeUpWarningTimeout = undefined;\n        }\n        _handleUpdate(client, network_1.UpdateConnectionState.connected);\n      }\n      lastPongAt = Date.now();\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      if (client._log.canSend(Logger_1.LogLevel.ERROR)) {\n        console.error(err);\n      }\n      lastPongAt = undefined;\n      if (client._sender.isReconnecting || client._isSwitchingDc) {\n        continue;\n      }\n      client._sender.reconnect();\n    }\n    // We need to send some content-related request at least hourly\n    // for Telegram to keep delivering updates, otherwise they will\n    // just stop even if we're connected. Do so every 30 minutes.\n    if (Date.now() - (client._lastRequest || 0) > 30 * 60 * 1000) {\n      try {\n        await client.invoke(new tl_1.Api.updates.GetState());\n      } catch (e) {\n        // we don't care about errors here\n      }\n      lastPongAt = undefined;\n    }\n  }\n  await client.disconnect();\n}\nexports._updateLoop = _updateLoop;\n/** @hidden */\nasync function attempts(cb, times, pause) {\n  for (let i = 0; i < times; i++) {\n    try {\n      // We need to `return await` here so it can be caught locally\n      return await cb();\n    } catch (err) {\n      if (i === times - 1) {\n        throw err;\n      }\n      await (0, Helpers_1.sleep)(pause);\n    }\n  }\n  return undefined;\n}\n/** @hidden */\nfunction timeout(cb, ms) {\n  let isResolved = false;\n  return Promise.race([cb(), (0, Helpers_1.sleep)(ms).then(() => isResolved ? undefined : Promise.reject(new Error(\"TIMEOUT\")))]).finally(() => {\n    isResolved = true;\n  });\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_updateLoop","_dispatchUpdate","_processUpdate","_handleUpdate","catchUp","listEventHandlers","removeEventHandler","addEventHandler","on","StopPropagation","tl_1","require","network_1","index_1","Helpers_1","Logger_1","PING_INTERVAL","PING_TIMEOUT","PING_FAIL_ATTEMPTS","PING_FAIL_INTERVAL","PING_DISCONNECT_DELAY","PING_INTERVAL_TO_WAKE_UP","PING_WAKE_UP_TIMEOUT","PING_WAKE_UP_WARNING_TIMEOUT","Error","client","event","f","callback","undefined","raw","Raw","_eventBuilders","push","filter","item","update","includes","UpdateConnectionState","_entityCache","add","session","processEntities","Api","Updates","UpdatesCombined","entities","Map","x","users","chats","set","utils","getPeerId","u","updates","UpdateShort","others","_entities","args","builder","resolved","resolve","_selfInputPeer","getMe","e","build","returnBigInt","userId","_client","_setClient","originalUpdate","_log","canSend","LogLevel","ERROR","console","error","lastPongAt","_destroyed","sleep","_sender","isReconnecting","_isSwitchingDc","ping","send","PingDelayDisconnect","pingId","getRandomInt","Number","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","disconnectDelay","pingAt","Date","now","lastInterval","attempts","timeout","wakeUpWarningTimeout","setTimeout","disconnected","clearTimeout","connected","err","reconnect","_lastRequest","invoke","GetState","disconnect","cb","times","pause","i","ms","isResolved","Promise","race","then","reject","finally"],"sources":["C:/Users/Muhammed/Desktop/REACT_JS/dene-gramjs/node_modules/telegram/client/updates.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports._updateLoop = exports._dispatchUpdate = exports._processUpdate = exports._handleUpdate = exports.catchUp = exports.listEventHandlers = exports.removeEventHandler = exports.addEventHandler = exports.on = exports.StopPropagation = void 0;\r\nconst tl_1 = require(\"../tl\");\r\nconst network_1 = require(\"../network\");\r\nconst index_1 = require(\"../index\");\r\nconst Helpers_1 = require(\"../Helpers\");\r\nconst Logger_1 = require(\"../extensions/Logger\");\r\nconst PING_INTERVAL = 9000; // 9 sec\r\nconst PING_TIMEOUT = 10000; // 10 sec\r\nconst PING_FAIL_ATTEMPTS = 3;\r\nconst PING_FAIL_INTERVAL = 100; // ms\r\nconst PING_DISCONNECT_DELAY = 60000; // 1 min\r\n// An unusually long interval is a sign of returning from background mode...\r\nconst PING_INTERVAL_TO_WAKE_UP = 5000; // 5 sec\r\n// ... so we send a quick \"wake-up\" ping to confirm than connection was dropped ASAP\r\nconst PING_WAKE_UP_TIMEOUT = 3000; // 3 sec\r\n// We also send a warning to the user even a bit more quickly\r\nconst PING_WAKE_UP_WARNING_TIMEOUT = 1000; // 1 sec\r\n/**\r\n If this exception is raised in any of the handlers for a given event,\r\n it will stop the execution of all other registered event handlers.\r\n It can be seen as the ``StopIteration`` in a for loop but for events.\r\n */\r\nclass StopPropagation extends Error {\r\n}\r\nexports.StopPropagation = StopPropagation;\r\n/** @hidden */\r\nfunction on(client, event) {\r\n    return (f) => {\r\n        client.addEventHandler(f, event);\r\n        return f;\r\n    };\r\n}\r\nexports.on = on;\r\n/** @hidden */\r\nfunction addEventHandler(client, callback, event) {\r\n    if (event == undefined) {\r\n        // recursive imports :(\r\n        const raw = require(\"../events/Raw\").Raw;\r\n        event = new raw({});\r\n    }\r\n    event.client = client;\r\n    client._eventBuilders.push([event, callback]);\r\n}\r\nexports.addEventHandler = addEventHandler;\r\n/** @hidden */\r\nfunction removeEventHandler(client, callback, event) {\r\n    client._eventBuilders = client._eventBuilders.filter(function (item) {\r\n        return item[0] !== event && item[1] !== callback;\r\n    });\r\n}\r\nexports.removeEventHandler = removeEventHandler;\r\n/** @hidden */\r\nfunction listEventHandlers(client) {\r\n    return client._eventBuilders;\r\n}\r\nexports.listEventHandlers = listEventHandlers;\r\n/** @hidden */\r\nfunction catchUp() {\r\n    // TODO\r\n}\r\nexports.catchUp = catchUp;\r\n/** @hidden */\r\nfunction _handleUpdate(client, update) {\r\n    if (typeof update === \"number\") {\r\n        if ([-1, 0, 1].includes(update)) {\r\n            _dispatchUpdate(client, {\r\n                update: new network_1.UpdateConnectionState(update),\r\n            });\r\n            return;\r\n        }\r\n    }\r\n    //this.session.processEntities(update)\r\n    client._entityCache.add(update);\r\n    client.session.processEntities(update);\r\n    if (update instanceof tl_1.Api.Updates ||\r\n        update instanceof tl_1.Api.UpdatesCombined) {\r\n        // TODO deal with entities\r\n        const entities = new Map();\r\n        for (const x of [...update.users, ...update.chats]) {\r\n            entities.set(index_1.utils.getPeerId(x), x);\r\n        }\r\n        for (const u of update.updates) {\r\n            _processUpdate(client, u, update.updates, entities);\r\n        }\r\n    }\r\n    else if (update instanceof tl_1.Api.UpdateShort) {\r\n        _processUpdate(client, update.update, null);\r\n    }\r\n    else {\r\n        _processUpdate(client, update, null);\r\n    }\r\n}\r\nexports._handleUpdate = _handleUpdate;\r\n/** @hidden */\r\nfunction _processUpdate(client, update, others, entities) {\r\n    update._entities = entities || new Map();\r\n    const args = {\r\n        update: update,\r\n        others: others,\r\n    };\r\n    _dispatchUpdate(client, args);\r\n}\r\nexports._processUpdate = _processUpdate;\r\n/** @hidden */\r\nasync function _dispatchUpdate(client, args) {\r\n    for (const [builder, callback] of client._eventBuilders) {\r\n        if (!builder || !callback) {\r\n            continue;\r\n        }\r\n        if (!builder.resolved) {\r\n            await builder.resolve(client);\r\n        }\r\n        let event = args.update;\r\n        if (event) {\r\n            if (!client._selfInputPeer) {\r\n                try {\r\n                    await client.getMe(true);\r\n                }\r\n                catch (e) {\r\n                    // do nothing\r\n                }\r\n            }\r\n            if (!(event instanceof network_1.UpdateConnectionState)) {\r\n                // TODO fix me\r\n            }\r\n            // TODO fix others not being passed\r\n            event = builder.build(event, callback, client._selfInputPeer\r\n                ? (0, Helpers_1.returnBigInt)(client._selfInputPeer.userId)\r\n                : undefined);\r\n            if (event) {\r\n                event._client = client;\r\n                if (\"_eventName\" in event) {\r\n                    event._setClient(client);\r\n                    event.originalUpdate = args.update;\r\n                    event._entities = args.update._entities;\r\n                }\r\n                const filter = await builder.filter(event);\r\n                if (!filter) {\r\n                    continue;\r\n                }\r\n                try {\r\n                    await callback(event);\r\n                }\r\n                catch (e) {\r\n                    if (e instanceof StopPropagation) {\r\n                        break;\r\n                    }\r\n                    if (client._log.canSend(Logger_1.LogLevel.ERROR)) {\r\n                        console.error(e);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nexports._dispatchUpdate = _dispatchUpdate;\r\n/** @hidden */\r\nasync function _updateLoop(client) {\r\n    let lastPongAt;\r\n    while (!client._destroyed) {\r\n        await (0, Helpers_1.sleep)(PING_INTERVAL, true);\r\n        if (client._destroyed)\r\n            break;\r\n        if (client._sender.isReconnecting || client._isSwitchingDc) {\r\n            lastPongAt = undefined;\r\n            continue;\r\n        }\r\n        try {\r\n            const ping = () => {\r\n                return client._sender.send(new tl_1.Api.PingDelayDisconnect({\r\n                    pingId: (0, Helpers_1.returnBigInt)((0, Helpers_1.getRandomInt)(Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)),\r\n                    disconnectDelay: PING_DISCONNECT_DELAY,\r\n                }));\r\n            };\r\n            const pingAt = Date.now();\r\n            const lastInterval = lastPongAt ? pingAt - lastPongAt : undefined;\r\n            if (!lastInterval || lastInterval < PING_INTERVAL_TO_WAKE_UP) {\r\n                await attempts(() => timeout(ping, PING_TIMEOUT), PING_FAIL_ATTEMPTS, PING_FAIL_INTERVAL);\r\n            }\r\n            else {\r\n                let wakeUpWarningTimeout = setTimeout(() => {\r\n                    _handleUpdate(client, network_1.UpdateConnectionState.disconnected);\r\n                    wakeUpWarningTimeout = undefined;\r\n                }, PING_WAKE_UP_WARNING_TIMEOUT);\r\n                await timeout(ping, PING_WAKE_UP_TIMEOUT);\r\n                if (wakeUpWarningTimeout) {\r\n                    clearTimeout(wakeUpWarningTimeout);\r\n                    wakeUpWarningTimeout = undefined;\r\n                }\r\n                _handleUpdate(client, network_1.UpdateConnectionState.connected);\r\n            }\r\n            lastPongAt = Date.now();\r\n        }\r\n        catch (err) {\r\n            // eslint-disable-next-line no-console\r\n            if (client._log.canSend(Logger_1.LogLevel.ERROR)) {\r\n                console.error(err);\r\n            }\r\n            lastPongAt = undefined;\r\n            if (client._sender.isReconnecting || client._isSwitchingDc) {\r\n                continue;\r\n            }\r\n            client._sender.reconnect();\r\n        }\r\n        // We need to send some content-related request at least hourly\r\n        // for Telegram to keep delivering updates, otherwise they will\r\n        // just stop even if we're connected. Do so every 30 minutes.\r\n        if (Date.now() - (client._lastRequest || 0) > 30 * 60 * 1000) {\r\n            try {\r\n                await client.invoke(new tl_1.Api.updates.GetState());\r\n            }\r\n            catch (e) {\r\n                // we don't care about errors here\r\n            }\r\n            lastPongAt = undefined;\r\n        }\r\n    }\r\n    await client.disconnect();\r\n}\r\nexports._updateLoop = _updateLoop;\r\n/** @hidden */\r\nasync function attempts(cb, times, pause) {\r\n    for (let i = 0; i < times; i++) {\r\n        try {\r\n            // We need to `return await` here so it can be caught locally\r\n            return await cb();\r\n        }\r\n        catch (err) {\r\n            if (i === times - 1) {\r\n                throw err;\r\n            }\r\n            await (0, Helpers_1.sleep)(pause);\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n/** @hidden */\r\nfunction timeout(cb, ms) {\r\n    let isResolved = false;\r\n    return Promise.race([\r\n        cb(),\r\n        (0, Helpers_1.sleep)(ms).then(() => isResolved ? undefined : Promise.reject(new Error(\"TIMEOUT\"))),\r\n    ]).finally(() => {\r\n        isResolved = true;\r\n    });\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}