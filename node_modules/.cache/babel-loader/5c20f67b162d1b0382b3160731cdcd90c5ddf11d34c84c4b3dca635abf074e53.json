{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TelegramBaseClient = void 0;\nconst __1 = require(\"../\");\nconst Helpers_1 = require(\"../Helpers\");\nconst connection_1 = require(\"../network/connection\");\nconst sessions_1 = require(\"../sessions\");\nconst extensions_1 = require(\"../extensions\");\nconst tl_1 = require(\"../tl\");\nconst os_1 = __importDefault(require(\"./os\"));\nconst entityCache_1 = require(\"../entityCache\");\nconst markdown_1 = require(\"../extensions/markdown\");\nconst network_1 = require(\"../network\");\nconst AllTLObjects_1 = require(\"../tl/AllTLObjects\");\nconst TCPMTProxy_1 = require(\"../network/connection/TCPMTProxy\");\nconst async_mutex_1 = require(\"async-mutex\");\nconst Logger_1 = require(\"../extensions/Logger\");\nconst platform_1 = require(\"../platform\");\nconst Deferred_1 = __importDefault(require(\"../extensions/Deferred\"));\nconst EXPORTED_SENDER_RECONNECT_TIMEOUT = 1000; // 1 sec\nconst EXPORTED_SENDER_RELEASE_TIMEOUT = 30000; // 30 sec\nconst DEFAULT_DC_ID = 4;\nconst DEFAULT_IPV4_IP = platform_1.isNode ? \"149.154.167.91\" : \"vesta.web.telegram.org\";\nconst DEFAULT_IPV6_IP = \"2001:067c:04e8:f004:0000:0000:0000:000a\";\nconst clientParamsDefault = {\n  connection: platform_1.isNode ? connection_1.ConnectionTCPFull : connection_1.ConnectionTCPObfuscated,\n  networkSocket: platform_1.isNode ? extensions_1.PromisedNetSockets : extensions_1.PromisedWebSockets,\n  useIPV6: false,\n  timeout: 10,\n  requestRetries: 5,\n  connectionRetries: Infinity,\n  retryDelay: 1000,\n  downloadRetries: 5,\n  autoReconnect: true,\n  sequentialUpdates: false,\n  floodSleepThreshold: 60,\n  deviceModel: \"\",\n  systemVersion: \"\",\n  appVersion: \"\",\n  langCode: \"en\",\n  systemLangCode: \"en\",\n  _securityChecks: true,\n  useWSS: platform_1.isBrowser ? window.location.protocol == \"https:\" : false,\n  testServers: false\n};\nclass TelegramBaseClient {\n  constructor(session, apiId, apiHash, clientParams) {\n    var _a;\n    /** The current gramJS version. */\n    this.__version__ = __1.version;\n    /** @hidden */\n    this._ALBUMS = new Map();\n    /** @hidden */\n    this._exportedSenderPromises = new Map();\n    /** @hidden */\n    this._exportedSenderReleaseTimeouts = new Map();\n    clientParams = Object.assign(Object.assign({}, clientParamsDefault), clientParams);\n    if (!apiId || !apiHash) {\n      throw new Error(\"Your API ID or Hash cannot be empty or undefined\");\n    }\n    if (clientParams.baseLogger) {\n      this._log = clientParams.baseLogger;\n    } else {\n      this._log = new extensions_1.Logger();\n    }\n    this._log.info(\"Running gramJS version \" + __1.version);\n    if (session && typeof session == \"string\") {\n      session = new sessions_1.StoreSession(session);\n    }\n    if (!(session instanceof sessions_1.Session)) {\n      throw new Error(\"Only StringSession and StoreSessions are supported currently :( \");\n    }\n    this._floodSleepThreshold = clientParams.floodSleepThreshold;\n    this.session = session;\n    this.apiId = apiId;\n    this.apiHash = apiHash;\n    this._useIPV6 = clientParams.useIPV6;\n    this._requestRetries = clientParams.requestRetries;\n    this._downloadRetries = clientParams.downloadRetries;\n    this._connectionRetries = clientParams.connectionRetries;\n    this._retryDelay = clientParams.retryDelay || 0;\n    this._timeout = clientParams.timeout;\n    this._autoReconnect = clientParams.autoReconnect;\n    this._proxy = clientParams.proxy;\n    this._semaphore = new async_mutex_1.Semaphore(clientParams.maxConcurrentDownloads || 1);\n    this.testServers = clientParams.testServers || false;\n    this.networkSocket = clientParams.networkSocket || extensions_1.PromisedNetSockets;\n    if (!(clientParams.connection instanceof Function)) {\n      throw new Error(\"Connection should be a class not an instance\");\n    }\n    this._connection = clientParams.connection;\n    let initProxy;\n    if ((_a = this._proxy) === null || _a === void 0 ? void 0 : _a.MTProxy) {\n      this._connection = TCPMTProxy_1.ConnectionTCPMTProxyAbridged;\n      initProxy = new tl_1.Api.InputClientProxy({\n        address: this._proxy.ip,\n        port: this._proxy.port\n      });\n    }\n    this._initRequest = new tl_1.Api.InitConnection({\n      apiId: this.apiId,\n      deviceModel: clientParams.deviceModel || os_1.default.type().toString() || \"Unknown\",\n      systemVersion: clientParams.systemVersion || os_1.default.release().toString() || \"1.0\",\n      appVersion: clientParams.appVersion || \"1.0\",\n      langCode: clientParams.langCode,\n      langPack: \"\",\n      systemLangCode: clientParams.systemLangCode,\n      proxy: initProxy\n    });\n    this._eventBuilders = [];\n    this._floodWaitedRequests = {};\n    this._borrowedSenderPromises = {};\n    this._bot = undefined;\n    this._selfInputPeer = undefined;\n    this.useWSS = clientParams.useWSS;\n    this._securityChecks = !!clientParams.securityChecks;\n    if (this.useWSS && this._proxy) {\n      throw new Error(\"Cannot use SSL with proxies. You need to disable the useWSS client param in TelegramClient\");\n    }\n    this._entityCache = new entityCache_1.EntityCache();\n    // These will be set later\n    this._config = undefined;\n    this._loopStarted = false;\n    this._reconnecting = false;\n    this._destroyed = false;\n    this._isSwitchingDc = false;\n    this._connectedDeferred = new Deferred_1.default();\n    // parse mode\n    this._parseMode = markdown_1.MarkdownParser;\n  }\n  get floodSleepThreshold() {\n    return this._floodSleepThreshold;\n  }\n  set floodSleepThreshold(value) {\n    this._floodSleepThreshold = Math.min(value || 0, 24 * 60 * 60);\n  }\n  set maxConcurrentDownloads(value) {\n    // @ts-ignore\n    this._semaphore._value = value;\n  }\n  // region connecting\n  async _initSession() {\n    await this.session.load();\n    if (!this.session.serverAddress) {\n      this.session.setDC(DEFAULT_DC_ID, this._useIPV6 ? DEFAULT_IPV6_IP : DEFAULT_IPV4_IP, this.useWSS ? 443 : 80);\n    } else {\n      this._useIPV6 = this.session.serverAddress.includes(\":\");\n    }\n  }\n  get connected() {\n    return this._sender && this._sender.isConnected();\n  }\n  async disconnect() {\n    await this._disconnect();\n    await Promise.all(Object.values(this._exportedSenderPromises).map(promises => {\n      return Object.values(promises).map(promise => {\n        return promise && promise.then(sender => {\n          if (sender) {\n            return sender.disconnect();\n          }\n          return undefined;\n        });\n      });\n    }).flat());\n    Object.values(this._exportedSenderReleaseTimeouts).forEach(timeouts => {\n      Object.values(timeouts).forEach(releaseTimeout => {\n        clearTimeout(releaseTimeout);\n      });\n    });\n    this._exportedSenderPromises.clear();\n  }\n  get disconnected() {\n    return !this._sender || this._sender._disconnected;\n  }\n  async _disconnect() {\n    var _a;\n    await ((_a = this._sender) === null || _a === void 0 ? void 0 : _a.disconnect());\n  }\n  /**\r\n   * Disconnects all senders and removes all handlers\r\n   * Disconnect is safer as it will not remove your event handlers\r\n   */\n  async destroy() {\n    this._destroyed = true;\n    await Promise.all([this.disconnect(), ...Object.values(this._borrowedSenderPromises).map(promise => {\n      return promise.then(sender => sender.disconnect());\n    })]);\n    this._eventBuilders = [];\n  }\n  /** @hidden */\n  async _authKeyCallback(authKey, dcId) {\n    this.session.setAuthKey(authKey, dcId);\n    await this.session.save();\n  }\n  /** @hidden */\n  async _cleanupExportedSender(dcId) {\n    if (this.session.dcId !== dcId) {\n      this.session.setAuthKey(undefined, dcId);\n    }\n    let sender = await this._exportedSenderPromises.get(dcId);\n    this._exportedSenderPromises.delete(dcId);\n    await (sender === null || sender === void 0 ? void 0 : sender.disconnect());\n  }\n  /** @hidden */\n  async _connectSender(sender, dcId) {\n    // if we don't already have an auth key we want to use normal DCs not -1\n    const dc = await this.getDC(dcId, !!sender.authKey.getKey());\n    while (true) {\n      try {\n        await sender.connect(new this._connection({\n          ip: dc.ipAddress,\n          port: dc.port,\n          dcId: dcId,\n          loggers: this._log,\n          proxy: this._proxy,\n          testServers: this.testServers,\n          socket: this.networkSocket\n        }), false);\n        if (this.session.dcId !== dcId && !sender._authenticated) {\n          this._log.info(`Exporting authorization for data center ${dc.ipAddress} with layer ${AllTLObjects_1.LAYER}`);\n          const auth = await this.invoke(new tl_1.Api.auth.ExportAuthorization({\n            dcId: dcId\n          }));\n          this._initRequest.query = new tl_1.Api.auth.ImportAuthorization({\n            id: auth.id,\n            bytes: auth.bytes\n          });\n          const req = new tl_1.Api.InvokeWithLayer({\n            layer: AllTLObjects_1.LAYER,\n            query: this._initRequest\n          });\n          await sender.send(req);\n          sender._authenticated = true;\n        }\n        sender.dcId = dcId;\n        sender.userDisconnected = false;\n        return sender;\n      } catch (err) {\n        if (err.errorMessage === \"DC_ID_INVALID\") {\n          sender._authenticated = true;\n          sender.userDisconnected = false;\n          return sender;\n        }\n        if (this._log.canSend(Logger_1.LogLevel.ERROR)) {\n          console.error(err);\n        }\n        await (0, Helpers_1.sleep)(1000);\n        await sender.disconnect();\n      }\n    }\n  }\n  /** @hidden */\n  async _borrowExportedSender(dcId, shouldReconnect, existingSender) {\n    if (!this._exportedSenderPromises.get(dcId) || shouldReconnect) {\n      this._exportedSenderPromises.set(dcId, this._connectSender(existingSender || this._createExportedSender(dcId), dcId));\n    }\n    let sender;\n    try {\n      sender = await this._exportedSenderPromises.get(dcId);\n      if (!sender.isConnected()) {\n        if (sender.isConnecting) {\n          await (0, Helpers_1.sleep)(EXPORTED_SENDER_RECONNECT_TIMEOUT);\n          return this._borrowExportedSender(dcId, false, sender);\n        } else {\n          return this._borrowExportedSender(dcId, true, sender);\n        }\n      }\n    } catch (err) {\n      if (this._log.canSend(Logger_1.LogLevel.ERROR)) {\n        console.error(err);\n      }\n      return this._borrowExportedSender(dcId, true);\n    }\n    if (this._exportedSenderReleaseTimeouts.get(dcId)) {\n      clearTimeout(this._exportedSenderReleaseTimeouts.get(dcId));\n      this._exportedSenderReleaseTimeouts.delete(dcId);\n    }\n    this._exportedSenderReleaseTimeouts.set(dcId, setTimeout(() => {\n      this._exportedSenderReleaseTimeouts.delete(dcId);\n      sender.disconnect();\n    }, EXPORTED_SENDER_RELEASE_TIMEOUT));\n    return sender;\n  }\n  /** @hidden */\n  _createExportedSender(dcId) {\n    return new network_1.MTProtoSender(this.session.getAuthKey(dcId), {\n      logger: this._log,\n      dcId,\n      retries: this._connectionRetries,\n      delay: this._retryDelay,\n      autoReconnect: this._autoReconnect,\n      connectTimeout: this._timeout,\n      authKeyCallback: this._authKeyCallback.bind(this),\n      isMainSender: dcId === this.session.dcId,\n      onConnectionBreak: this._cleanupExportedSender.bind(this),\n      client: this,\n      securityChecks: this._securityChecks\n    });\n  }\n  /** @hidden */\n  getSender(dcId) {\n    return dcId ? this._borrowExportedSender(dcId) : Promise.resolve(this._sender);\n  }\n  // endregion\n  async getDC(dcId, download) {\n    throw new Error(\"Cannot be called from here!\");\n  }\n  invoke(request) {\n    throw new Error(\"Cannot be called from here!\");\n  }\n  setLogLevel(level) {\n    this._log.setLevel(level);\n  }\n  get logger() {\n    return this._log;\n  }\n}\nexports.TelegramBaseClient = TelegramBaseClient;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","TelegramBaseClient","__1","require","Helpers_1","connection_1","sessions_1","extensions_1","tl_1","os_1","entityCache_1","markdown_1","network_1","AllTLObjects_1","TCPMTProxy_1","async_mutex_1","Logger_1","platform_1","Deferred_1","EXPORTED_SENDER_RECONNECT_TIMEOUT","EXPORTED_SENDER_RELEASE_TIMEOUT","DEFAULT_DC_ID","DEFAULT_IPV4_IP","isNode","DEFAULT_IPV6_IP","clientParamsDefault","connection","ConnectionTCPFull","ConnectionTCPObfuscated","networkSocket","PromisedNetSockets","PromisedWebSockets","useIPV6","timeout","requestRetries","connectionRetries","Infinity","retryDelay","downloadRetries","autoReconnect","sequentialUpdates","floodSleepThreshold","deviceModel","systemVersion","appVersion","langCode","systemLangCode","_securityChecks","useWSS","isBrowser","window","location","protocol","testServers","constructor","session","apiId","apiHash","clientParams","_a","__version__","version","_ALBUMS","Map","_exportedSenderPromises","_exportedSenderReleaseTimeouts","assign","Error","baseLogger","_log","Logger","info","StoreSession","Session","_floodSleepThreshold","_useIPV6","_requestRetries","_downloadRetries","_connectionRetries","_retryDelay","_timeout","_autoReconnect","_proxy","proxy","_semaphore","Semaphore","maxConcurrentDownloads","Function","_connection","initProxy","MTProxy","ConnectionTCPMTProxyAbridged","Api","InputClientProxy","address","ip","port","_initRequest","InitConnection","default","type","toString","release","langPack","_eventBuilders","_floodWaitedRequests","_borrowedSenderPromises","_bot","undefined","_selfInputPeer","securityChecks","_entityCache","EntityCache","_config","_loopStarted","_reconnecting","_destroyed","_isSwitchingDc","_connectedDeferred","_parseMode","MarkdownParser","Math","min","_value","_initSession","load","serverAddress","setDC","includes","connected","_sender","isConnected","disconnect","_disconnect","Promise","all","values","map","promises","promise","then","sender","flat","forEach","timeouts","releaseTimeout","clearTimeout","clear","disconnected","_disconnected","destroy","_authKeyCallback","authKey","dcId","setAuthKey","save","_cleanupExportedSender","get","delete","_connectSender","dc","getDC","getKey","connect","ipAddress","loggers","socket","_authenticated","LAYER","auth","invoke","ExportAuthorization","query","ImportAuthorization","id","bytes","req","InvokeWithLayer","layer","send","userDisconnected","err","errorMessage","canSend","LogLevel","ERROR","console","error","sleep","_borrowExportedSender","shouldReconnect","existingSender","set","_createExportedSender","isConnecting","setTimeout","MTProtoSender","getAuthKey","logger","retries","delay","connectTimeout","authKeyCallback","bind","isMainSender","onConnectionBreak","client","getSender","resolve","download","request","setLogLevel","level","setLevel"],"sources":["C:/Users/Muhammed/Desktop/REACT_JS/dene-gramjs/node_modules/telegram/client/telegramBaseClient.js"],"sourcesContent":["\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TelegramBaseClient = void 0;\r\nconst __1 = require(\"../\");\r\nconst Helpers_1 = require(\"../Helpers\");\r\nconst connection_1 = require(\"../network/connection\");\r\nconst sessions_1 = require(\"../sessions\");\r\nconst extensions_1 = require(\"../extensions\");\r\nconst tl_1 = require(\"../tl\");\r\nconst os_1 = __importDefault(require(\"./os\"));\r\nconst entityCache_1 = require(\"../entityCache\");\r\nconst markdown_1 = require(\"../extensions/markdown\");\r\nconst network_1 = require(\"../network\");\r\nconst AllTLObjects_1 = require(\"../tl/AllTLObjects\");\r\nconst TCPMTProxy_1 = require(\"../network/connection/TCPMTProxy\");\r\nconst async_mutex_1 = require(\"async-mutex\");\r\nconst Logger_1 = require(\"../extensions/Logger\");\r\nconst platform_1 = require(\"../platform\");\r\nconst Deferred_1 = __importDefault(require(\"../extensions/Deferred\"));\r\nconst EXPORTED_SENDER_RECONNECT_TIMEOUT = 1000; // 1 sec\r\nconst EXPORTED_SENDER_RELEASE_TIMEOUT = 30000; // 30 sec\r\nconst DEFAULT_DC_ID = 4;\r\nconst DEFAULT_IPV4_IP = platform_1.isNode ? \"149.154.167.91\" : \"vesta.web.telegram.org\";\r\nconst DEFAULT_IPV6_IP = \"2001:067c:04e8:f004:0000:0000:0000:000a\";\r\nconst clientParamsDefault = {\r\n    connection: platform_1.isNode ? connection_1.ConnectionTCPFull : connection_1.ConnectionTCPObfuscated,\r\n    networkSocket: platform_1.isNode ? extensions_1.PromisedNetSockets : extensions_1.PromisedWebSockets,\r\n    useIPV6: false,\r\n    timeout: 10,\r\n    requestRetries: 5,\r\n    connectionRetries: Infinity,\r\n    retryDelay: 1000,\r\n    downloadRetries: 5,\r\n    autoReconnect: true,\r\n    sequentialUpdates: false,\r\n    floodSleepThreshold: 60,\r\n    deviceModel: \"\",\r\n    systemVersion: \"\",\r\n    appVersion: \"\",\r\n    langCode: \"en\",\r\n    systemLangCode: \"en\",\r\n    _securityChecks: true,\r\n    useWSS: platform_1.isBrowser ? window.location.protocol == \"https:\" : false,\r\n    testServers: false,\r\n};\r\nclass TelegramBaseClient {\r\n    constructor(session, apiId, apiHash, clientParams) {\r\n        var _a;\r\n        /** The current gramJS version. */\r\n        this.__version__ = __1.version;\r\n        /** @hidden */\r\n        this._ALBUMS = new Map();\r\n        /** @hidden */\r\n        this._exportedSenderPromises = new Map();\r\n        /** @hidden */\r\n        this._exportedSenderReleaseTimeouts = new Map();\r\n        clientParams = Object.assign(Object.assign({}, clientParamsDefault), clientParams);\r\n        if (!apiId || !apiHash) {\r\n            throw new Error(\"Your API ID or Hash cannot be empty or undefined\");\r\n        }\r\n        if (clientParams.baseLogger) {\r\n            this._log = clientParams.baseLogger;\r\n        }\r\n        else {\r\n            this._log = new extensions_1.Logger();\r\n        }\r\n        this._log.info(\"Running gramJS version \" + __1.version);\r\n        if (session && typeof session == \"string\") {\r\n            session = new sessions_1.StoreSession(session);\r\n        }\r\n        if (!(session instanceof sessions_1.Session)) {\r\n            throw new Error(\"Only StringSession and StoreSessions are supported currently :( \");\r\n        }\r\n        this._floodSleepThreshold = clientParams.floodSleepThreshold;\r\n        this.session = session;\r\n        this.apiId = apiId;\r\n        this.apiHash = apiHash;\r\n        this._useIPV6 = clientParams.useIPV6;\r\n        this._requestRetries = clientParams.requestRetries;\r\n        this._downloadRetries = clientParams.downloadRetries;\r\n        this._connectionRetries = clientParams.connectionRetries;\r\n        this._retryDelay = clientParams.retryDelay || 0;\r\n        this._timeout = clientParams.timeout;\r\n        this._autoReconnect = clientParams.autoReconnect;\r\n        this._proxy = clientParams.proxy;\r\n        this._semaphore = new async_mutex_1.Semaphore(clientParams.maxConcurrentDownloads || 1);\r\n        this.testServers = clientParams.testServers || false;\r\n        this.networkSocket = clientParams.networkSocket || extensions_1.PromisedNetSockets;\r\n        if (!(clientParams.connection instanceof Function)) {\r\n            throw new Error(\"Connection should be a class not an instance\");\r\n        }\r\n        this._connection = clientParams.connection;\r\n        let initProxy;\r\n        if ((_a = this._proxy) === null || _a === void 0 ? void 0 : _a.MTProxy) {\r\n            this._connection = TCPMTProxy_1.ConnectionTCPMTProxyAbridged;\r\n            initProxy = new tl_1.Api.InputClientProxy({\r\n                address: this._proxy.ip,\r\n                port: this._proxy.port,\r\n            });\r\n        }\r\n        this._initRequest = new tl_1.Api.InitConnection({\r\n            apiId: this.apiId,\r\n            deviceModel: clientParams.deviceModel || os_1.default.type().toString() || \"Unknown\",\r\n            systemVersion: clientParams.systemVersion || os_1.default.release().toString() || \"1.0\",\r\n            appVersion: clientParams.appVersion || \"1.0\",\r\n            langCode: clientParams.langCode,\r\n            langPack: \"\",\r\n            systemLangCode: clientParams.systemLangCode,\r\n            proxy: initProxy,\r\n        });\r\n        this._eventBuilders = [];\r\n        this._floodWaitedRequests = {};\r\n        this._borrowedSenderPromises = {};\r\n        this._bot = undefined;\r\n        this._selfInputPeer = undefined;\r\n        this.useWSS = clientParams.useWSS;\r\n        this._securityChecks = !!clientParams.securityChecks;\r\n        if (this.useWSS && this._proxy) {\r\n            throw new Error(\"Cannot use SSL with proxies. You need to disable the useWSS client param in TelegramClient\");\r\n        }\r\n        this._entityCache = new entityCache_1.EntityCache();\r\n        // These will be set later\r\n        this._config = undefined;\r\n        this._loopStarted = false;\r\n        this._reconnecting = false;\r\n        this._destroyed = false;\r\n        this._isSwitchingDc = false;\r\n        this._connectedDeferred = new Deferred_1.default();\r\n        // parse mode\r\n        this._parseMode = markdown_1.MarkdownParser;\r\n    }\r\n    get floodSleepThreshold() {\r\n        return this._floodSleepThreshold;\r\n    }\r\n    set floodSleepThreshold(value) {\r\n        this._floodSleepThreshold = Math.min(value || 0, 24 * 60 * 60);\r\n    }\r\n    set maxConcurrentDownloads(value) {\r\n        // @ts-ignore\r\n        this._semaphore._value = value;\r\n    }\r\n    // region connecting\r\n    async _initSession() {\r\n        await this.session.load();\r\n        if (!this.session.serverAddress) {\r\n            this.session.setDC(DEFAULT_DC_ID, this._useIPV6 ? DEFAULT_IPV6_IP : DEFAULT_IPV4_IP, this.useWSS ? 443 : 80);\r\n        }\r\n        else {\r\n            this._useIPV6 = this.session.serverAddress.includes(\":\");\r\n        }\r\n    }\r\n    get connected() {\r\n        return this._sender && this._sender.isConnected();\r\n    }\r\n    async disconnect() {\r\n        await this._disconnect();\r\n        await Promise.all(Object.values(this._exportedSenderPromises)\r\n            .map((promises) => {\r\n            return Object.values(promises).map((promise) => {\r\n                return (promise &&\r\n                    promise.then((sender) => {\r\n                        if (sender) {\r\n                            return sender.disconnect();\r\n                        }\r\n                        return undefined;\r\n                    }));\r\n            });\r\n        })\r\n            .flat());\r\n        Object.values(this._exportedSenderReleaseTimeouts).forEach((timeouts) => {\r\n            Object.values(timeouts).forEach((releaseTimeout) => {\r\n                clearTimeout(releaseTimeout);\r\n            });\r\n        });\r\n        this._exportedSenderPromises.clear();\r\n    }\r\n    get disconnected() {\r\n        return !this._sender || this._sender._disconnected;\r\n    }\r\n    async _disconnect() {\r\n        var _a;\r\n        await ((_a = this._sender) === null || _a === void 0 ? void 0 : _a.disconnect());\r\n    }\r\n    /**\r\n     * Disconnects all senders and removes all handlers\r\n     * Disconnect is safer as it will not remove your event handlers\r\n     */\r\n    async destroy() {\r\n        this._destroyed = true;\r\n        await Promise.all([\r\n            this.disconnect(),\r\n            ...Object.values(this._borrowedSenderPromises).map((promise) => {\r\n                return promise.then((sender) => sender.disconnect());\r\n            }),\r\n        ]);\r\n        this._eventBuilders = [];\r\n    }\r\n    /** @hidden */\r\n    async _authKeyCallback(authKey, dcId) {\r\n        this.session.setAuthKey(authKey, dcId);\r\n        await this.session.save();\r\n    }\r\n    /** @hidden */\r\n    async _cleanupExportedSender(dcId) {\r\n        if (this.session.dcId !== dcId) {\r\n            this.session.setAuthKey(undefined, dcId);\r\n        }\r\n        let sender = await this._exportedSenderPromises.get(dcId);\r\n        this._exportedSenderPromises.delete(dcId);\r\n        await (sender === null || sender === void 0 ? void 0 : sender.disconnect());\r\n    }\r\n    /** @hidden */\r\n    async _connectSender(sender, dcId) {\r\n        // if we don't already have an auth key we want to use normal DCs not -1\r\n        const dc = await this.getDC(dcId, !!sender.authKey.getKey());\r\n        while (true) {\r\n            try {\r\n                await sender.connect(new this._connection({\r\n                    ip: dc.ipAddress,\r\n                    port: dc.port,\r\n                    dcId: dcId,\r\n                    loggers: this._log,\r\n                    proxy: this._proxy,\r\n                    testServers: this.testServers,\r\n                    socket: this.networkSocket,\r\n                }), false);\r\n                if (this.session.dcId !== dcId && !sender._authenticated) {\r\n                    this._log.info(`Exporting authorization for data center ${dc.ipAddress} with layer ${AllTLObjects_1.LAYER}`);\r\n                    const auth = await this.invoke(new tl_1.Api.auth.ExportAuthorization({ dcId: dcId }));\r\n                    this._initRequest.query = new tl_1.Api.auth.ImportAuthorization({\r\n                        id: auth.id,\r\n                        bytes: auth.bytes,\r\n                    });\r\n                    const req = new tl_1.Api.InvokeWithLayer({\r\n                        layer: AllTLObjects_1.LAYER,\r\n                        query: this._initRequest,\r\n                    });\r\n                    await sender.send(req);\r\n                    sender._authenticated = true;\r\n                }\r\n                sender.dcId = dcId;\r\n                sender.userDisconnected = false;\r\n                return sender;\r\n            }\r\n            catch (err) {\r\n                if (err.errorMessage === \"DC_ID_INVALID\") {\r\n                    sender._authenticated = true;\r\n                    sender.userDisconnected = false;\r\n                    return sender;\r\n                }\r\n                if (this._log.canSend(Logger_1.LogLevel.ERROR)) {\r\n                    console.error(err);\r\n                }\r\n                await (0, Helpers_1.sleep)(1000);\r\n                await sender.disconnect();\r\n            }\r\n        }\r\n    }\r\n    /** @hidden */\r\n    async _borrowExportedSender(dcId, shouldReconnect, existingSender) {\r\n        if (!this._exportedSenderPromises.get(dcId) || shouldReconnect) {\r\n            this._exportedSenderPromises.set(dcId, this._connectSender(existingSender || this._createExportedSender(dcId), dcId));\r\n        }\r\n        let sender;\r\n        try {\r\n            sender = await this._exportedSenderPromises.get(dcId);\r\n            if (!sender.isConnected()) {\r\n                if (sender.isConnecting) {\r\n                    await (0, Helpers_1.sleep)(EXPORTED_SENDER_RECONNECT_TIMEOUT);\r\n                    return this._borrowExportedSender(dcId, false, sender);\r\n                }\r\n                else {\r\n                    return this._borrowExportedSender(dcId, true, sender);\r\n                }\r\n            }\r\n        }\r\n        catch (err) {\r\n            if (this._log.canSend(Logger_1.LogLevel.ERROR)) {\r\n                console.error(err);\r\n            }\r\n            return this._borrowExportedSender(dcId, true);\r\n        }\r\n        if (this._exportedSenderReleaseTimeouts.get(dcId)) {\r\n            clearTimeout(this._exportedSenderReleaseTimeouts.get(dcId));\r\n            this._exportedSenderReleaseTimeouts.delete(dcId);\r\n        }\r\n        this._exportedSenderReleaseTimeouts.set(dcId, setTimeout(() => {\r\n            this._exportedSenderReleaseTimeouts.delete(dcId);\r\n            sender.disconnect();\r\n        }, EXPORTED_SENDER_RELEASE_TIMEOUT));\r\n        return sender;\r\n    }\r\n    /** @hidden */\r\n    _createExportedSender(dcId) {\r\n        return new network_1.MTProtoSender(this.session.getAuthKey(dcId), {\r\n            logger: this._log,\r\n            dcId,\r\n            retries: this._connectionRetries,\r\n            delay: this._retryDelay,\r\n            autoReconnect: this._autoReconnect,\r\n            connectTimeout: this._timeout,\r\n            authKeyCallback: this._authKeyCallback.bind(this),\r\n            isMainSender: dcId === this.session.dcId,\r\n            onConnectionBreak: this._cleanupExportedSender.bind(this),\r\n            client: this,\r\n            securityChecks: this._securityChecks,\r\n        });\r\n    }\r\n    /** @hidden */\r\n    getSender(dcId) {\r\n        return dcId\r\n            ? this._borrowExportedSender(dcId)\r\n            : Promise.resolve(this._sender);\r\n    }\r\n    // endregion\r\n    async getDC(dcId, download) {\r\n        throw new Error(\"Cannot be called from here!\");\r\n    }\r\n    invoke(request) {\r\n        throw new Error(\"Cannot be called from here!\");\r\n    }\r\n    setLogLevel(level) {\r\n        this._log.setLevel(level);\r\n    }\r\n    get logger() {\r\n        return this._log;\r\n    }\r\n}\r\nexports.TelegramBaseClient = TelegramBaseClient;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}