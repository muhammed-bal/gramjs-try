{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObfuscatedConnection = exports.PacketCodec = exports.Connection = void 0;\nconst extensions_1 = require(\"../../extensions\");\n/**\r\n * The `Connection` class is a wrapper around ``asyncio.open_connection``.\r\n *\r\n * Subclasses will implement different transport modes as atomic operations,\r\n * which this class eases doing since the exposed interface simply puts and\r\n * gets complete data payloads to and from queues.\r\n *\r\n * The only error that will raise from send and receive methods is\r\n * ``ConnectionError``, which will raise when attempting to send if\r\n * the client is disconnected (includes remote disconnections).\r\n */\nclass Connection {\n  constructor({\n    ip,\n    port,\n    dcId,\n    loggers,\n    proxy,\n    socket,\n    testServers\n  }) {\n    this._ip = ip;\n    this._port = port;\n    this._dcId = dcId;\n    this._log = loggers;\n    this._proxy = proxy;\n    this._connected = false;\n    this._sendTask = undefined;\n    this._recvTask = undefined;\n    this._codec = undefined;\n    this._obfuscation = undefined; // TcpObfuscated and MTProxy\n    this._sendArray = new extensions_1.AsyncQueue();\n    this._recvArray = new extensions_1.AsyncQueue();\n    this.socket = new socket(proxy);\n    this._testServers = testServers;\n  }\n  async _connect() {\n    this._log.debug(\"Connecting\");\n    this._codec = new this.PacketCodecClass(this);\n    await this.socket.connect(this._port, this._ip, this._testServers);\n    this._log.debug(\"Finished connecting\");\n    // await this.socket.connect({host: this._ip, port: this._port});\n    await this._initConn();\n  }\n  async connect() {\n    await this._connect();\n    this._connected = true;\n    if (!this._sendTask) {\n      this._sendTask = this._sendLoop();\n    }\n    this._recvTask = this._recvLoop();\n  }\n  async disconnect() {\n    if (!this._connected) {\n      return;\n    }\n    this._connected = false;\n    void this._recvArray.push(undefined);\n    await this.socket.close();\n  }\n  async send(data) {\n    if (!this._connected) {\n      throw new Error(\"Not connected\");\n    }\n    await this._sendArray.push(data);\n  }\n  async recv() {\n    while (this._connected) {\n      const result = await this._recvArray.pop();\n      // null = sentinel value = keep trying\n      if (result) {\n        return result;\n      }\n    }\n    throw new Error(\"Not connected\");\n  }\n  async _sendLoop() {\n    try {\n      while (this._connected) {\n        const data = await this._sendArray.pop();\n        if (!data) {\n          this._sendTask = undefined;\n          return;\n        }\n        await this._send(data);\n      }\n    } catch (e) {\n      this._log.info(\"The server closed the connection while sending\");\n    }\n  }\n  isConnected() {\n    return this._connected;\n  }\n  async _recvLoop() {\n    let data;\n    while (this._connected) {\n      try {\n        data = await this._recv();\n        if (!data) {\n          throw new Error(\"no data received\");\n        }\n      } catch (e) {\n        this._log.info(\"connection closed\");\n        // await this._recvArray.push()\n        this.disconnect();\n        return;\n      }\n      await this._recvArray.push(data);\n    }\n  }\n  async _initConn() {\n    if (this._codec.tag) {\n      await this.socket.write(this._codec.tag);\n    }\n  }\n  async _send(data) {\n    const encodedPacket = this._codec.encodePacket(data);\n    this.socket.write(encodedPacket);\n  }\n  async _recv() {\n    return await this._codec.readPacket(this.socket);\n  }\n  toString() {\n    return `${this._ip}:${this._port}/${this.constructor.name.replace(\"Connection\", \"\")}`;\n  }\n}\nexports.Connection = Connection;\nclass ObfuscatedConnection extends Connection {\n  constructor() {\n    super(...arguments);\n    this.ObfuscatedIO = undefined;\n  }\n  async _initConn() {\n    this._obfuscation = new this.ObfuscatedIO(this);\n    await this._obfuscation.initHeader();\n    this.socket.write(this._obfuscation.header);\n  }\n  async _send(data) {\n    this._obfuscation.write(this._codec.encodePacket(data));\n  }\n  async _recv() {\n    return await this._codec.readPacket(this._obfuscation);\n  }\n}\nexports.ObfuscatedConnection = ObfuscatedConnection;\nclass PacketCodec {\n  constructor(connection) {\n    this._conn = connection;\n  }\n  encodePacket(data) {\n    throw new Error(\"Not Implemented\");\n    // Override\n  }\n\n  async readPacket(reader) {\n    // override\n    throw new Error(\"Not Implemented\");\n  }\n}\nexports.PacketCodec = PacketCodec;","map":{"version":3,"names":["Object","defineProperty","exports","value","ObfuscatedConnection","PacketCodec","Connection","extensions_1","require","constructor","ip","port","dcId","loggers","proxy","socket","testServers","_ip","_port","_dcId","_log","_proxy","_connected","_sendTask","undefined","_recvTask","_codec","_obfuscation","_sendArray","AsyncQueue","_recvArray","_testServers","_connect","debug","PacketCodecClass","connect","_initConn","_sendLoop","_recvLoop","disconnect","push","close","send","data","Error","recv","result","pop","_send","e","info","isConnected","_recv","tag","write","encodedPacket","encodePacket","readPacket","toString","name","replace","arguments","ObfuscatedIO","initHeader","header","connection","_conn","reader"],"sources":["C:/Users/Muhammed/Desktop/REACT_JS/dene-gramjs/node_modules/telegram/network/connection/Connection.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ObfuscatedConnection = exports.PacketCodec = exports.Connection = void 0;\r\nconst extensions_1 = require(\"../../extensions\");\r\n/**\r\n * The `Connection` class is a wrapper around ``asyncio.open_connection``.\r\n *\r\n * Subclasses will implement different transport modes as atomic operations,\r\n * which this class eases doing since the exposed interface simply puts and\r\n * gets complete data payloads to and from queues.\r\n *\r\n * The only error that will raise from send and receive methods is\r\n * ``ConnectionError``, which will raise when attempting to send if\r\n * the client is disconnected (includes remote disconnections).\r\n */\r\nclass Connection {\r\n    constructor({ ip, port, dcId, loggers, proxy, socket, testServers, }) {\r\n        this._ip = ip;\r\n        this._port = port;\r\n        this._dcId = dcId;\r\n        this._log = loggers;\r\n        this._proxy = proxy;\r\n        this._connected = false;\r\n        this._sendTask = undefined;\r\n        this._recvTask = undefined;\r\n        this._codec = undefined;\r\n        this._obfuscation = undefined; // TcpObfuscated and MTProxy\r\n        this._sendArray = new extensions_1.AsyncQueue();\r\n        this._recvArray = new extensions_1.AsyncQueue();\r\n        this.socket = new socket(proxy);\r\n        this._testServers = testServers;\r\n    }\r\n    async _connect() {\r\n        this._log.debug(\"Connecting\");\r\n        this._codec = new this.PacketCodecClass(this);\r\n        await this.socket.connect(this._port, this._ip, this._testServers);\r\n        this._log.debug(\"Finished connecting\");\r\n        // await this.socket.connect({host: this._ip, port: this._port});\r\n        await this._initConn();\r\n    }\r\n    async connect() {\r\n        await this._connect();\r\n        this._connected = true;\r\n        if (!this._sendTask) {\r\n            this._sendTask = this._sendLoop();\r\n        }\r\n        this._recvTask = this._recvLoop();\r\n    }\r\n    async disconnect() {\r\n        if (!this._connected) {\r\n            return;\r\n        }\r\n        this._connected = false;\r\n        void this._recvArray.push(undefined);\r\n        await this.socket.close();\r\n    }\r\n    async send(data) {\r\n        if (!this._connected) {\r\n            throw new Error(\"Not connected\");\r\n        }\r\n        await this._sendArray.push(data);\r\n    }\r\n    async recv() {\r\n        while (this._connected) {\r\n            const result = await this._recvArray.pop();\r\n            // null = sentinel value = keep trying\r\n            if (result) {\r\n                return result;\r\n            }\r\n        }\r\n        throw new Error(\"Not connected\");\r\n    }\r\n    async _sendLoop() {\r\n        try {\r\n            while (this._connected) {\r\n                const data = await this._sendArray.pop();\r\n                if (!data) {\r\n                    this._sendTask = undefined;\r\n                    return;\r\n                }\r\n                await this._send(data);\r\n            }\r\n        }\r\n        catch (e) {\r\n            this._log.info(\"The server closed the connection while sending\");\r\n        }\r\n    }\r\n    isConnected() {\r\n        return this._connected;\r\n    }\r\n    async _recvLoop() {\r\n        let data;\r\n        while (this._connected) {\r\n            try {\r\n                data = await this._recv();\r\n                if (!data) {\r\n                    throw new Error(\"no data received\");\r\n                }\r\n            }\r\n            catch (e) {\r\n                this._log.info(\"connection closed\");\r\n                // await this._recvArray.push()\r\n                this.disconnect();\r\n                return;\r\n            }\r\n            await this._recvArray.push(data);\r\n        }\r\n    }\r\n    async _initConn() {\r\n        if (this._codec.tag) {\r\n            await this.socket.write(this._codec.tag);\r\n        }\r\n    }\r\n    async _send(data) {\r\n        const encodedPacket = this._codec.encodePacket(data);\r\n        this.socket.write(encodedPacket);\r\n    }\r\n    async _recv() {\r\n        return await this._codec.readPacket(this.socket);\r\n    }\r\n    toString() {\r\n        return `${this._ip}:${this._port}/${this.constructor.name.replace(\"Connection\", \"\")}`;\r\n    }\r\n}\r\nexports.Connection = Connection;\r\nclass ObfuscatedConnection extends Connection {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.ObfuscatedIO = undefined;\r\n    }\r\n    async _initConn() {\r\n        this._obfuscation = new this.ObfuscatedIO(this);\r\n        await this._obfuscation.initHeader();\r\n        this.socket.write(this._obfuscation.header);\r\n    }\r\n    async _send(data) {\r\n        this._obfuscation.write(this._codec.encodePacket(data));\r\n    }\r\n    async _recv() {\r\n        return await this._codec.readPacket(this._obfuscation);\r\n    }\r\n}\r\nexports.ObfuscatedConnection = ObfuscatedConnection;\r\nclass PacketCodec {\r\n    constructor(connection) {\r\n        this._conn = connection;\r\n    }\r\n    encodePacket(data) {\r\n        throw new Error(\"Not Implemented\");\r\n        // Override\r\n    }\r\n    async readPacket(reader) {\r\n        // override\r\n        throw new Error(\"Not Implemented\");\r\n    }\r\n}\r\nexports.PacketCodec = PacketCodec;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}