{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MarkdownParser = void 0;\nconst messageParse_1 = require(\"../client/messageParse\");\nclass MarkdownParser {\n  // TODO maybe there is a better way :shrug:\n  static parse(message) {\n    let i = 0;\n    const keys = {};\n    for (const k in messageParse_1.DEFAULT_DELIMITERS) {\n      keys[k] = false;\n    }\n    const entities = [];\n    const tempEntities = {};\n    while (i < message.length) {\n      let foundIndex = -1;\n      let foundDelim = undefined;\n      for (const key of Object.keys(messageParse_1.DEFAULT_DELIMITERS)) {\n        const index = message.indexOf(key, i);\n        if (index > -1 && (foundIndex === -1 || index < foundIndex)) {\n          foundIndex = index;\n          foundDelim = key;\n        }\n      }\n      if (foundIndex === -1 || foundDelim == undefined) {\n        break;\n      }\n      if (!keys[foundDelim]) {\n        tempEntities[foundDelim] = new messageParse_1.DEFAULT_DELIMITERS[foundDelim]({\n          offset: foundIndex,\n          length: -1,\n          language: \"\"\n        });\n        keys[foundDelim] = true;\n      } else {\n        keys[foundDelim] = false;\n        tempEntities[foundDelim].length = foundIndex - tempEntities[foundDelim].offset;\n        entities.push(tempEntities[foundDelim]);\n      }\n      message = message.replace(foundDelim, \"\");\n      i = foundIndex;\n    }\n    return [message, entities];\n  }\n  static unparse(text, entities) {\n    const delimiters = messageParse_1.DEFAULT_DELIMITERS;\n    if (!text || !entities) {\n      return text;\n    }\n    let insertAt = [];\n    const tempDelimiters = new Map();\n    Object.keys(delimiters).forEach(key => {\n      tempDelimiters.set(delimiters[key].className, key);\n    });\n    for (const entity of entities) {\n      const s = entity.offset;\n      const e = entity.offset + entity.length;\n      const delimiter = tempDelimiters.get(entity.className);\n      if (delimiter) {\n        insertAt.push([s, delimiter]);\n        insertAt.push([e, delimiter]);\n      }\n    }\n    insertAt = insertAt.sort((a, b) => {\n      return a[0] - b[0];\n    });\n    while (insertAt.length) {\n      const [at, what] = insertAt.pop();\n      text = text.slice(0, at) + what + text.slice(at);\n    }\n    return text;\n  }\n}\nexports.MarkdownParser = MarkdownParser;","map":{"version":3,"names":["Object","defineProperty","exports","value","MarkdownParser","messageParse_1","require","parse","message","i","keys","k","DEFAULT_DELIMITERS","entities","tempEntities","length","foundIndex","foundDelim","undefined","key","index","indexOf","offset","language","push","replace","unparse","text","delimiters","insertAt","tempDelimiters","Map","forEach","set","className","entity","s","e","delimiter","get","sort","a","b","at","what","pop","slice"],"sources":["C:/Users/Muhammed/Desktop/REACT_JS/dene-gramjs/node_modules/telegram/extensions/markdown.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MarkdownParser = void 0;\r\nconst messageParse_1 = require(\"../client/messageParse\");\r\nclass MarkdownParser {\r\n    // TODO maybe there is a better way :shrug:\r\n    static parse(message) {\r\n        let i = 0;\r\n        const keys = {};\r\n        for (const k in messageParse_1.DEFAULT_DELIMITERS) {\r\n            keys[k] = false;\r\n        }\r\n        const entities = [];\r\n        const tempEntities = {};\r\n        while (i < message.length) {\r\n            let foundIndex = -1;\r\n            let foundDelim = undefined;\r\n            for (const key of Object.keys(messageParse_1.DEFAULT_DELIMITERS)) {\r\n                const index = message.indexOf(key, i);\r\n                if (index > -1 && (foundIndex === -1 || index < foundIndex)) {\r\n                    foundIndex = index;\r\n                    foundDelim = key;\r\n                }\r\n            }\r\n            if (foundIndex === -1 || foundDelim == undefined) {\r\n                break;\r\n            }\r\n            if (!keys[foundDelim]) {\r\n                tempEntities[foundDelim] = new messageParse_1.DEFAULT_DELIMITERS[foundDelim]({\r\n                    offset: foundIndex,\r\n                    length: -1,\r\n                    language: \"\",\r\n                });\r\n                keys[foundDelim] = true;\r\n            }\r\n            else {\r\n                keys[foundDelim] = false;\r\n                tempEntities[foundDelim].length =\r\n                    foundIndex - tempEntities[foundDelim].offset;\r\n                entities.push(tempEntities[foundDelim]);\r\n            }\r\n            message = message.replace(foundDelim, \"\");\r\n            i = foundIndex;\r\n        }\r\n        return [message, entities];\r\n    }\r\n    static unparse(text, entities) {\r\n        const delimiters = messageParse_1.DEFAULT_DELIMITERS;\r\n        if (!text || !entities) {\r\n            return text;\r\n        }\r\n        let insertAt = [];\r\n        const tempDelimiters = new Map();\r\n        Object.keys(delimiters).forEach((key) => {\r\n            tempDelimiters.set(delimiters[key].className, key);\r\n        });\r\n        for (const entity of entities) {\r\n            const s = entity.offset;\r\n            const e = entity.offset + entity.length;\r\n            const delimiter = tempDelimiters.get(entity.className);\r\n            if (delimiter) {\r\n                insertAt.push([s, delimiter]);\r\n                insertAt.push([e, delimiter]);\r\n            }\r\n        }\r\n        insertAt = insertAt.sort((a, b) => {\r\n            return a[0] - b[0];\r\n        });\r\n        while (insertAt.length) {\r\n            const [at, what] = insertAt.pop();\r\n            text = text.slice(0, at) + what + text.slice(at);\r\n        }\r\n        return text;\r\n    }\r\n}\r\nexports.MarkdownParser = MarkdownParser;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}