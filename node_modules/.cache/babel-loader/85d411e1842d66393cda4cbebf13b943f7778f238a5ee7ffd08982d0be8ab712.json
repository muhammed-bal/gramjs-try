{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.doAuthentication = void 0;\nconst buffer_1 = require(\"buffer/\");\nconst Helpers_1 = require(\"../Helpers\");\nconst tl_1 = require(\"../tl\");\nconst errors_1 = require(\"../errors\");\nconst Factorizator_1 = require(\"../crypto/Factorizator\");\nconst RSA_1 = require(\"../crypto/RSA\");\nconst IGE_1 = require(\"../crypto/IGE\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst extensions_1 = require(\"../extensions\");\nconst AuthKey_1 = require(\"../crypto/AuthKey\");\nconst RETRIES = 20;\nasync function doAuthentication(sender, log) {\n  // Step 1 sending: PQ Request, endianness doesn't matter since it's random\n  let bytes = (0, Helpers_1.generateRandomBytes)(16);\n  const nonce = (0, Helpers_1.readBigIntFromBuffer)(bytes, false, true);\n  const resPQ = await sender.send(new tl_1.Api.ReqPqMulti({\n    nonce\n  }));\n  log.debug(\"Starting authKey generation step 1\");\n  if (!(resPQ instanceof tl_1.Api.ResPQ)) {\n    throw new errors_1.SecurityError(`Step 1 answer was ${resPQ}`);\n  }\n  if (resPQ.nonce.neq(nonce)) {\n    throw new errors_1.SecurityError(\"Step 1 invalid nonce from server\");\n  }\n  const pq = (0, Helpers_1.readBigIntFromBuffer)(resPQ.pq, false, true);\n  log.debug(\"Finished authKey generation step 1\");\n  // Step 2 sending: DH Exchange\n  const {\n    p,\n    q\n  } = Factorizator_1.Factorizator.factorize(pq);\n  const pBuffer = (0, Helpers_1.getByteArray)(p);\n  const qBuffer = (0, Helpers_1.getByteArray)(q);\n  bytes = (0, Helpers_1.generateRandomBytes)(32);\n  const newNonce = (0, Helpers_1.readBigIntFromBuffer)(bytes, true, true);\n  const pqInnerData = new tl_1.Api.PQInnerData({\n    pq: (0, Helpers_1.getByteArray)(pq),\n    p: pBuffer,\n    q: qBuffer,\n    nonce: resPQ.nonce,\n    serverNonce: resPQ.serverNonce,\n    newNonce\n  }).getBytes();\n  if (pqInnerData.length > 144) {\n    throw new errors_1.SecurityError(\"Step 1 invalid nonce from server\");\n  }\n  let targetFingerprint;\n  let targetKey;\n  for (const fingerprint of resPQ.serverPublicKeyFingerprints) {\n    targetKey = RSA_1._serverKeys.get(fingerprint.toString());\n    if (targetKey !== undefined) {\n      targetFingerprint = fingerprint;\n      break;\n    }\n  }\n  if (targetFingerprint === undefined || targetKey === undefined) {\n    throw new errors_1.SecurityError(\"Step 2 could not find a valid key for fingerprints\");\n  }\n  // Value should be padded to be made 192 exactly\n  const padding = (0, Helpers_1.generateRandomBytes)(192 - pqInnerData.length);\n  const dataWithPadding = buffer_1.Buffer.concat([pqInnerData, padding]);\n  const dataPadReversed = buffer_1.Buffer.from(dataWithPadding).reverse();\n  let encryptedData;\n  for (let i = 0; i < RETRIES; i++) {\n    const tempKey = (0, Helpers_1.generateRandomBytes)(32);\n    const shaDigestKeyWithData = await (0, Helpers_1.sha256)(buffer_1.Buffer.concat([tempKey, dataWithPadding]));\n    const dataWithHash = buffer_1.Buffer.concat([dataPadReversed, shaDigestKeyWithData]);\n    const ige = new IGE_1.IGE(tempKey, buffer_1.Buffer.alloc(32));\n    const aesEncrypted = ige.encryptIge(dataWithHash);\n    const tempKeyXor = (0, Helpers_1.bufferXor)(tempKey, await (0, Helpers_1.sha256)(aesEncrypted));\n    const keyAesEncrypted = buffer_1.Buffer.concat([tempKeyXor, aesEncrypted]);\n    const keyAesEncryptedInt = (0, Helpers_1.readBigIntFromBuffer)(keyAesEncrypted, false, false);\n    if (keyAesEncryptedInt.greaterOrEquals(targetKey.n)) {\n      log.debug(\"Aes key greater than RSA. retrying\");\n      continue;\n    }\n    const encryptedDataBuffer = (0, Helpers_1.modExp)(keyAesEncryptedInt, (0, big_integer_1.default)(targetKey.e), targetKey.n);\n    encryptedData = (0, Helpers_1.readBufferFromBigInt)(encryptedDataBuffer, 256, false, false);\n    break;\n  }\n  if (encryptedData === undefined) {\n    throw new errors_1.SecurityError(\"Step 2 could create a secure encrypted key\");\n  }\n  log.debug(\"Step 2 : Generated a secure aes encrypted data\");\n  const serverDhParams = await sender.send(new tl_1.Api.ReqDHParams({\n    nonce: resPQ.nonce,\n    serverNonce: resPQ.serverNonce,\n    p: pBuffer,\n    q: qBuffer,\n    publicKeyFingerprint: targetFingerprint,\n    encryptedData\n  }));\n  if (!(serverDhParams instanceof tl_1.Api.ServerDHParamsOk || serverDhParams instanceof tl_1.Api.ServerDHParamsFail)) {\n    throw new Error(`Step 2.1 answer was ${serverDhParams}`);\n  }\n  if (serverDhParams.nonce.neq(resPQ.nonce)) {\n    throw new errors_1.SecurityError(\"Step 2 invalid nonce from server\");\n  }\n  if (serverDhParams.serverNonce.neq(resPQ.serverNonce)) {\n    throw new errors_1.SecurityError(\"Step 2 invalid server nonce from server\");\n  }\n  if (serverDhParams instanceof tl_1.Api.ServerDHParamsFail) {\n    const sh = await (0, Helpers_1.sha1)((0, Helpers_1.toSignedLittleBuffer)(newNonce, 32).slice(4, 20));\n    const nnh = (0, Helpers_1.readBigIntFromBuffer)(sh, true, true);\n    if (serverDhParams.newNonceHash.neq(nnh)) {\n      throw new errors_1.SecurityError(\"Step 2 invalid DH fail nonce from server\");\n    }\n  }\n  if (!(serverDhParams instanceof tl_1.Api.ServerDHParamsOk)) {\n    throw new Error(`Step 2.2 answer was ${serverDhParams}`);\n  }\n  log.debug(\"Finished authKey generation step 2\");\n  log.debug(\"Starting authKey generation step 3\");\n  // Step 3 sending: Complete DH Exchange\n  const {\n    key,\n    iv\n  } = await (0, Helpers_1.generateKeyDataFromNonce)(resPQ.serverNonce, newNonce);\n  if (serverDhParams.encryptedAnswer.length % 16 !== 0) {\n    // See PR#453\n    throw new errors_1.SecurityError(\"Step 3 AES block size mismatch\");\n  }\n  const ige = new IGE_1.IGE(key, iv);\n  const plainTextAnswer = ige.decryptIge(serverDhParams.encryptedAnswer);\n  const reader = new extensions_1.BinaryReader(plainTextAnswer);\n  reader.read(20); // hash sum\n  const serverDhInner = reader.tgReadObject();\n  if (!(serverDhInner instanceof tl_1.Api.ServerDHInnerData)) {\n    throw new Error(`Step 3 answer was ${serverDhInner}`);\n  }\n  if (serverDhInner.nonce.neq(resPQ.nonce)) {\n    throw new errors_1.SecurityError(\"Step 3 Invalid nonce in encrypted answer\");\n  }\n  if (serverDhInner.serverNonce.neq(resPQ.serverNonce)) {\n    throw new errors_1.SecurityError(\"Step 3 Invalid server nonce in encrypted answer\");\n  }\n  const dhPrime = (0, Helpers_1.readBigIntFromBuffer)(serverDhInner.dhPrime, false, false);\n  const ga = (0, Helpers_1.readBigIntFromBuffer)(serverDhInner.gA, false, false);\n  const timeOffset = serverDhInner.serverTime - Math.floor(new Date().getTime() / 1000);\n  const b = (0, Helpers_1.readBigIntFromBuffer)((0, Helpers_1.generateRandomBytes)(256), false, false);\n  const gb = (0, Helpers_1.modExp)((0, big_integer_1.default)(serverDhInner.g), b, dhPrime);\n  const gab = (0, Helpers_1.modExp)(ga, b, dhPrime);\n  // Prepare client DH Inner Data\n  const clientDhInner = new tl_1.Api.ClientDHInnerData({\n    nonce: resPQ.nonce,\n    serverNonce: resPQ.serverNonce,\n    retryId: big_integer_1.default.zero,\n    gB: (0, Helpers_1.getByteArray)(gb, false)\n  }).getBytes();\n  const clientDdhInnerHashed = buffer_1.Buffer.concat([await (0, Helpers_1.sha1)(clientDhInner), clientDhInner]);\n  // Encryption\n  const clientDhEncrypted = ige.encryptIge(clientDdhInnerHashed);\n  const dhGen = await sender.send(new tl_1.Api.SetClientDHParams({\n    nonce: resPQ.nonce,\n    serverNonce: resPQ.serverNonce,\n    encryptedData: clientDhEncrypted\n  }));\n  const nonceTypes = [tl_1.Api.DhGenOk, tl_1.Api.DhGenRetry, tl_1.Api.DhGenFail];\n  // TS being weird again.\n  const nonceTypesString = [\"DhGenOk\", \"DhGenRetry\", \"DhGenFail\"];\n  if (!(dhGen instanceof nonceTypes[0] || dhGen instanceof nonceTypes[1] || dhGen instanceof nonceTypes[2])) {\n    throw new Error(`Step 3.1 answer was ${dhGen}`);\n  }\n  const {\n    name\n  } = dhGen.constructor;\n  if (dhGen.nonce.neq(resPQ.nonce)) {\n    throw new errors_1.SecurityError(`Step 3 invalid ${name} nonce from server`);\n  }\n  if (dhGen.serverNonce.neq(resPQ.serverNonce)) {\n    throw new errors_1.SecurityError(`Step 3 invalid ${name} server nonce from server`);\n  }\n  const authKey = new AuthKey_1.AuthKey();\n  await authKey.setKey((0, Helpers_1.getByteArray)(gab));\n  const nonceNumber = 1 + nonceTypesString.indexOf(dhGen.className);\n  const newNonceHash = await authKey.calcNewNonceHash(newNonce, nonceNumber);\n  // @ts-ignore\n  const dhHash = dhGen[`newNonceHash${nonceNumber}`];\n  if (dhHash.neq(newNonceHash)) {\n    throw new errors_1.SecurityError(\"Step 3 invalid new nonce hash\");\n  }\n  if (!(dhGen instanceof tl_1.Api.DhGenOk)) {\n    throw new Error(`Step 3.2 answer was ${dhGen}`);\n  }\n  log.debug(\"Finished authKey generation step 3\");\n  return {\n    authKey,\n    timeOffset\n  };\n}\nexports.doAuthentication = doAuthentication;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","doAuthentication","buffer_1","require","Helpers_1","tl_1","errors_1","Factorizator_1","RSA_1","IGE_1","big_integer_1","extensions_1","AuthKey_1","RETRIES","sender","log","bytes","generateRandomBytes","nonce","readBigIntFromBuffer","resPQ","send","Api","ReqPqMulti","debug","ResPQ","SecurityError","neq","pq","p","q","Factorizator","factorize","pBuffer","getByteArray","qBuffer","newNonce","pqInnerData","PQInnerData","serverNonce","getBytes","length","targetFingerprint","targetKey","fingerprint","serverPublicKeyFingerprints","_serverKeys","get","toString","undefined","padding","dataWithPadding","Buffer","concat","dataPadReversed","from","reverse","encryptedData","i","tempKey","shaDigestKeyWithData","sha256","dataWithHash","ige","IGE","alloc","aesEncrypted","encryptIge","tempKeyXor","bufferXor","keyAesEncrypted","keyAesEncryptedInt","greaterOrEquals","n","encryptedDataBuffer","modExp","default","e","readBufferFromBigInt","serverDhParams","ReqDHParams","publicKeyFingerprint","ServerDHParamsOk","ServerDHParamsFail","Error","sh","sha1","toSignedLittleBuffer","slice","nnh","newNonceHash","key","iv","generateKeyDataFromNonce","encryptedAnswer","plainTextAnswer","decryptIge","reader","BinaryReader","read","serverDhInner","tgReadObject","ServerDHInnerData","dhPrime","ga","gA","timeOffset","serverTime","Math","floor","Date","getTime","b","gb","g","gab","clientDhInner","ClientDHInnerData","retryId","zero","gB","clientDdhInnerHashed","clientDhEncrypted","dhGen","SetClientDHParams","nonceTypes","DhGenOk","DhGenRetry","DhGenFail","nonceTypesString","name","constructor","authKey","AuthKey","setKey","nonceNumber","indexOf","className","calcNewNonceHash","dhHash"],"sources":["C:/Users/Muhammed/Desktop/REACT_JS/dene-gramjs/node_modules/telegram/network/Authenticator.js"],"sourcesContent":["\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.doAuthentication = void 0;\r\nconst buffer_1 = require(\"buffer/\");\r\nconst Helpers_1 = require(\"../Helpers\");\r\nconst tl_1 = require(\"../tl\");\r\nconst errors_1 = require(\"../errors\");\r\nconst Factorizator_1 = require(\"../crypto/Factorizator\");\r\nconst RSA_1 = require(\"../crypto/RSA\");\r\nconst IGE_1 = require(\"../crypto/IGE\");\r\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\r\nconst extensions_1 = require(\"../extensions\");\r\nconst AuthKey_1 = require(\"../crypto/AuthKey\");\r\nconst RETRIES = 20;\r\nasync function doAuthentication(sender, log) {\r\n    // Step 1 sending: PQ Request, endianness doesn't matter since it's random\r\n    let bytes = (0, Helpers_1.generateRandomBytes)(16);\r\n    const nonce = (0, Helpers_1.readBigIntFromBuffer)(bytes, false, true);\r\n    const resPQ = await sender.send(new tl_1.Api.ReqPqMulti({ nonce }));\r\n    log.debug(\"Starting authKey generation step 1\");\r\n    if (!(resPQ instanceof tl_1.Api.ResPQ)) {\r\n        throw new errors_1.SecurityError(`Step 1 answer was ${resPQ}`);\r\n    }\r\n    if (resPQ.nonce.neq(nonce)) {\r\n        throw new errors_1.SecurityError(\"Step 1 invalid nonce from server\");\r\n    }\r\n    const pq = (0, Helpers_1.readBigIntFromBuffer)(resPQ.pq, false, true);\r\n    log.debug(\"Finished authKey generation step 1\");\r\n    // Step 2 sending: DH Exchange\r\n    const { p, q } = Factorizator_1.Factorizator.factorize(pq);\r\n    const pBuffer = (0, Helpers_1.getByteArray)(p);\r\n    const qBuffer = (0, Helpers_1.getByteArray)(q);\r\n    bytes = (0, Helpers_1.generateRandomBytes)(32);\r\n    const newNonce = (0, Helpers_1.readBigIntFromBuffer)(bytes, true, true);\r\n    const pqInnerData = new tl_1.Api.PQInnerData({\r\n        pq: (0, Helpers_1.getByteArray)(pq),\r\n        p: pBuffer,\r\n        q: qBuffer,\r\n        nonce: resPQ.nonce,\r\n        serverNonce: resPQ.serverNonce,\r\n        newNonce,\r\n    }).getBytes();\r\n    if (pqInnerData.length > 144) {\r\n        throw new errors_1.SecurityError(\"Step 1 invalid nonce from server\");\r\n    }\r\n    let targetFingerprint;\r\n    let targetKey;\r\n    for (const fingerprint of resPQ.serverPublicKeyFingerprints) {\r\n        targetKey = RSA_1._serverKeys.get(fingerprint.toString());\r\n        if (targetKey !== undefined) {\r\n            targetFingerprint = fingerprint;\r\n            break;\r\n        }\r\n    }\r\n    if (targetFingerprint === undefined || targetKey === undefined) {\r\n        throw new errors_1.SecurityError(\"Step 2 could not find a valid key for fingerprints\");\r\n    }\r\n    // Value should be padded to be made 192 exactly\r\n    const padding = (0, Helpers_1.generateRandomBytes)(192 - pqInnerData.length);\r\n    const dataWithPadding = buffer_1.Buffer.concat([pqInnerData, padding]);\r\n    const dataPadReversed = buffer_1.Buffer.from(dataWithPadding).reverse();\r\n    let encryptedData;\r\n    for (let i = 0; i < RETRIES; i++) {\r\n        const tempKey = (0, Helpers_1.generateRandomBytes)(32);\r\n        const shaDigestKeyWithData = await (0, Helpers_1.sha256)(buffer_1.Buffer.concat([tempKey, dataWithPadding]));\r\n        const dataWithHash = buffer_1.Buffer.concat([\r\n            dataPadReversed,\r\n            shaDigestKeyWithData,\r\n        ]);\r\n        const ige = new IGE_1.IGE(tempKey, buffer_1.Buffer.alloc(32));\r\n        const aesEncrypted = ige.encryptIge(dataWithHash);\r\n        const tempKeyXor = (0, Helpers_1.bufferXor)(tempKey, await (0, Helpers_1.sha256)(aesEncrypted));\r\n        const keyAesEncrypted = buffer_1.Buffer.concat([tempKeyXor, aesEncrypted]);\r\n        const keyAesEncryptedInt = (0, Helpers_1.readBigIntFromBuffer)(keyAesEncrypted, false, false);\r\n        if (keyAesEncryptedInt.greaterOrEquals(targetKey.n)) {\r\n            log.debug(\"Aes key greater than RSA. retrying\");\r\n            continue;\r\n        }\r\n        const encryptedDataBuffer = (0, Helpers_1.modExp)(keyAesEncryptedInt, (0, big_integer_1.default)(targetKey.e), targetKey.n);\r\n        encryptedData = (0, Helpers_1.readBufferFromBigInt)(encryptedDataBuffer, 256, false, false);\r\n        break;\r\n    }\r\n    if (encryptedData === undefined) {\r\n        throw new errors_1.SecurityError(\"Step 2 could create a secure encrypted key\");\r\n    }\r\n    log.debug(\"Step 2 : Generated a secure aes encrypted data\");\r\n    const serverDhParams = await sender.send(new tl_1.Api.ReqDHParams({\r\n        nonce: resPQ.nonce,\r\n        serverNonce: resPQ.serverNonce,\r\n        p: pBuffer,\r\n        q: qBuffer,\r\n        publicKeyFingerprint: targetFingerprint,\r\n        encryptedData,\r\n    }));\r\n    if (!(serverDhParams instanceof tl_1.Api.ServerDHParamsOk ||\r\n        serverDhParams instanceof tl_1.Api.ServerDHParamsFail)) {\r\n        throw new Error(`Step 2.1 answer was ${serverDhParams}`);\r\n    }\r\n    if (serverDhParams.nonce.neq(resPQ.nonce)) {\r\n        throw new errors_1.SecurityError(\"Step 2 invalid nonce from server\");\r\n    }\r\n    if (serverDhParams.serverNonce.neq(resPQ.serverNonce)) {\r\n        throw new errors_1.SecurityError(\"Step 2 invalid server nonce from server\");\r\n    }\r\n    if (serverDhParams instanceof tl_1.Api.ServerDHParamsFail) {\r\n        const sh = await (0, Helpers_1.sha1)((0, Helpers_1.toSignedLittleBuffer)(newNonce, 32).slice(4, 20));\r\n        const nnh = (0, Helpers_1.readBigIntFromBuffer)(sh, true, true);\r\n        if (serverDhParams.newNonceHash.neq(nnh)) {\r\n            throw new errors_1.SecurityError(\"Step 2 invalid DH fail nonce from server\");\r\n        }\r\n    }\r\n    if (!(serverDhParams instanceof tl_1.Api.ServerDHParamsOk)) {\r\n        throw new Error(`Step 2.2 answer was ${serverDhParams}`);\r\n    }\r\n    log.debug(\"Finished authKey generation step 2\");\r\n    log.debug(\"Starting authKey generation step 3\");\r\n    // Step 3 sending: Complete DH Exchange\r\n    const { key, iv } = await (0, Helpers_1.generateKeyDataFromNonce)(resPQ.serverNonce, newNonce);\r\n    if (serverDhParams.encryptedAnswer.length % 16 !== 0) {\r\n        // See PR#453\r\n        throw new errors_1.SecurityError(\"Step 3 AES block size mismatch\");\r\n    }\r\n    const ige = new IGE_1.IGE(key, iv);\r\n    const plainTextAnswer = ige.decryptIge(serverDhParams.encryptedAnswer);\r\n    const reader = new extensions_1.BinaryReader(plainTextAnswer);\r\n    reader.read(20); // hash sum\r\n    const serverDhInner = reader.tgReadObject();\r\n    if (!(serverDhInner instanceof tl_1.Api.ServerDHInnerData)) {\r\n        throw new Error(`Step 3 answer was ${serverDhInner}`);\r\n    }\r\n    if (serverDhInner.nonce.neq(resPQ.nonce)) {\r\n        throw new errors_1.SecurityError(\"Step 3 Invalid nonce in encrypted answer\");\r\n    }\r\n    if (serverDhInner.serverNonce.neq(resPQ.serverNonce)) {\r\n        throw new errors_1.SecurityError(\"Step 3 Invalid server nonce in encrypted answer\");\r\n    }\r\n    const dhPrime = (0, Helpers_1.readBigIntFromBuffer)(serverDhInner.dhPrime, false, false);\r\n    const ga = (0, Helpers_1.readBigIntFromBuffer)(serverDhInner.gA, false, false);\r\n    const timeOffset = serverDhInner.serverTime - Math.floor(new Date().getTime() / 1000);\r\n    const b = (0, Helpers_1.readBigIntFromBuffer)((0, Helpers_1.generateRandomBytes)(256), false, false);\r\n    const gb = (0, Helpers_1.modExp)((0, big_integer_1.default)(serverDhInner.g), b, dhPrime);\r\n    const gab = (0, Helpers_1.modExp)(ga, b, dhPrime);\r\n    // Prepare client DH Inner Data\r\n    const clientDhInner = new tl_1.Api.ClientDHInnerData({\r\n        nonce: resPQ.nonce,\r\n        serverNonce: resPQ.serverNonce,\r\n        retryId: big_integer_1.default.zero,\r\n        gB: (0, Helpers_1.getByteArray)(gb, false),\r\n    }).getBytes();\r\n    const clientDdhInnerHashed = buffer_1.Buffer.concat([\r\n        await (0, Helpers_1.sha1)(clientDhInner),\r\n        clientDhInner,\r\n    ]);\r\n    // Encryption\r\n    const clientDhEncrypted = ige.encryptIge(clientDdhInnerHashed);\r\n    const dhGen = await sender.send(new tl_1.Api.SetClientDHParams({\r\n        nonce: resPQ.nonce,\r\n        serverNonce: resPQ.serverNonce,\r\n        encryptedData: clientDhEncrypted,\r\n    }));\r\n    const nonceTypes = [tl_1.Api.DhGenOk, tl_1.Api.DhGenRetry, tl_1.Api.DhGenFail];\r\n    // TS being weird again.\r\n    const nonceTypesString = [\"DhGenOk\", \"DhGenRetry\", \"DhGenFail\"];\r\n    if (!(dhGen instanceof nonceTypes[0] ||\r\n        dhGen instanceof nonceTypes[1] ||\r\n        dhGen instanceof nonceTypes[2])) {\r\n        throw new Error(`Step 3.1 answer was ${dhGen}`);\r\n    }\r\n    const { name } = dhGen.constructor;\r\n    if (dhGen.nonce.neq(resPQ.nonce)) {\r\n        throw new errors_1.SecurityError(`Step 3 invalid ${name} nonce from server`);\r\n    }\r\n    if (dhGen.serverNonce.neq(resPQ.serverNonce)) {\r\n        throw new errors_1.SecurityError(`Step 3 invalid ${name} server nonce from server`);\r\n    }\r\n    const authKey = new AuthKey_1.AuthKey();\r\n    await authKey.setKey((0, Helpers_1.getByteArray)(gab));\r\n    const nonceNumber = 1 + nonceTypesString.indexOf(dhGen.className);\r\n    const newNonceHash = await authKey.calcNewNonceHash(newNonce, nonceNumber);\r\n    // @ts-ignore\r\n    const dhHash = dhGen[`newNonceHash${nonceNumber}`];\r\n    if (dhHash.neq(newNonceHash)) {\r\n        throw new errors_1.SecurityError(\"Step 3 invalid new nonce hash\");\r\n    }\r\n    if (!(dhGen instanceof tl_1.Api.DhGenOk)) {\r\n        throw new Error(`Step 3.2 answer was ${dhGen}`);\r\n    }\r\n    log.debug(\"Finished authKey generation step 3\");\r\n    return { authKey, timeOffset };\r\n}\r\nexports.doAuthentication = doAuthentication;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}