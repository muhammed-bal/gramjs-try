{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n    i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.downloadProfilePhoto = exports._downloadPhoto = exports._downloadCachedPhotoSize = exports._downloadWebDocument = exports._downloadContact = exports._downloadDocument = exports.downloadMedia = exports.downloadFileV2 = exports.iterDownload = exports.GenericDownloadIter = exports.DirectDownloadIter = void 0;\nconst buffer_1 = require(\"buffer/\");\nconst tl_1 = require(\"../tl\");\nconst Utils_1 = require(\"../Utils\");\nconst Helpers_1 = require(\"../Helpers\");\nconst __1 = require(\"../\");\nconst requestIter_1 = require(\"../requestIter\");\nconst errors_1 = require(\"../errors\");\nconst fs_1 = require(\"./fs\");\nconst extensions_1 = require(\"../extensions\");\nconst fs = __importStar(require(\"./fs\"));\nconst path_1 = __importDefault(require(\"./path\"));\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\n// All types\nconst sizeTypes = [\"w\", \"y\", \"d\", \"x\", \"c\", \"m\", \"b\", \"a\", \"s\"];\n// Chunk sizes for `upload.getFile` must be multiple of the smallest size\nconst MIN_CHUNK_SIZE = 4096;\nconst DEFAULT_CHUNK_SIZE = 64; // kb\nconst ONE_MB = 1024 * 1024;\nconst REQUEST_TIMEOUT = 15000;\nconst DISCONNECT_SLEEP = 1000;\nconst TIMED_OUT_SLEEP = 1000;\nconst MAX_CHUNK_SIZE = 512 * 1024;\nclass DirectDownloadIter extends requestIter_1.RequestIter {\n  constructor() {\n    super(...arguments);\n    this._timedOut = false;\n  }\n  async _init({\n    fileLocation,\n    dcId,\n    offset,\n    stride,\n    chunkSize,\n    requestSize,\n    fileSize,\n    msgData\n  }) {\n    this.request = new tl_1.Api.upload.GetFile({\n      location: fileLocation,\n      offset,\n      limit: requestSize\n    });\n    this.total = fileSize;\n    this._stride = stride;\n    this._chunkSize = chunkSize;\n    this._lastPart = undefined;\n    //this._msgData = msgData;\n    this._timedOut = false;\n    this._sender = await this.client.getSender(dcId);\n  }\n  async _loadNextChunk() {\n    const current = await this._request();\n    this.buffer.push(current);\n    if (current.length < this.request.limit) {\n      // we finished downloading\n      this.left = this.buffer.length;\n      await this.close();\n      return true;\n    } else {\n      this.request.offset = this.request.offset.add(this._stride);\n    }\n  }\n  async _request() {\n    try {\n      this._sender = await this.client.getSender(this._sender.dcId);\n      const result = await this.client.invokeWithSender(this.request, this._sender);\n      this._timedOut = false;\n      if (result instanceof tl_1.Api.upload.FileCdnRedirect) {\n        throw new Error(\"CDN Not supported. Please Add an issue in github\");\n      }\n      return result.bytes;\n    } catch (e) {\n      if (e.errorMessage == \"TIMEOUT\") {\n        if (this._timedOut) {\n          this.client._log.warn(\"Got two timeouts in a row while downloading file\");\n          throw e;\n        }\n        this._timedOut = true;\n        this.client._log.info(\"Got timeout while downloading file, retrying once\");\n        await (0, Helpers_1.sleep)(TIMED_OUT_SLEEP);\n        return await this._request();\n      } else if (e instanceof errors_1.FileMigrateError) {\n        this.client._log.info(\"File lives in another DC\");\n        this._sender = await this.client.getSender(e.newDc);\n        return await this._request();\n      } else if (e.errorMessage == \"FILEREF_UPGRADE_NEEDED\") {\n        // TODO later\n        throw e;\n      } else {\n        throw e;\n      }\n    }\n  }\n  async close() {\n    this.client._log.debug(\"Finished downloading file ...\");\n  }\n  [Symbol.asyncIterator]() {\n    return super[Symbol.asyncIterator]();\n  }\n}\nexports.DirectDownloadIter = DirectDownloadIter;\nclass GenericDownloadIter extends DirectDownloadIter {\n  async _loadNextChunk() {\n    // 1. Fetch enough for one chunk\n    let data = buffer_1.Buffer.alloc(0);\n    //  1.1. ``bad`` is how much into the data we have we need to offset\n    const bad = this.request.offset.mod(this.request.limit).toJSNumber();\n    const before = this.request.offset;\n    // 1.2. We have to fetch from a valid offset, so remove that bad part\n    this.request.offset = this.request.offset.subtract(bad);\n    let done = false;\n    while (!done && data.length - bad < this._chunkSize) {\n      const current = await this._request();\n      this.request.offset = this.request.offset.add(this.request.limit);\n      data = buffer_1.Buffer.concat([data, current]);\n      done = current.length < this.request.limit;\n    }\n    // 1.3 Restore our last desired offset\n    this.request.offset = before;\n    // 2. Fill the buffer with the data we have\n    // 2.1. The current chunk starts at ``bad`` offset into the data,\n    //  and each new chunk is ``stride`` bytes apart of the other\n    for (let i = bad; i < data.length; i += this._stride) {\n      this.buffer.push(data.slice(i, i + this._chunkSize));\n      // 2.2. We will yield this offset, so move to the next one\n      this.request.offset = this.request.offset.add(this._stride);\n    }\n    // 2.3. If we are in the last chunk, we will return the last partial data\n    if (done) {\n      this.left = this.buffer.length;\n      await this.close();\n      return;\n    }\n    // 2.4 If we are not done, we can't return incomplete chunks.\n    if (this.buffer[this.buffer.length - 1].length != this._chunkSize) {\n      this._lastPart = this.buffer.pop();\n      //   3. Be careful with the offsets. Re-fetching a bit of data\n      //   is fine, since it greatly simplifies things.\n      // TODO Try to not re-fetch data\n      this.request.offset = this.request.offset.subtract(this._stride);\n    }\n  }\n}\nexports.GenericDownloadIter = GenericDownloadIter;\n/** @hidden */\nfunction iterDownload(client, {\n  file,\n  offset = big_integer_1.default.zero,\n  stride,\n  limit,\n  chunkSize,\n  requestSize = MAX_CHUNK_SIZE,\n  fileSize,\n  dcId,\n  msgData\n}) {\n  // we're ignoring here to make it more flexible (which is probably a bad idea)\n  // @ts-ignore\n  const info = __1.utils.getFileInfo(file);\n  if (info.dcId != undefined) {\n    dcId = info.dcId;\n  }\n  if (fileSize == undefined) {\n    fileSize = info.size;\n  }\n  file = info.location;\n  if (chunkSize == undefined) {\n    chunkSize = requestSize;\n  }\n  if (limit == undefined && fileSize != undefined) {\n    limit = Math.floor(fileSize.add(chunkSize).subtract(1).divide(chunkSize).toJSNumber());\n  }\n  if (stride == undefined) {\n    stride = chunkSize;\n  } else if (stride < chunkSize) {\n    throw new Error(\"Stride must be >= chunkSize\");\n  }\n  requestSize -= requestSize % MIN_CHUNK_SIZE;\n  if (requestSize < MIN_CHUNK_SIZE) {\n    requestSize = MIN_CHUNK_SIZE;\n  } else if (requestSize > MAX_CHUNK_SIZE) {\n    requestSize = MAX_CHUNK_SIZE;\n  }\n  let cls;\n  if (chunkSize == requestSize && offset.divide(MAX_CHUNK_SIZE).eq(big_integer_1.default.zero) && stride % MIN_CHUNK_SIZE == 0 && (limit == undefined || offset.divide(limit).eq(big_integer_1.default.zero))) {\n    cls = DirectDownloadIter;\n    client._log.info(`Starting direct file download in chunks of ${requestSize} at ${offset}, stride ${stride}`);\n  } else {\n    cls = GenericDownloadIter;\n    client._log.info(`Starting indirect file download in chunks of ${requestSize} at ${offset}, stride ${stride}`);\n  }\n  return new cls(client, limit, {}, {\n    fileLocation: file,\n    dcId,\n    offset,\n    stride,\n    chunkSize,\n    requestSize,\n    fileSize,\n    msgData\n  });\n}\nexports.iterDownload = iterDownload;\nfunction getWriter(outputFile) {\n  if (!outputFile || buffer_1.Buffer.isBuffer(outputFile)) {\n    return new extensions_1.BinaryWriter(buffer_1.Buffer.alloc(0));\n  } else if (typeof outputFile == \"string\") {\n    // We want to make sure that the path exists.\n    return (0, fs_1.createWriteStream)(outputFile);\n  } else {\n    return outputFile;\n  }\n}\nfunction closeWriter(writer) {\n  if (\"close\" in writer && writer.close) {\n    writer.close();\n  }\n}\nfunction returnWriterValue(writer) {\n  if (writer instanceof extensions_1.BinaryWriter) {\n    return writer.getValue();\n  }\n  if (writer instanceof fs.WriteStream) {\n    if (typeof writer.path == \"string\") {\n      return path_1.default.resolve(writer.path);\n    } else {\n      return buffer_1.Buffer.from(writer.path);\n    }\n  }\n}\n/** @hidden */\nasync function downloadFileV2(client, inputLocation, {\n  outputFile = undefined,\n  partSizeKb = undefined,\n  fileSize = undefined,\n  progressCallback = undefined,\n  dcId = undefined,\n  msgData = undefined\n}) {\n  var e_1, _a;\n  if (!partSizeKb) {\n    if (!fileSize) {\n      partSizeKb = 64;\n    } else {\n      partSizeKb = __1.utils.getAppropriatedPartSize(fileSize);\n    }\n  }\n  const partSize = Math.floor(partSizeKb * 1024);\n  if (partSize % MIN_CHUNK_SIZE != 0) {\n    throw new Error(\"The part size must be evenly divisible by 4096\");\n  }\n  const writer = getWriter(outputFile);\n  let downloaded = big_integer_1.default.zero;\n  try {\n    try {\n      for (var _b = __asyncValues(iterDownload(client, {\n          file: inputLocation,\n          requestSize: partSize,\n          dcId: dcId,\n          msgData: msgData\n        })), _c; _c = await _b.next(), !_c.done;) {\n        const chunk = _c.value;\n        await writer.write(chunk);\n        if (progressCallback) {\n          await progressCallback(downloaded, (0, big_integer_1.default)(fileSize || big_integer_1.default.zero));\n        }\n        downloaded = downloaded.add(chunk.length);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return returnWriterValue(writer);\n  } finally {\n    closeWriter(writer);\n  }\n}\nexports.downloadFileV2 = downloadFileV2;\nclass Foreman {\n  constructor(maxWorkers) {\n    this.maxWorkers = maxWorkers;\n    this.activeWorkers = 0;\n  }\n  requestWorker() {\n    this.activeWorkers++;\n    if (this.activeWorkers > this.maxWorkers) {\n      this.deferred = createDeferred();\n      return this.deferred.promise;\n    }\n    return Promise.resolve();\n  }\n  releaseWorker() {\n    this.activeWorkers--;\n    if (this.deferred && this.activeWorkers <= this.maxWorkers) {\n      this.deferred.resolve();\n    }\n  }\n}\nfunction createDeferred() {\n  let resolve;\n  const promise = new Promise(_resolve => {\n    resolve = _resolve;\n  });\n  return {\n    promise,\n    resolve: resolve\n  };\n}\n/** @hidden */\nasync function downloadMedia(client, messageOrMedia, outputFile, thumb, progressCallback) {\n  /*\r\n    Downloading large documents may be slow enough to require a new file reference\r\n    to be obtained mid-download. Store (input chat, message id) so that the message\r\n    can be re-fetched.\r\n   */\n  let msgData;\n  let date;\n  let media;\n  if (messageOrMedia instanceof tl_1.Api.Message) {\n    media = messageOrMedia.media;\n    date = messageOrMedia.date;\n    msgData = messageOrMedia.inputChat ? [messageOrMedia.inputChat, messageOrMedia.id] : undefined;\n  } else {\n    media = messageOrMedia;\n    date = Date.now();\n  }\n  if (typeof media == \"string\") {\n    throw new Error(\"not implemented\");\n  }\n  if (media instanceof tl_1.Api.MessageMediaWebPage) {\n    if (media.webpage instanceof tl_1.Api.WebPage) {\n      media = media.webpage.document || media.webpage.photo;\n    }\n  }\n  if (media instanceof tl_1.Api.MessageMediaPhoto || media instanceof tl_1.Api.Photo) {\n    return _downloadPhoto(client, media, outputFile, date, thumb, progressCallback);\n  } else if (media instanceof tl_1.Api.MessageMediaDocument || media instanceof tl_1.Api.Document) {\n    return _downloadDocument(client, media, outputFile, date, thumb, progressCallback, msgData);\n  } else if (media instanceof tl_1.Api.MessageMediaContact) {\n    return _downloadContact(client, media, {});\n  } else if (media instanceof tl_1.Api.WebDocument || media instanceof tl_1.Api.WebDocumentNoProxy) {\n    return _downloadWebDocument(client, media, {});\n  } else {\n    return buffer_1.Buffer.alloc(0);\n  }\n}\nexports.downloadMedia = downloadMedia;\n/** @hidden */\nasync function _downloadDocument(client, doc, outputFile, date, thumb, progressCallback, msgData) {\n  if (doc instanceof tl_1.Api.MessageMediaDocument) {\n    if (!doc.document) {\n      return buffer_1.Buffer.alloc(0);\n    }\n    doc = doc.document;\n  }\n  if (!(doc instanceof tl_1.Api.Document)) {\n    return buffer_1.Buffer.alloc(0);\n  }\n  let size;\n  if (thumb == undefined) {\n    outputFile = getProperFilename(outputFile, \"document\", \".\" + (__1.utils.getExtension(doc) || \"bin\"), date);\n  } else {\n    outputFile = getProperFilename(outputFile, \"photo\", \".jpg\", date);\n    size = getThumb(doc.thumbs || [], thumb);\n    if (size instanceof tl_1.Api.PhotoCachedSize || size instanceof tl_1.Api.PhotoStrippedSize) {\n      return _downloadCachedPhotoSize(size, outputFile);\n    }\n  }\n  return await downloadFileV2(client, new tl_1.Api.InputDocumentFileLocation({\n    id: doc.id,\n    accessHash: doc.accessHash,\n    fileReference: doc.fileReference,\n    thumbSize: size && \"type\" in size ? size.type : \"\"\n  }), {\n    outputFile: outputFile,\n    fileSize: size && \"size\" in size ? (0, big_integer_1.default)(size.size) : doc.size,\n    progressCallback: progressCallback,\n    msgData: msgData\n  });\n}\nexports._downloadDocument = _downloadDocument;\n/** @hidden */\nasync function _downloadContact(client, media, args) {\n  throw new Error(\"not implemented\");\n}\nexports._downloadContact = _downloadContact;\n/** @hidden */\nasync function _downloadWebDocument(client, media, args) {\n  throw new Error(\"not implemented\");\n}\nexports._downloadWebDocument = _downloadWebDocument;\nfunction pickFileSize(sizes, sizeType) {\n  if (!sizeType || !sizes || !sizes.length) {\n    return undefined;\n  }\n  const indexOfSize = sizeTypes.indexOf(sizeType);\n  let size;\n  for (let i = indexOfSize; i < sizeTypes.length; i++) {\n    size = sizes.find(s => s.type === sizeTypes[i]);\n    if (size && !(size instanceof tl_1.Api.PhotoPathSize)) {\n      return size;\n    }\n  }\n  return undefined;\n}\n/** @hidden */\nfunction getThumb(thumbs, thumb) {\n  function sortThumb(thumb) {\n    if (thumb instanceof tl_1.Api.PhotoStrippedSize) {\n      return thumb.bytes.length;\n    }\n    if (thumb instanceof tl_1.Api.PhotoCachedSize) {\n      return thumb.bytes.length;\n    }\n    if (thumb instanceof tl_1.Api.PhotoSize) {\n      return thumb.size;\n    }\n    if (thumb instanceof tl_1.Api.PhotoSizeProgressive) {\n      return Math.max(...thumb.sizes);\n    }\n    if (thumb instanceof tl_1.Api.VideoSize) {\n      return thumb.size;\n    }\n    return 0;\n  }\n  thumbs = thumbs.sort((a, b) => sortThumb(a) - sortThumb(b));\n  const correctThumbs = [];\n  for (const t of thumbs) {\n    if (!(t instanceof tl_1.Api.PhotoPathSize)) {\n      correctThumbs.push(t);\n    }\n  }\n  if (thumb == undefined) {\n    return correctThumbs.pop();\n  } else if (typeof thumb == \"number\") {\n    return correctThumbs[thumb];\n  } else if (typeof thumb == \"string\") {\n    for (const t of correctThumbs) {\n      if (\"type\" in t && t.type == thumb) {\n        return t;\n      }\n    }\n  } else if (thumb instanceof tl_1.Api.PhotoSize || thumb instanceof tl_1.Api.PhotoCachedSize || thumb instanceof tl_1.Api.PhotoStrippedSize || thumb instanceof tl_1.Api.VideoSize) {\n    return thumb;\n  }\n}\n/** @hidden */\nasync function _downloadCachedPhotoSize(size, outputFile) {\n  // No need to download anything, simply write the bytes\n  let data;\n  if (size instanceof tl_1.Api.PhotoStrippedSize) {\n    data = (0, Utils_1.strippedPhotoToJpg)(size.bytes);\n  } else {\n    data = size.bytes;\n  }\n  const writer = getWriter(outputFile);\n  try {\n    await writer.write(data);\n  } finally {\n    closeWriter(writer);\n  }\n  return returnWriterValue(writer);\n}\nexports._downloadCachedPhotoSize = _downloadCachedPhotoSize;\n/** @hidden */\nfunction getProperFilename(file, fileType, extension, date) {\n  if (!file || typeof file != \"string\") {\n    return file;\n  }\n  if (fs.existsSync(file) && fs.lstatSync(file).isDirectory()) {\n    let fullName = fileType + date + extension;\n    return path_1.default.join(file, fullName);\n  }\n  return file;\n}\n/** @hidden */\nasync function _downloadPhoto(client, photo, file, date, thumb, progressCallback) {\n  if (photo instanceof tl_1.Api.MessageMediaPhoto) {\n    if (photo.photo instanceof tl_1.Api.PhotoEmpty || !photo.photo) {\n      return buffer_1.Buffer.alloc(0);\n    }\n    photo = photo.photo;\n  }\n  if (!(photo instanceof tl_1.Api.Photo)) {\n    return buffer_1.Buffer.alloc(0);\n  }\n  const photoSizes = [...(photo.sizes || []), ...(photo.videoSizes || [])];\n  const size = getThumb(photoSizes, thumb);\n  if (!size || size instanceof tl_1.Api.PhotoSizeEmpty) {\n    return buffer_1.Buffer.alloc(0);\n  }\n  if (!date) {\n    date = Date.now();\n  }\n  file = getProperFilename(file, \"photo\", \".jpg\", date);\n  if (size instanceof tl_1.Api.PhotoCachedSize || size instanceof tl_1.Api.PhotoStrippedSize) {\n    return _downloadCachedPhotoSize(size, file);\n  }\n  let fileSize;\n  if (size instanceof tl_1.Api.PhotoSizeProgressive) {\n    fileSize = Math.max(...size.sizes);\n  } else {\n    fileSize = \"size\" in size ? size.size : 512;\n  }\n  return downloadFileV2(client, new tl_1.Api.InputPhotoFileLocation({\n    id: photo.id,\n    accessHash: photo.accessHash,\n    fileReference: photo.fileReference,\n    thumbSize: \"type\" in size ? size.type : \"\"\n  }), {\n    outputFile: file,\n    fileSize: (0, big_integer_1.default)(fileSize),\n    progressCallback: progressCallback,\n    dcId: photo.dcId\n  });\n}\nexports._downloadPhoto = _downloadPhoto;\n/** @hidden */\nasync function downloadProfilePhoto(client, entity, fileParams) {\n  let photo;\n  if (typeof entity == \"object\" && \"photo\" in entity) {\n    photo = entity.photo;\n  } else {\n    entity = await client.getEntity(entity);\n    if (\"photo\" in entity) {\n      photo = entity.photo;\n    } else {\n      throw new Error(`Could not get photo from ${entity ? entity.className : undefined}`);\n    }\n  }\n  let dcId;\n  let loc;\n  if (photo instanceof tl_1.Api.UserProfilePhoto || photo instanceof tl_1.Api.ChatPhoto) {\n    dcId = photo.dcId;\n    loc = new tl_1.Api.InputPeerPhotoFileLocation({\n      peer: __1.utils.getInputPeer(entity),\n      photoId: photo.photoId,\n      big: fileParams.isBig\n    });\n  } else {\n    return buffer_1.Buffer.alloc(0);\n  }\n  return client.downloadFile(loc, {\n    outputFile: fileParams.outputFile,\n    dcId\n  });\n}\nexports.downloadProfilePhoto = downloadProfilePhoto;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","__asyncValues","Symbol","asyncIterator","TypeError","i","__values","iterator","verb","n","Promise","resolve","reject","settle","done","d","then","__importDefault","exports","downloadProfilePhoto","_downloadPhoto","_downloadCachedPhotoSize","_downloadWebDocument","_downloadContact","_downloadDocument","downloadMedia","downloadFileV2","iterDownload","GenericDownloadIter","DirectDownloadIter","buffer_1","require","tl_1","Utils_1","Helpers_1","__1","requestIter_1","errors_1","fs_1","extensions_1","fs","path_1","big_integer_1","sizeTypes","MIN_CHUNK_SIZE","DEFAULT_CHUNK_SIZE","ONE_MB","REQUEST_TIMEOUT","DISCONNECT_SLEEP","TIMED_OUT_SLEEP","MAX_CHUNK_SIZE","RequestIter","constructor","arguments","_timedOut","_init","fileLocation","dcId","offset","stride","chunkSize","requestSize","fileSize","msgData","request","Api","upload","GetFile","location","limit","total","_stride","_chunkSize","_lastPart","_sender","client","getSender","_loadNextChunk","current","_request","buffer","push","length","left","close","add","invokeWithSender","FileCdnRedirect","Error","bytes","e","errorMessage","_log","warn","info","sleep","FileMigrateError","newDc","debug","data","Buffer","alloc","bad","toJSNumber","before","subtract","concat","slice","pop","file","default","zero","utils","getFileInfo","size","Math","floor","divide","cls","eq","getWriter","outputFile","isBuffer","BinaryWriter","createWriteStream","closeWriter","writer","returnWriterValue","getValue","WriteStream","path","from","inputLocation","partSizeKb","progressCallback","e_1","_a","getAppropriatedPartSize","partSize","downloaded","_b","_c","next","chunk","write","e_1_1","error","return","Foreman","maxWorkers","activeWorkers","requestWorker","deferred","createDeferred","promise","releaseWorker","_resolve","messageOrMedia","thumb","date","media","Message","inputChat","id","Date","now","MessageMediaWebPage","webpage","WebPage","document","photo","MessageMediaPhoto","Photo","MessageMediaDocument","Document","MessageMediaContact","WebDocument","WebDocumentNoProxy","doc","getProperFilename","getExtension","getThumb","thumbs","PhotoCachedSize","PhotoStrippedSize","InputDocumentFileLocation","accessHash","fileReference","thumbSize","type","args","pickFileSize","sizes","sizeType","indexOfSize","indexOf","find","s","PhotoPathSize","sortThumb","PhotoSize","PhotoSizeProgressive","max","VideoSize","sort","a","b","correctThumbs","t","strippedPhotoToJpg","fileType","extension","existsSync","lstatSync","isDirectory","fullName","join","PhotoEmpty","photoSizes","videoSizes","PhotoSizeEmpty","InputPhotoFileLocation","entity","fileParams","getEntity","className","loc","UserProfilePhoto","ChatPhoto","InputPeerPhotoFileLocation","peer","getInputPeer","photoId","big","isBig","downloadFile"],"sources":["C:/Users/Muhammed/Desktop/REACT_JS/dene-gramjs/node_modules/telegram/client/downloads.js"],"sourcesContent":["\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.downloadProfilePhoto = exports._downloadPhoto = exports._downloadCachedPhotoSize = exports._downloadWebDocument = exports._downloadContact = exports._downloadDocument = exports.downloadMedia = exports.downloadFileV2 = exports.iterDownload = exports.GenericDownloadIter = exports.DirectDownloadIter = void 0;\r\nconst buffer_1 = require(\"buffer/\");\r\nconst tl_1 = require(\"../tl\");\r\nconst Utils_1 = require(\"../Utils\");\r\nconst Helpers_1 = require(\"../Helpers\");\r\nconst __1 = require(\"../\");\r\nconst requestIter_1 = require(\"../requestIter\");\r\nconst errors_1 = require(\"../errors\");\r\nconst fs_1 = require(\"./fs\");\r\nconst extensions_1 = require(\"../extensions\");\r\nconst fs = __importStar(require(\"./fs\"));\r\nconst path_1 = __importDefault(require(\"./path\"));\r\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\r\n// All types\r\nconst sizeTypes = [\"w\", \"y\", \"d\", \"x\", \"c\", \"m\", \"b\", \"a\", \"s\"];\r\n// Chunk sizes for `upload.getFile` must be multiple of the smallest size\r\nconst MIN_CHUNK_SIZE = 4096;\r\nconst DEFAULT_CHUNK_SIZE = 64; // kb\r\nconst ONE_MB = 1024 * 1024;\r\nconst REQUEST_TIMEOUT = 15000;\r\nconst DISCONNECT_SLEEP = 1000;\r\nconst TIMED_OUT_SLEEP = 1000;\r\nconst MAX_CHUNK_SIZE = 512 * 1024;\r\nclass DirectDownloadIter extends requestIter_1.RequestIter {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._timedOut = false;\r\n    }\r\n    async _init({ fileLocation, dcId, offset, stride, chunkSize, requestSize, fileSize, msgData, }) {\r\n        this.request = new tl_1.Api.upload.GetFile({\r\n            location: fileLocation,\r\n            offset,\r\n            limit: requestSize,\r\n        });\r\n        this.total = fileSize;\r\n        this._stride = stride;\r\n        this._chunkSize = chunkSize;\r\n        this._lastPart = undefined;\r\n        //this._msgData = msgData;\r\n        this._timedOut = false;\r\n        this._sender = await this.client.getSender(dcId);\r\n    }\r\n    async _loadNextChunk() {\r\n        const current = await this._request();\r\n        this.buffer.push(current);\r\n        if (current.length < this.request.limit) {\r\n            // we finished downloading\r\n            this.left = this.buffer.length;\r\n            await this.close();\r\n            return true;\r\n        }\r\n        else {\r\n            this.request.offset = this.request.offset.add(this._stride);\r\n        }\r\n    }\r\n    async _request() {\r\n        try {\r\n            this._sender = await this.client.getSender(this._sender.dcId);\r\n            const result = await this.client.invokeWithSender(this.request, this._sender);\r\n            this._timedOut = false;\r\n            if (result instanceof tl_1.Api.upload.FileCdnRedirect) {\r\n                throw new Error(\"CDN Not supported. Please Add an issue in github\");\r\n            }\r\n            return result.bytes;\r\n        }\r\n        catch (e) {\r\n            if (e.errorMessage == \"TIMEOUT\") {\r\n                if (this._timedOut) {\r\n                    this.client._log.warn(\"Got two timeouts in a row while downloading file\");\r\n                    throw e;\r\n                }\r\n                this._timedOut = true;\r\n                this.client._log.info(\"Got timeout while downloading file, retrying once\");\r\n                await (0, Helpers_1.sleep)(TIMED_OUT_SLEEP);\r\n                return await this._request();\r\n            }\r\n            else if (e instanceof errors_1.FileMigrateError) {\r\n                this.client._log.info(\"File lives in another DC\");\r\n                this._sender = await this.client.getSender(e.newDc);\r\n                return await this._request();\r\n            }\r\n            else if (e.errorMessage == \"FILEREF_UPGRADE_NEEDED\") {\r\n                // TODO later\r\n                throw e;\r\n            }\r\n            else {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n    async close() {\r\n        this.client._log.debug(\"Finished downloading file ...\");\r\n    }\r\n    [Symbol.asyncIterator]() {\r\n        return super[Symbol.asyncIterator]();\r\n    }\r\n}\r\nexports.DirectDownloadIter = DirectDownloadIter;\r\nclass GenericDownloadIter extends DirectDownloadIter {\r\n    async _loadNextChunk() {\r\n        // 1. Fetch enough for one chunk\r\n        let data = buffer_1.Buffer.alloc(0);\r\n        //  1.1. ``bad`` is how much into the data we have we need to offset\r\n        const bad = this.request.offset.mod(this.request.limit).toJSNumber();\r\n        const before = this.request.offset;\r\n        // 1.2. We have to fetch from a valid offset, so remove that bad part\r\n        this.request.offset = this.request.offset.subtract(bad);\r\n        let done = false;\r\n        while (!done && data.length - bad < this._chunkSize) {\r\n            const current = await this._request();\r\n            this.request.offset = this.request.offset.add(this.request.limit);\r\n            data = buffer_1.Buffer.concat([data, current]);\r\n            done = current.length < this.request.limit;\r\n        }\r\n        // 1.3 Restore our last desired offset\r\n        this.request.offset = before;\r\n        // 2. Fill the buffer with the data we have\r\n        // 2.1. The current chunk starts at ``bad`` offset into the data,\r\n        //  and each new chunk is ``stride`` bytes apart of the other\r\n        for (let i = bad; i < data.length; i += this._stride) {\r\n            this.buffer.push(data.slice(i, i + this._chunkSize));\r\n            // 2.2. We will yield this offset, so move to the next one\r\n            this.request.offset = this.request.offset.add(this._stride);\r\n        }\r\n        // 2.3. If we are in the last chunk, we will return the last partial data\r\n        if (done) {\r\n            this.left = this.buffer.length;\r\n            await this.close();\r\n            return;\r\n        }\r\n        // 2.4 If we are not done, we can't return incomplete chunks.\r\n        if (this.buffer[this.buffer.length - 1].length != this._chunkSize) {\r\n            this._lastPart = this.buffer.pop();\r\n            //   3. Be careful with the offsets. Re-fetching a bit of data\r\n            //   is fine, since it greatly simplifies things.\r\n            // TODO Try to not re-fetch data\r\n            this.request.offset = this.request.offset.subtract(this._stride);\r\n        }\r\n    }\r\n}\r\nexports.GenericDownloadIter = GenericDownloadIter;\r\n/** @hidden */\r\nfunction iterDownload(client, { file, offset = big_integer_1.default.zero, stride, limit, chunkSize, requestSize = MAX_CHUNK_SIZE, fileSize, dcId, msgData, }) {\r\n    // we're ignoring here to make it more flexible (which is probably a bad idea)\r\n    // @ts-ignore\r\n    const info = __1.utils.getFileInfo(file);\r\n    if (info.dcId != undefined) {\r\n        dcId = info.dcId;\r\n    }\r\n    if (fileSize == undefined) {\r\n        fileSize = info.size;\r\n    }\r\n    file = info.location;\r\n    if (chunkSize == undefined) {\r\n        chunkSize = requestSize;\r\n    }\r\n    if (limit == undefined && fileSize != undefined) {\r\n        limit = Math.floor(fileSize.add(chunkSize).subtract(1).divide(chunkSize).toJSNumber());\r\n    }\r\n    if (stride == undefined) {\r\n        stride = chunkSize;\r\n    }\r\n    else if (stride < chunkSize) {\r\n        throw new Error(\"Stride must be >= chunkSize\");\r\n    }\r\n    requestSize -= requestSize % MIN_CHUNK_SIZE;\r\n    if (requestSize < MIN_CHUNK_SIZE) {\r\n        requestSize = MIN_CHUNK_SIZE;\r\n    }\r\n    else if (requestSize > MAX_CHUNK_SIZE) {\r\n        requestSize = MAX_CHUNK_SIZE;\r\n    }\r\n    let cls;\r\n    if (chunkSize == requestSize &&\r\n        offset.divide(MAX_CHUNK_SIZE).eq(big_integer_1.default.zero) &&\r\n        stride % MIN_CHUNK_SIZE == 0 &&\r\n        (limit == undefined || offset.divide(limit).eq(big_integer_1.default.zero))) {\r\n        cls = DirectDownloadIter;\r\n        client._log.info(`Starting direct file download in chunks of ${requestSize} at ${offset}, stride ${stride}`);\r\n    }\r\n    else {\r\n        cls = GenericDownloadIter;\r\n        client._log.info(`Starting indirect file download in chunks of ${requestSize} at ${offset}, stride ${stride}`);\r\n    }\r\n    return new cls(client, limit, {}, {\r\n        fileLocation: file,\r\n        dcId,\r\n        offset,\r\n        stride,\r\n        chunkSize,\r\n        requestSize,\r\n        fileSize,\r\n        msgData,\r\n    });\r\n}\r\nexports.iterDownload = iterDownload;\r\nfunction getWriter(outputFile) {\r\n    if (!outputFile || buffer_1.Buffer.isBuffer(outputFile)) {\r\n        return new extensions_1.BinaryWriter(buffer_1.Buffer.alloc(0));\r\n    }\r\n    else if (typeof outputFile == \"string\") {\r\n        // We want to make sure that the path exists.\r\n        return (0, fs_1.createWriteStream)(outputFile);\r\n    }\r\n    else {\r\n        return outputFile;\r\n    }\r\n}\r\nfunction closeWriter(writer) {\r\n    if (\"close\" in writer && writer.close) {\r\n        writer.close();\r\n    }\r\n}\r\nfunction returnWriterValue(writer) {\r\n    if (writer instanceof extensions_1.BinaryWriter) {\r\n        return writer.getValue();\r\n    }\r\n    if (writer instanceof fs.WriteStream) {\r\n        if (typeof writer.path == \"string\") {\r\n            return path_1.default.resolve(writer.path);\r\n        }\r\n        else {\r\n            return buffer_1.Buffer.from(writer.path);\r\n        }\r\n    }\r\n}\r\n/** @hidden */\r\nasync function downloadFileV2(client, inputLocation, { outputFile = undefined, partSizeKb = undefined, fileSize = undefined, progressCallback = undefined, dcId = undefined, msgData = undefined, }) {\r\n    var e_1, _a;\r\n    if (!partSizeKb) {\r\n        if (!fileSize) {\r\n            partSizeKb = 64;\r\n        }\r\n        else {\r\n            partSizeKb = __1.utils.getAppropriatedPartSize(fileSize);\r\n        }\r\n    }\r\n    const partSize = Math.floor(partSizeKb * 1024);\r\n    if (partSize % MIN_CHUNK_SIZE != 0) {\r\n        throw new Error(\"The part size must be evenly divisible by 4096\");\r\n    }\r\n    const writer = getWriter(outputFile);\r\n    let downloaded = big_integer_1.default.zero;\r\n    try {\r\n        try {\r\n            for (var _b = __asyncValues(iterDownload(client, {\r\n                file: inputLocation,\r\n                requestSize: partSize,\r\n                dcId: dcId,\r\n                msgData: msgData,\r\n            })), _c; _c = await _b.next(), !_c.done;) {\r\n                const chunk = _c.value;\r\n                await writer.write(chunk);\r\n                if (progressCallback) {\r\n                    await progressCallback(downloaded, (0, big_integer_1.default)(fileSize || big_integer_1.default.zero));\r\n                }\r\n                downloaded = downloaded.add(chunk.length);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        return returnWriterValue(writer);\r\n    }\r\n    finally {\r\n        closeWriter(writer);\r\n    }\r\n}\r\nexports.downloadFileV2 = downloadFileV2;\r\nclass Foreman {\r\n    constructor(maxWorkers) {\r\n        this.maxWorkers = maxWorkers;\r\n        this.activeWorkers = 0;\r\n    }\r\n    requestWorker() {\r\n        this.activeWorkers++;\r\n        if (this.activeWorkers > this.maxWorkers) {\r\n            this.deferred = createDeferred();\r\n            return this.deferred.promise;\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    releaseWorker() {\r\n        this.activeWorkers--;\r\n        if (this.deferred && this.activeWorkers <= this.maxWorkers) {\r\n            this.deferred.resolve();\r\n        }\r\n    }\r\n}\r\nfunction createDeferred() {\r\n    let resolve;\r\n    const promise = new Promise((_resolve) => {\r\n        resolve = _resolve;\r\n    });\r\n    return {\r\n        promise,\r\n        resolve: resolve,\r\n    };\r\n}\r\n/** @hidden */\r\nasync function downloadMedia(client, messageOrMedia, outputFile, thumb, progressCallback) {\r\n    /*\r\n      Downloading large documents may be slow enough to require a new file reference\r\n      to be obtained mid-download. Store (input chat, message id) so that the message\r\n      can be re-fetched.\r\n     */\r\n    let msgData;\r\n    let date;\r\n    let media;\r\n    if (messageOrMedia instanceof tl_1.Api.Message) {\r\n        media = messageOrMedia.media;\r\n        date = messageOrMedia.date;\r\n        msgData = messageOrMedia.inputChat\r\n            ? [messageOrMedia.inputChat, messageOrMedia.id]\r\n            : undefined;\r\n    }\r\n    else {\r\n        media = messageOrMedia;\r\n        date = Date.now();\r\n    }\r\n    if (typeof media == \"string\") {\r\n        throw new Error(\"not implemented\");\r\n    }\r\n    if (media instanceof tl_1.Api.MessageMediaWebPage) {\r\n        if (media.webpage instanceof tl_1.Api.WebPage) {\r\n            media = media.webpage.document || media.webpage.photo;\r\n        }\r\n    }\r\n    if (media instanceof tl_1.Api.MessageMediaPhoto || media instanceof tl_1.Api.Photo) {\r\n        return _downloadPhoto(client, media, outputFile, date, thumb, progressCallback);\r\n    }\r\n    else if (media instanceof tl_1.Api.MessageMediaDocument ||\r\n        media instanceof tl_1.Api.Document) {\r\n        return _downloadDocument(client, media, outputFile, date, thumb, progressCallback, msgData);\r\n    }\r\n    else if (media instanceof tl_1.Api.MessageMediaContact) {\r\n        return _downloadContact(client, media, {});\r\n    }\r\n    else if (media instanceof tl_1.Api.WebDocument ||\r\n        media instanceof tl_1.Api.WebDocumentNoProxy) {\r\n        return _downloadWebDocument(client, media, {});\r\n    }\r\n    else {\r\n        return buffer_1.Buffer.alloc(0);\r\n    }\r\n}\r\nexports.downloadMedia = downloadMedia;\r\n/** @hidden */\r\nasync function _downloadDocument(client, doc, outputFile, date, thumb, progressCallback, msgData) {\r\n    if (doc instanceof tl_1.Api.MessageMediaDocument) {\r\n        if (!doc.document) {\r\n            return buffer_1.Buffer.alloc(0);\r\n        }\r\n        doc = doc.document;\r\n    }\r\n    if (!(doc instanceof tl_1.Api.Document)) {\r\n        return buffer_1.Buffer.alloc(0);\r\n    }\r\n    let size;\r\n    if (thumb == undefined) {\r\n        outputFile = getProperFilename(outputFile, \"document\", \".\" + (__1.utils.getExtension(doc) || \"bin\"), date);\r\n    }\r\n    else {\r\n        outputFile = getProperFilename(outputFile, \"photo\", \".jpg\", date);\r\n        size = getThumb(doc.thumbs || [], thumb);\r\n        if (size instanceof tl_1.Api.PhotoCachedSize ||\r\n            size instanceof tl_1.Api.PhotoStrippedSize) {\r\n            return _downloadCachedPhotoSize(size, outputFile);\r\n        }\r\n    }\r\n    return await downloadFileV2(client, new tl_1.Api.InputDocumentFileLocation({\r\n        id: doc.id,\r\n        accessHash: doc.accessHash,\r\n        fileReference: doc.fileReference,\r\n        thumbSize: size && \"type\" in size ? size.type : \"\",\r\n    }), {\r\n        outputFile: outputFile,\r\n        fileSize: size && \"size\" in size ? (0, big_integer_1.default)(size.size) : doc.size,\r\n        progressCallback: progressCallback,\r\n        msgData: msgData,\r\n    });\r\n}\r\nexports._downloadDocument = _downloadDocument;\r\n/** @hidden */\r\nasync function _downloadContact(client, media, args) {\r\n    throw new Error(\"not implemented\");\r\n}\r\nexports._downloadContact = _downloadContact;\r\n/** @hidden */\r\nasync function _downloadWebDocument(client, media, args) {\r\n    throw new Error(\"not implemented\");\r\n}\r\nexports._downloadWebDocument = _downloadWebDocument;\r\nfunction pickFileSize(sizes, sizeType) {\r\n    if (!sizeType || !sizes || !sizes.length) {\r\n        return undefined;\r\n    }\r\n    const indexOfSize = sizeTypes.indexOf(sizeType);\r\n    let size;\r\n    for (let i = indexOfSize; i < sizeTypes.length; i++) {\r\n        size = sizes.find((s) => s.type === sizeTypes[i]);\r\n        if (size && !(size instanceof tl_1.Api.PhotoPathSize)) {\r\n            return size;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n/** @hidden */\r\nfunction getThumb(thumbs, thumb) {\r\n    function sortThumb(thumb) {\r\n        if (thumb instanceof tl_1.Api.PhotoStrippedSize) {\r\n            return thumb.bytes.length;\r\n        }\r\n        if (thumb instanceof tl_1.Api.PhotoCachedSize) {\r\n            return thumb.bytes.length;\r\n        }\r\n        if (thumb instanceof tl_1.Api.PhotoSize) {\r\n            return thumb.size;\r\n        }\r\n        if (thumb instanceof tl_1.Api.PhotoSizeProgressive) {\r\n            return Math.max(...thumb.sizes);\r\n        }\r\n        if (thumb instanceof tl_1.Api.VideoSize) {\r\n            return thumb.size;\r\n        }\r\n        return 0;\r\n    }\r\n    thumbs = thumbs.sort((a, b) => sortThumb(a) - sortThumb(b));\r\n    const correctThumbs = [];\r\n    for (const t of thumbs) {\r\n        if (!(t instanceof tl_1.Api.PhotoPathSize)) {\r\n            correctThumbs.push(t);\r\n        }\r\n    }\r\n    if (thumb == undefined) {\r\n        return correctThumbs.pop();\r\n    }\r\n    else if (typeof thumb == \"number\") {\r\n        return correctThumbs[thumb];\r\n    }\r\n    else if (typeof thumb == \"string\") {\r\n        for (const t of correctThumbs) {\r\n            if (\"type\" in t && t.type == thumb) {\r\n                return t;\r\n            }\r\n        }\r\n    }\r\n    else if (thumb instanceof tl_1.Api.PhotoSize ||\r\n        thumb instanceof tl_1.Api.PhotoCachedSize ||\r\n        thumb instanceof tl_1.Api.PhotoStrippedSize ||\r\n        thumb instanceof tl_1.Api.VideoSize) {\r\n        return thumb;\r\n    }\r\n}\r\n/** @hidden */\r\nasync function _downloadCachedPhotoSize(size, outputFile) {\r\n    // No need to download anything, simply write the bytes\r\n    let data;\r\n    if (size instanceof tl_1.Api.PhotoStrippedSize) {\r\n        data = (0, Utils_1.strippedPhotoToJpg)(size.bytes);\r\n    }\r\n    else {\r\n        data = size.bytes;\r\n    }\r\n    const writer = getWriter(outputFile);\r\n    try {\r\n        await writer.write(data);\r\n    }\r\n    finally {\r\n        closeWriter(writer);\r\n    }\r\n    return returnWriterValue(writer);\r\n}\r\nexports._downloadCachedPhotoSize = _downloadCachedPhotoSize;\r\n/** @hidden */\r\nfunction getProperFilename(file, fileType, extension, date) {\r\n    if (!file || typeof file != \"string\") {\r\n        return file;\r\n    }\r\n    if (fs.existsSync(file) && fs.lstatSync(file).isDirectory()) {\r\n        let fullName = fileType + date + extension;\r\n        return path_1.default.join(file, fullName);\r\n    }\r\n    return file;\r\n}\r\n/** @hidden */\r\nasync function _downloadPhoto(client, photo, file, date, thumb, progressCallback) {\r\n    if (photo instanceof tl_1.Api.MessageMediaPhoto) {\r\n        if (photo.photo instanceof tl_1.Api.PhotoEmpty || !photo.photo) {\r\n            return buffer_1.Buffer.alloc(0);\r\n        }\r\n        photo = photo.photo;\r\n    }\r\n    if (!(photo instanceof tl_1.Api.Photo)) {\r\n        return buffer_1.Buffer.alloc(0);\r\n    }\r\n    const photoSizes = [...(photo.sizes || []), ...(photo.videoSizes || [])];\r\n    const size = getThumb(photoSizes, thumb);\r\n    if (!size || size instanceof tl_1.Api.PhotoSizeEmpty) {\r\n        return buffer_1.Buffer.alloc(0);\r\n    }\r\n    if (!date) {\r\n        date = Date.now();\r\n    }\r\n    file = getProperFilename(file, \"photo\", \".jpg\", date);\r\n    if (size instanceof tl_1.Api.PhotoCachedSize ||\r\n        size instanceof tl_1.Api.PhotoStrippedSize) {\r\n        return _downloadCachedPhotoSize(size, file);\r\n    }\r\n    let fileSize;\r\n    if (size instanceof tl_1.Api.PhotoSizeProgressive) {\r\n        fileSize = Math.max(...size.sizes);\r\n    }\r\n    else {\r\n        fileSize = \"size\" in size ? size.size : 512;\r\n    }\r\n    return downloadFileV2(client, new tl_1.Api.InputPhotoFileLocation({\r\n        id: photo.id,\r\n        accessHash: photo.accessHash,\r\n        fileReference: photo.fileReference,\r\n        thumbSize: \"type\" in size ? size.type : \"\",\r\n    }), {\r\n        outputFile: file,\r\n        fileSize: (0, big_integer_1.default)(fileSize),\r\n        progressCallback: progressCallback,\r\n        dcId: photo.dcId,\r\n    });\r\n}\r\nexports._downloadPhoto = _downloadPhoto;\r\n/** @hidden */\r\nasync function downloadProfilePhoto(client, entity, fileParams) {\r\n    let photo;\r\n    if (typeof entity == \"object\" && \"photo\" in entity) {\r\n        photo = entity.photo;\r\n    }\r\n    else {\r\n        entity = await client.getEntity(entity);\r\n        if (\"photo\" in entity) {\r\n            photo = entity.photo;\r\n        }\r\n        else {\r\n            throw new Error(`Could not get photo from ${entity ? entity.className : undefined}`);\r\n        }\r\n    }\r\n    let dcId;\r\n    let loc;\r\n    if (photo instanceof tl_1.Api.UserProfilePhoto ||\r\n        photo instanceof tl_1.Api.ChatPhoto) {\r\n        dcId = photo.dcId;\r\n        loc = new tl_1.Api.InputPeerPhotoFileLocation({\r\n            peer: __1.utils.getInputPeer(entity),\r\n            photoId: photo.photoId,\r\n            big: fileParams.isBig,\r\n        });\r\n    }\r\n    else {\r\n        return buffer_1.Buffer.alloc(0);\r\n    }\r\n    return client.downloadFile(loc, {\r\n        outputFile: fileParams.outputFile,\r\n        dcId,\r\n    });\r\n}\r\nexports.downloadProfilePhoto = downloadProfilePhoto;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}