{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sendFile = exports._sendAlbum = exports._fileToMedia = exports.uploadFile = exports.CustomFile = void 0;\nconst buffer_1 = require(\"buffer/\");\nconst tl_1 = require(\"../tl\");\nconst Helpers_1 = require(\"../Helpers\");\nconst Utils_1 = require(\"../Utils\");\nconst path_1 = __importDefault(require(\"./path\"));\nconst fs_1 = require(\"./fs\");\nconst index_1 = require(\"../index\");\nconst messageParse_1 = require(\"./messageParse\");\nconst messages_1 = require(\"./messages\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\n/**\r\n * A custom file class that mimics the browser's File class.<br/>\r\n * You should use this whenever you want to upload a file.\r\n */\nclass CustomFile {\n  constructor(name, size, path, buffer) {\n    this.name = name;\n    this.size = size;\n    this.path = path;\n    this.buffer = buffer;\n  }\n}\nexports.CustomFile = CustomFile;\nclass CustomBuffer {\n  constructor(options) {\n    this.options = options;\n    if (!options.buffer && !options.filePath) {\n      throw new Error(\"Either one of `buffer` or `filePath` should be specified\");\n    }\n  }\n  async slice(begin, end) {\n    const {\n      buffer,\n      filePath\n    } = this.options;\n    if (buffer) {\n      return buffer.slice(begin, end);\n    } else if (filePath) {\n      const buffSize = end - begin;\n      const buff = buffer_1.Buffer.alloc(buffSize);\n      const fHandle = await fs_1.promises.open(filePath, \"r\");\n      await fHandle.read(buff, 0, buffSize, begin);\n      await fHandle.close();\n      return buffer_1.Buffer.from(buff);\n    }\n    return buffer_1.Buffer.alloc(0);\n  }\n}\nconst KB_TO_BYTES = 1024;\nconst LARGE_FILE_THRESHOLD = 10 * 1024 * 1024;\nconst UPLOAD_TIMEOUT = 15 * 1000;\nconst DISCONNECT_SLEEP = 1000;\nconst BUFFER_SIZE_2GB = 2 ** 31;\nasync function getFileBuffer(file, fileSize, maxBufferSize) {\n  const options = {};\n  if (fileSize > maxBufferSize && file instanceof CustomFile) {\n    options.filePath = file.path;\n  } else {\n    options.buffer = buffer_1.Buffer.from(await fileToBuffer(file));\n  }\n  return new CustomBuffer(options);\n}\n/** @hidden */\nasync function uploadFile(client, fileParams) {\n  const {\n    file,\n    onProgress\n  } = fileParams;\n  let {\n    workers\n  } = fileParams;\n  const {\n    name,\n    size\n  } = file;\n  const fileId = (0, Helpers_1.readBigIntFromBuffer)((0, Helpers_1.generateRandomBytes)(8), true, true);\n  const isLarge = size > LARGE_FILE_THRESHOLD;\n  const partSize = (0, Utils_1.getAppropriatedPartSize)((0, big_integer_1.default)(size)) * KB_TO_BYTES;\n  const partCount = Math.floor((size + partSize - 1) / partSize);\n  const buffer = await getFileBuffer(file, size, fileParams.maxBufferSize || BUFFER_SIZE_2GB - 1);\n  // Make sure a new sender can be created before starting upload\n  await client.getSender(client.session.dcId);\n  if (!workers || !size) {\n    workers = 1;\n  }\n  if (workers >= partCount) {\n    workers = partCount;\n  }\n  let progress = 0;\n  if (onProgress) {\n    onProgress(progress);\n  }\n  for (let i = 0; i < partCount; i += workers) {\n    const sendingParts = [];\n    let end = i + workers;\n    if (end > partCount) {\n      end = partCount;\n    }\n    for (let j = i; j < end; j++) {\n      const bytes = await buffer.slice(j * partSize, (j + 1) * partSize);\n      // eslint-disable-next-line no-loop-func\n      sendingParts.push((async (jMemo, bytesMemo) => {\n        while (true) {\n          let sender;\n          try {\n            // We always upload from the DC we are in\n            sender = await client.getSender(client.session.dcId);\n            await sender.send(isLarge ? new tl_1.Api.upload.SaveBigFilePart({\n              fileId,\n              filePart: jMemo,\n              fileTotalParts: partCount,\n              bytes: bytesMemo\n            }) : new tl_1.Api.upload.SaveFilePart({\n              fileId,\n              filePart: jMemo,\n              bytes: bytesMemo\n            }));\n          } catch (err) {\n            if (sender && !sender.isConnected()) {\n              await (0, Helpers_1.sleep)(DISCONNECT_SLEEP);\n              continue;\n            } else if (err instanceof index_1.errors.FloodWaitError) {\n              await (0, Helpers_1.sleep)(err.seconds * 1000);\n              continue;\n            }\n            throw err;\n          }\n          if (onProgress) {\n            if (onProgress.isCanceled) {\n              throw new Error(\"USER_CANCELED\");\n            }\n            progress += 1 / partCount;\n            onProgress(progress);\n          }\n          break;\n        }\n      })(j, bytes));\n    }\n    await Promise.all(sendingParts);\n  }\n  return isLarge ? new tl_1.Api.InputFileBig({\n    id: fileId,\n    parts: partCount,\n    name\n  }) : new tl_1.Api.InputFile({\n    id: fileId,\n    parts: partCount,\n    name,\n    md5Checksum: \"\" // This is not a \"flag\", so not sure if we can make it optional.\n  });\n}\n\nexports.uploadFile = uploadFile;\n/** @hidden */\nasync function _fileToMedia(client, {\n  file,\n  forceDocument,\n  fileSize,\n  progressCallback,\n  attributes,\n  thumb,\n  voiceNote = false,\n  videoNote = false,\n  supportsStreaming = false,\n  mimeType,\n  asImage,\n  workers = 1\n}) {\n  if (!file) {\n    return {\n      fileHandle: undefined,\n      media: undefined,\n      image: undefined\n    };\n  }\n  const isImage = index_1.utils.isImage(file);\n  if (asImage == undefined) {\n    asImage = isImage && !forceDocument;\n  }\n  if (typeof file == \"object\" && !buffer_1.Buffer.isBuffer(file) && !(file instanceof tl_1.Api.InputFile) && !(file instanceof tl_1.Api.InputFileBig) && !(file instanceof CustomFile) && !(\"read\" in file)) {\n    try {\n      return {\n        fileHandle: undefined,\n        media: index_1.utils.getInputMedia(file, {\n          isPhoto: asImage,\n          attributes: attributes,\n          forceDocument: forceDocument,\n          voiceNote: voiceNote,\n          videoNote: videoNote,\n          supportsStreaming: supportsStreaming\n        }),\n        image: asImage\n      };\n    } catch (e) {\n      return {\n        fileHandle: undefined,\n        media: undefined,\n        image: isImage\n      };\n    }\n  }\n  let media;\n  let fileHandle;\n  let createdFile;\n  if (file instanceof tl_1.Api.InputFile || file instanceof tl_1.Api.InputFileBig) {\n    fileHandle = file;\n  } else if (typeof file == \"string\" && (file.startsWith(\"https://\") || file.startsWith(\"http://\"))) {\n    if (asImage) {\n      media = new tl_1.Api.InputMediaPhotoExternal({\n        url: file\n      });\n    } else {\n      media = new tl_1.Api.InputMediaDocumentExternal({\n        url: file\n      });\n    }\n  } else if (!(typeof file == \"string\") || (await fs_1.promises.lstat(file)).isFile()) {\n    if (typeof file == \"string\") {\n      createdFile = new CustomFile(path_1.default.basename(file), (await fs_1.promises.stat(file)).size, file);\n    } else if (typeof File !== \"undefined\" && file instanceof File || file instanceof CustomFile) {\n      createdFile = file;\n    } else {\n      let name;\n      if (\"name\" in file) {\n        // @ts-ignore\n        name = file.name;\n      } else {\n        name = \"unnamed\";\n      }\n      if (buffer_1.Buffer.isBuffer(file)) {\n        createdFile = new CustomFile(name, file.length, \"\", file);\n      }\n    }\n    if (!createdFile) {\n      throw new Error(`Could not create file from ${JSON.stringify(file)}`);\n    }\n    fileHandle = await uploadFile(client, {\n      file: createdFile,\n      onProgress: progressCallback,\n      workers: workers\n    });\n  } else {\n    throw new Error(`\"Not a valid path nor a url ${file}`);\n  }\n  if (media != undefined) {} else if (fileHandle == undefined) {\n    throw new Error(`Failed to convert ${file} to media. Not an existing file or an HTTP URL`);\n  } else if (asImage) {\n    media = new tl_1.Api.InputMediaUploadedPhoto({\n      file: fileHandle\n    });\n  } else {\n    // @ts-ignore\n    let res = index_1.utils.getAttributes(file, {\n      mimeType: mimeType,\n      attributes: attributes,\n      forceDocument: forceDocument && !isImage,\n      voiceNote: voiceNote,\n      videoNote: videoNote,\n      supportsStreaming: supportsStreaming,\n      thumb: thumb\n    });\n    attributes = res.attrs;\n    mimeType = res.mimeType;\n    let uploadedThumb;\n    if (!thumb) {\n      uploadedThumb = undefined;\n    } else {\n      // todo refactor\n      if (typeof thumb == \"string\") {\n        uploadedThumb = new CustomFile(path_1.default.basename(thumb), (await fs_1.promises.stat(thumb)).size, thumb);\n      } else if (typeof File !== \"undefined\" && thumb instanceof File) {\n        uploadedThumb = thumb;\n      } else {\n        let name;\n        if (\"name\" in thumb) {\n          name = thumb.name;\n        } else {\n          name = \"unnamed\";\n        }\n        if (buffer_1.Buffer.isBuffer(thumb)) {\n          uploadedThumb = new CustomFile(name, thumb.length, \"\", thumb);\n        }\n      }\n      if (!uploadedThumb) {\n        throw new Error(`Could not create file from ${file}`);\n      }\n      uploadedThumb = await uploadFile(client, {\n        file: uploadedThumb,\n        workers: 1\n      });\n    }\n    media = new tl_1.Api.InputMediaUploadedDocument({\n      file: fileHandle,\n      mimeType: mimeType,\n      attributes: attributes,\n      thumb: uploadedThumb,\n      forceFile: forceDocument && !isImage\n    });\n  }\n  return {\n    fileHandle: fileHandle,\n    media: media,\n    image: asImage\n  };\n}\nexports._fileToMedia = _fileToMedia;\n/** @hidden */\nasync function _sendAlbum(client, entity, {\n  file,\n  caption,\n  forceDocument = false,\n  fileSize,\n  clearDraft = false,\n  progressCallback,\n  replyTo,\n  attributes,\n  thumb,\n  parseMode,\n  voiceNote = false,\n  videoNote = false,\n  silent,\n  supportsStreaming = false,\n  scheduleDate,\n  workers = 1,\n  noforwards,\n  commentTo,\n  topMsgId\n}) {\n  entity = await client.getInputEntity(entity);\n  let files = [];\n  if (!Array.isArray(file)) {\n    files = [file];\n  } else {\n    files = file;\n  }\n  if (!Array.isArray(caption)) {\n    if (!caption) {\n      caption = \"\";\n    }\n    caption = [caption];\n  }\n  const captions = [];\n  for (const c of caption) {\n    captions.push(await (0, messageParse_1._parseMessageText)(client, c, parseMode));\n  }\n  if (commentTo != undefined) {\n    const discussionData = await (0, messages_1.getCommentData)(client, entity, commentTo);\n    entity = discussionData.entity;\n    replyTo = discussionData.replyTo;\n  } else {\n    replyTo = index_1.utils.getMessageId(replyTo);\n  }\n  if (!attributes) {\n    attributes = [];\n  }\n  let index = 0;\n  const albumFiles = [];\n  for (const file of files) {\n    let {\n      fileHandle,\n      media,\n      image\n    } = await _fileToMedia(client, {\n      file: file,\n      forceDocument: forceDocument,\n      fileSize: fileSize,\n      progressCallback: progressCallback,\n      // @ts-ignore\n      attributes: attributes[index],\n      thumb: thumb,\n      voiceNote: voiceNote,\n      videoNote: videoNote,\n      supportsStreaming: supportsStreaming,\n      workers: workers\n    });\n    index++;\n    if (media instanceof tl_1.Api.InputMediaUploadedPhoto || media instanceof tl_1.Api.InputMediaPhotoExternal) {\n      const r = await client.invoke(new tl_1.Api.messages.UploadMedia({\n        peer: entity,\n        media\n      }));\n      if (r instanceof tl_1.Api.MessageMediaPhoto) {\n        media = (0, Utils_1.getInputMedia)(r.photo);\n      }\n    } else if (media instanceof tl_1.Api.InputMediaUploadedDocument) {\n      const r = await client.invoke(new tl_1.Api.messages.UploadMedia({\n        peer: entity,\n        media\n      }));\n      if (r instanceof tl_1.Api.MessageMediaDocument) {\n        media = (0, Utils_1.getInputMedia)(r.document);\n      }\n    }\n    let text = \"\";\n    let msgEntities = [];\n    if (captions.length) {\n      [text, msgEntities] = captions.shift();\n    }\n    albumFiles.push(new tl_1.Api.InputSingleMedia({\n      media: media,\n      message: text,\n      entities: msgEntities\n    }));\n  }\n  let replyObject = undefined;\n  if (replyTo != undefined) {\n    replyObject = new tl_1.Api.InputReplyToMessage({\n      replyToMsgId: (0, Utils_1.getMessageId)(replyTo),\n      topMsgId: (0, Utils_1.getMessageId)(topMsgId)\n    });\n  }\n  const result = await client.invoke(new tl_1.Api.messages.SendMultiMedia({\n    peer: entity,\n    replyTo: replyObject,\n    multiMedia: albumFiles,\n    silent: silent,\n    scheduleDate: scheduleDate,\n    clearDraft: clearDraft,\n    noforwards: noforwards\n  }));\n  const randomIds = albumFiles.map(m => m.randomId);\n  return client._getResponseMessage(randomIds, result, entity);\n}\nexports._sendAlbum = _sendAlbum;\n/** @hidden */\nasync function sendFile(client, entity, {\n  file,\n  caption,\n  forceDocument = false,\n  fileSize,\n  clearDraft = false,\n  progressCallback,\n  replyTo,\n  attributes,\n  thumb,\n  parseMode,\n  formattingEntities,\n  voiceNote = false,\n  videoNote = false,\n  buttons,\n  silent,\n  supportsStreaming = false,\n  scheduleDate,\n  workers = 1,\n  noforwards,\n  commentTo,\n  topMsgId\n}) {\n  if (!file) {\n    throw new Error(\"You need to specify a file\");\n  }\n  if (!caption) {\n    caption = \"\";\n  }\n  entity = await client.getInputEntity(entity);\n  if (commentTo != undefined) {\n    const discussionData = await (0, messages_1.getCommentData)(client, entity, commentTo);\n    entity = discussionData.entity;\n    replyTo = discussionData.replyTo;\n  } else {\n    replyTo = index_1.utils.getMessageId(replyTo);\n  }\n  if (Array.isArray(file)) {\n    return await _sendAlbum(client, entity, {\n      file: file,\n      caption: caption,\n      replyTo: replyTo,\n      parseMode: parseMode,\n      attributes: attributes,\n      silent: silent,\n      scheduleDate: scheduleDate,\n      supportsStreaming: supportsStreaming,\n      clearDraft: clearDraft,\n      forceDocument: forceDocument,\n      noforwards: noforwards,\n      topMsgId: topMsgId\n    });\n  }\n  if (Array.isArray(caption)) {\n    caption = caption[0] || \"\";\n  }\n  let msgEntities;\n  if (formattingEntities != undefined) {\n    msgEntities = formattingEntities;\n  } else {\n    [caption, msgEntities] = await (0, messageParse_1._parseMessageText)(client, caption, parseMode);\n  }\n  const {\n    fileHandle,\n    media,\n    image\n  } = await _fileToMedia(client, {\n    file: file,\n    forceDocument: forceDocument,\n    fileSize: fileSize,\n    progressCallback: progressCallback,\n    // @ts-ignore\n    attributes: attributes,\n    thumb: thumb,\n    voiceNote: voiceNote,\n    videoNote: videoNote,\n    supportsStreaming: supportsStreaming,\n    workers: workers\n  });\n  if (media == undefined) {\n    throw new Error(`Cannot use ${file} as file.`);\n  }\n  const markup = client.buildReplyMarkup(buttons);\n  let replyObject = undefined;\n  if (replyTo != undefined) {\n    replyObject = new tl_1.Api.InputReplyToMessage({\n      replyToMsgId: (0, Utils_1.getMessageId)(replyTo),\n      topMsgId: (0, Utils_1.getMessageId)(topMsgId)\n    });\n  }\n  const request = new tl_1.Api.messages.SendMedia({\n    peer: entity,\n    media: media,\n    replyTo: replyObject,\n    message: caption,\n    entities: msgEntities,\n    replyMarkup: markup,\n    silent: silent,\n    scheduleDate: scheduleDate,\n    clearDraft: clearDraft,\n    noforwards: noforwards\n  });\n  const result = await client.invoke(request);\n  return client._getResponseMessage(request, result, entity);\n}\nexports.sendFile = sendFile;\nfunction fileToBuffer(file) {\n  if (typeof File !== \"undefined\" && file instanceof File) {\n    return new Response(file).arrayBuffer();\n  } else if (file instanceof CustomFile) {\n    if (file.buffer != undefined) {\n      return file.buffer;\n    } else {\n      return fs_1.promises.readFile(file.path);\n    }\n  } else {\n    throw new Error(\"Could not create buffer from file \" + file);\n  }\n}","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","sendFile","_sendAlbum","_fileToMedia","uploadFile","CustomFile","buffer_1","require","tl_1","Helpers_1","Utils_1","path_1","fs_1","index_1","messageParse_1","messages_1","big_integer_1","constructor","name","size","path","buffer","CustomBuffer","options","filePath","Error","slice","begin","end","buffSize","buff","Buffer","alloc","fHandle","promises","open","read","close","from","KB_TO_BYTES","LARGE_FILE_THRESHOLD","UPLOAD_TIMEOUT","DISCONNECT_SLEEP","BUFFER_SIZE_2GB","getFileBuffer","file","fileSize","maxBufferSize","fileToBuffer","client","fileParams","onProgress","workers","fileId","readBigIntFromBuffer","generateRandomBytes","isLarge","partSize","getAppropriatedPartSize","default","partCount","Math","floor","getSender","session","dcId","progress","i","sendingParts","j","bytes","push","jMemo","bytesMemo","sender","send","Api","upload","SaveBigFilePart","filePart","fileTotalParts","SaveFilePart","err","isConnected","sleep","errors","FloodWaitError","seconds","isCanceled","Promise","all","InputFileBig","id","parts","InputFile","md5Checksum","forceDocument","progressCallback","attributes","thumb","voiceNote","videoNote","supportsStreaming","mimeType","asImage","fileHandle","undefined","media","image","isImage","utils","isBuffer","getInputMedia","isPhoto","e","createdFile","startsWith","InputMediaPhotoExternal","url","InputMediaDocumentExternal","lstat","isFile","basename","stat","File","length","JSON","stringify","InputMediaUploadedPhoto","res","getAttributes","attrs","uploadedThumb","InputMediaUploadedDocument","forceFile","entity","caption","clearDraft","replyTo","parseMode","silent","scheduleDate","noforwards","commentTo","topMsgId","getInputEntity","files","Array","isArray","captions","c","_parseMessageText","discussionData","getCommentData","getMessageId","index","albumFiles","r","invoke","messages","UploadMedia","peer","MessageMediaPhoto","photo","MessageMediaDocument","document","text","msgEntities","shift","InputSingleMedia","message","entities","replyObject","InputReplyToMessage","replyToMsgId","result","SendMultiMedia","multiMedia","randomIds","map","m","randomId","_getResponseMessage","formattingEntities","buttons","markup","buildReplyMarkup","request","SendMedia","replyMarkup","Response","arrayBuffer","readFile"],"sources":["C:/Users/Muhammed/Desktop/REACT_JS/dene-gramjs/node_modules/telegram/client/uploads.js"],"sourcesContent":["\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.sendFile = exports._sendAlbum = exports._fileToMedia = exports.uploadFile = exports.CustomFile = void 0;\r\nconst buffer_1 = require(\"buffer/\");\r\nconst tl_1 = require(\"../tl\");\r\nconst Helpers_1 = require(\"../Helpers\");\r\nconst Utils_1 = require(\"../Utils\");\r\nconst path_1 = __importDefault(require(\"./path\"));\r\nconst fs_1 = require(\"./fs\");\r\nconst index_1 = require(\"../index\");\r\nconst messageParse_1 = require(\"./messageParse\");\r\nconst messages_1 = require(\"./messages\");\r\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\r\n/**\r\n * A custom file class that mimics the browser's File class.<br/>\r\n * You should use this whenever you want to upload a file.\r\n */\r\nclass CustomFile {\r\n    constructor(name, size, path, buffer) {\r\n        this.name = name;\r\n        this.size = size;\r\n        this.path = path;\r\n        this.buffer = buffer;\r\n    }\r\n}\r\nexports.CustomFile = CustomFile;\r\nclass CustomBuffer {\r\n    constructor(options) {\r\n        this.options = options;\r\n        if (!options.buffer && !options.filePath) {\r\n            throw new Error(\"Either one of `buffer` or `filePath` should be specified\");\r\n        }\r\n    }\r\n    async slice(begin, end) {\r\n        const { buffer, filePath } = this.options;\r\n        if (buffer) {\r\n            return buffer.slice(begin, end);\r\n        }\r\n        else if (filePath) {\r\n            const buffSize = end - begin;\r\n            const buff = buffer_1.Buffer.alloc(buffSize);\r\n            const fHandle = await fs_1.promises.open(filePath, \"r\");\r\n            await fHandle.read(buff, 0, buffSize, begin);\r\n            await fHandle.close();\r\n            return buffer_1.Buffer.from(buff);\r\n        }\r\n        return buffer_1.Buffer.alloc(0);\r\n    }\r\n}\r\nconst KB_TO_BYTES = 1024;\r\nconst LARGE_FILE_THRESHOLD = 10 * 1024 * 1024;\r\nconst UPLOAD_TIMEOUT = 15 * 1000;\r\nconst DISCONNECT_SLEEP = 1000;\r\nconst BUFFER_SIZE_2GB = 2 ** 31;\r\nasync function getFileBuffer(file, fileSize, maxBufferSize) {\r\n    const options = {};\r\n    if (fileSize > maxBufferSize && file instanceof CustomFile) {\r\n        options.filePath = file.path;\r\n    }\r\n    else {\r\n        options.buffer = buffer_1.Buffer.from(await fileToBuffer(file));\r\n    }\r\n    return new CustomBuffer(options);\r\n}\r\n/** @hidden */\r\nasync function uploadFile(client, fileParams) {\r\n    const { file, onProgress } = fileParams;\r\n    let { workers } = fileParams;\r\n    const { name, size } = file;\r\n    const fileId = (0, Helpers_1.readBigIntFromBuffer)((0, Helpers_1.generateRandomBytes)(8), true, true);\r\n    const isLarge = size > LARGE_FILE_THRESHOLD;\r\n    const partSize = (0, Utils_1.getAppropriatedPartSize)((0, big_integer_1.default)(size)) * KB_TO_BYTES;\r\n    const partCount = Math.floor((size + partSize - 1) / partSize);\r\n    const buffer = await getFileBuffer(file, size, fileParams.maxBufferSize || BUFFER_SIZE_2GB - 1);\r\n    // Make sure a new sender can be created before starting upload\r\n    await client.getSender(client.session.dcId);\r\n    if (!workers || !size) {\r\n        workers = 1;\r\n    }\r\n    if (workers >= partCount) {\r\n        workers = partCount;\r\n    }\r\n    let progress = 0;\r\n    if (onProgress) {\r\n        onProgress(progress);\r\n    }\r\n    for (let i = 0; i < partCount; i += workers) {\r\n        const sendingParts = [];\r\n        let end = i + workers;\r\n        if (end > partCount) {\r\n            end = partCount;\r\n        }\r\n        for (let j = i; j < end; j++) {\r\n            const bytes = await buffer.slice(j * partSize, (j + 1) * partSize);\r\n            // eslint-disable-next-line no-loop-func\r\n            sendingParts.push((async (jMemo, bytesMemo) => {\r\n                while (true) {\r\n                    let sender;\r\n                    try {\r\n                        // We always upload from the DC we are in\r\n                        sender = await client.getSender(client.session.dcId);\r\n                        await sender.send(isLarge\r\n                            ? new tl_1.Api.upload.SaveBigFilePart({\r\n                                fileId,\r\n                                filePart: jMemo,\r\n                                fileTotalParts: partCount,\r\n                                bytes: bytesMemo,\r\n                            })\r\n                            : new tl_1.Api.upload.SaveFilePart({\r\n                                fileId,\r\n                                filePart: jMemo,\r\n                                bytes: bytesMemo,\r\n                            }));\r\n                    }\r\n                    catch (err) {\r\n                        if (sender && !sender.isConnected()) {\r\n                            await (0, Helpers_1.sleep)(DISCONNECT_SLEEP);\r\n                            continue;\r\n                        }\r\n                        else if (err instanceof index_1.errors.FloodWaitError) {\r\n                            await (0, Helpers_1.sleep)(err.seconds * 1000);\r\n                            continue;\r\n                        }\r\n                        throw err;\r\n                    }\r\n                    if (onProgress) {\r\n                        if (onProgress.isCanceled) {\r\n                            throw new Error(\"USER_CANCELED\");\r\n                        }\r\n                        progress += 1 / partCount;\r\n                        onProgress(progress);\r\n                    }\r\n                    break;\r\n                }\r\n            })(j, bytes));\r\n        }\r\n        await Promise.all(sendingParts);\r\n    }\r\n    return isLarge\r\n        ? new tl_1.Api.InputFileBig({\r\n            id: fileId,\r\n            parts: partCount,\r\n            name,\r\n        })\r\n        : new tl_1.Api.InputFile({\r\n            id: fileId,\r\n            parts: partCount,\r\n            name,\r\n            md5Checksum: \"\", // This is not a \"flag\", so not sure if we can make it optional.\r\n        });\r\n}\r\nexports.uploadFile = uploadFile;\r\n/** @hidden */\r\nasync function _fileToMedia(client, { file, forceDocument, fileSize, progressCallback, attributes, thumb, voiceNote = false, videoNote = false, supportsStreaming = false, mimeType, asImage, workers = 1, }) {\r\n    if (!file) {\r\n        return { fileHandle: undefined, media: undefined, image: undefined };\r\n    }\r\n    const isImage = index_1.utils.isImage(file);\r\n    if (asImage == undefined) {\r\n        asImage = isImage && !forceDocument;\r\n    }\r\n    if (typeof file == \"object\" &&\r\n        !buffer_1.Buffer.isBuffer(file) &&\r\n        !(file instanceof tl_1.Api.InputFile) &&\r\n        !(file instanceof tl_1.Api.InputFileBig) &&\r\n        !(file instanceof CustomFile) &&\r\n        !(\"read\" in file)) {\r\n        try {\r\n            return {\r\n                fileHandle: undefined,\r\n                media: index_1.utils.getInputMedia(file, {\r\n                    isPhoto: asImage,\r\n                    attributes: attributes,\r\n                    forceDocument: forceDocument,\r\n                    voiceNote: voiceNote,\r\n                    videoNote: videoNote,\r\n                    supportsStreaming: supportsStreaming,\r\n                }),\r\n                image: asImage,\r\n            };\r\n        }\r\n        catch (e) {\r\n            return {\r\n                fileHandle: undefined,\r\n                media: undefined,\r\n                image: isImage,\r\n            };\r\n        }\r\n    }\r\n    let media;\r\n    let fileHandle;\r\n    let createdFile;\r\n    if (file instanceof tl_1.Api.InputFile || file instanceof tl_1.Api.InputFileBig) {\r\n        fileHandle = file;\r\n    }\r\n    else if (typeof file == \"string\" &&\r\n        (file.startsWith(\"https://\") || file.startsWith(\"http://\"))) {\r\n        if (asImage) {\r\n            media = new tl_1.Api.InputMediaPhotoExternal({ url: file });\r\n        }\r\n        else {\r\n            media = new tl_1.Api.InputMediaDocumentExternal({ url: file });\r\n        }\r\n    }\r\n    else if (!(typeof file == \"string\") || (await fs_1.promises.lstat(file)).isFile()) {\r\n        if (typeof file == \"string\") {\r\n            createdFile = new CustomFile(path_1.default.basename(file), (await fs_1.promises.stat(file)).size, file);\r\n        }\r\n        else if ((typeof File !== \"undefined\" && file instanceof File) ||\r\n            file instanceof CustomFile) {\r\n            createdFile = file;\r\n        }\r\n        else {\r\n            let name;\r\n            if (\"name\" in file) {\r\n                // @ts-ignore\r\n                name = file.name;\r\n            }\r\n            else {\r\n                name = \"unnamed\";\r\n            }\r\n            if (buffer_1.Buffer.isBuffer(file)) {\r\n                createdFile = new CustomFile(name, file.length, \"\", file);\r\n            }\r\n        }\r\n        if (!createdFile) {\r\n            throw new Error(`Could not create file from ${JSON.stringify(file)}`);\r\n        }\r\n        fileHandle = await uploadFile(client, {\r\n            file: createdFile,\r\n            onProgress: progressCallback,\r\n            workers: workers,\r\n        });\r\n    }\r\n    else {\r\n        throw new Error(`\"Not a valid path nor a url ${file}`);\r\n    }\r\n    if (media != undefined) {\r\n    }\r\n    else if (fileHandle == undefined) {\r\n        throw new Error(`Failed to convert ${file} to media. Not an existing file or an HTTP URL`);\r\n    }\r\n    else if (asImage) {\r\n        media = new tl_1.Api.InputMediaUploadedPhoto({\r\n            file: fileHandle,\r\n        });\r\n    }\r\n    else {\r\n        // @ts-ignore\r\n        let res = index_1.utils.getAttributes(file, {\r\n            mimeType: mimeType,\r\n            attributes: attributes,\r\n            forceDocument: forceDocument && !isImage,\r\n            voiceNote: voiceNote,\r\n            videoNote: videoNote,\r\n            supportsStreaming: supportsStreaming,\r\n            thumb: thumb,\r\n        });\r\n        attributes = res.attrs;\r\n        mimeType = res.mimeType;\r\n        let uploadedThumb;\r\n        if (!thumb) {\r\n            uploadedThumb = undefined;\r\n        }\r\n        else {\r\n            // todo refactor\r\n            if (typeof thumb == \"string\") {\r\n                uploadedThumb = new CustomFile(path_1.default.basename(thumb), (await fs_1.promises.stat(thumb)).size, thumb);\r\n            }\r\n            else if (typeof File !== \"undefined\" && thumb instanceof File) {\r\n                uploadedThumb = thumb;\r\n            }\r\n            else {\r\n                let name;\r\n                if (\"name\" in thumb) {\r\n                    name = thumb.name;\r\n                }\r\n                else {\r\n                    name = \"unnamed\";\r\n                }\r\n                if (buffer_1.Buffer.isBuffer(thumb)) {\r\n                    uploadedThumb = new CustomFile(name, thumb.length, \"\", thumb);\r\n                }\r\n            }\r\n            if (!uploadedThumb) {\r\n                throw new Error(`Could not create file from ${file}`);\r\n            }\r\n            uploadedThumb = await uploadFile(client, {\r\n                file: uploadedThumb,\r\n                workers: 1,\r\n            });\r\n        }\r\n        media = new tl_1.Api.InputMediaUploadedDocument({\r\n            file: fileHandle,\r\n            mimeType: mimeType,\r\n            attributes: attributes,\r\n            thumb: uploadedThumb,\r\n            forceFile: forceDocument && !isImage,\r\n        });\r\n    }\r\n    return {\r\n        fileHandle: fileHandle,\r\n        media: media,\r\n        image: asImage,\r\n    };\r\n}\r\nexports._fileToMedia = _fileToMedia;\r\n/** @hidden */\r\nasync function _sendAlbum(client, entity, { file, caption, forceDocument = false, fileSize, clearDraft = false, progressCallback, replyTo, attributes, thumb, parseMode, voiceNote = false, videoNote = false, silent, supportsStreaming = false, scheduleDate, workers = 1, noforwards, commentTo, topMsgId, }) {\r\n    entity = await client.getInputEntity(entity);\r\n    let files = [];\r\n    if (!Array.isArray(file)) {\r\n        files = [file];\r\n    }\r\n    else {\r\n        files = file;\r\n    }\r\n    if (!Array.isArray(caption)) {\r\n        if (!caption) {\r\n            caption = \"\";\r\n        }\r\n        caption = [caption];\r\n    }\r\n    const captions = [];\r\n    for (const c of caption) {\r\n        captions.push(await (0, messageParse_1._parseMessageText)(client, c, parseMode));\r\n    }\r\n    if (commentTo != undefined) {\r\n        const discussionData = await (0, messages_1.getCommentData)(client, entity, commentTo);\r\n        entity = discussionData.entity;\r\n        replyTo = discussionData.replyTo;\r\n    }\r\n    else {\r\n        replyTo = index_1.utils.getMessageId(replyTo);\r\n    }\r\n    if (!attributes) {\r\n        attributes = [];\r\n    }\r\n    let index = 0;\r\n    const albumFiles = [];\r\n    for (const file of files) {\r\n        let { fileHandle, media, image } = await _fileToMedia(client, {\r\n            file: file,\r\n            forceDocument: forceDocument,\r\n            fileSize: fileSize,\r\n            progressCallback: progressCallback,\r\n            // @ts-ignore\r\n            attributes: attributes[index],\r\n            thumb: thumb,\r\n            voiceNote: voiceNote,\r\n            videoNote: videoNote,\r\n            supportsStreaming: supportsStreaming,\r\n            workers: workers,\r\n        });\r\n        index++;\r\n        if (media instanceof tl_1.Api.InputMediaUploadedPhoto ||\r\n            media instanceof tl_1.Api.InputMediaPhotoExternal) {\r\n            const r = await client.invoke(new tl_1.Api.messages.UploadMedia({\r\n                peer: entity,\r\n                media,\r\n            }));\r\n            if (r instanceof tl_1.Api.MessageMediaPhoto) {\r\n                media = (0, Utils_1.getInputMedia)(r.photo);\r\n            }\r\n        }\r\n        else if (media instanceof tl_1.Api.InputMediaUploadedDocument) {\r\n            const r = await client.invoke(new tl_1.Api.messages.UploadMedia({\r\n                peer: entity,\r\n                media,\r\n            }));\r\n            if (r instanceof tl_1.Api.MessageMediaDocument) {\r\n                media = (0, Utils_1.getInputMedia)(r.document);\r\n            }\r\n        }\r\n        let text = \"\";\r\n        let msgEntities = [];\r\n        if (captions.length) {\r\n            [text, msgEntities] = captions.shift();\r\n        }\r\n        albumFiles.push(new tl_1.Api.InputSingleMedia({\r\n            media: media,\r\n            message: text,\r\n            entities: msgEntities,\r\n        }));\r\n    }\r\n    let replyObject = undefined;\r\n    if (replyTo != undefined) {\r\n        replyObject = new tl_1.Api.InputReplyToMessage({\r\n            replyToMsgId: (0, Utils_1.getMessageId)(replyTo),\r\n            topMsgId: (0, Utils_1.getMessageId)(topMsgId),\r\n        });\r\n    }\r\n    const result = await client.invoke(new tl_1.Api.messages.SendMultiMedia({\r\n        peer: entity,\r\n        replyTo: replyObject,\r\n        multiMedia: albumFiles,\r\n        silent: silent,\r\n        scheduleDate: scheduleDate,\r\n        clearDraft: clearDraft,\r\n        noforwards: noforwards,\r\n    }));\r\n    const randomIds = albumFiles.map((m) => m.randomId);\r\n    return client._getResponseMessage(randomIds, result, entity);\r\n}\r\nexports._sendAlbum = _sendAlbum;\r\n/** @hidden */\r\nasync function sendFile(client, entity, { file, caption, forceDocument = false, fileSize, clearDraft = false, progressCallback, replyTo, attributes, thumb, parseMode, formattingEntities, voiceNote = false, videoNote = false, buttons, silent, supportsStreaming = false, scheduleDate, workers = 1, noforwards, commentTo, topMsgId, }) {\r\n    if (!file) {\r\n        throw new Error(\"You need to specify a file\");\r\n    }\r\n    if (!caption) {\r\n        caption = \"\";\r\n    }\r\n    entity = await client.getInputEntity(entity);\r\n    if (commentTo != undefined) {\r\n        const discussionData = await (0, messages_1.getCommentData)(client, entity, commentTo);\r\n        entity = discussionData.entity;\r\n        replyTo = discussionData.replyTo;\r\n    }\r\n    else {\r\n        replyTo = index_1.utils.getMessageId(replyTo);\r\n    }\r\n    if (Array.isArray(file)) {\r\n        return await _sendAlbum(client, entity, {\r\n            file: file,\r\n            caption: caption,\r\n            replyTo: replyTo,\r\n            parseMode: parseMode,\r\n            attributes: attributes,\r\n            silent: silent,\r\n            scheduleDate: scheduleDate,\r\n            supportsStreaming: supportsStreaming,\r\n            clearDraft: clearDraft,\r\n            forceDocument: forceDocument,\r\n            noforwards: noforwards,\r\n            topMsgId: topMsgId,\r\n        });\r\n    }\r\n    if (Array.isArray(caption)) {\r\n        caption = caption[0] || \"\";\r\n    }\r\n    let msgEntities;\r\n    if (formattingEntities != undefined) {\r\n        msgEntities = formattingEntities;\r\n    }\r\n    else {\r\n        [caption, msgEntities] = await (0, messageParse_1._parseMessageText)(client, caption, parseMode);\r\n    }\r\n    const { fileHandle, media, image } = await _fileToMedia(client, {\r\n        file: file,\r\n        forceDocument: forceDocument,\r\n        fileSize: fileSize,\r\n        progressCallback: progressCallback,\r\n        // @ts-ignore\r\n        attributes: attributes,\r\n        thumb: thumb,\r\n        voiceNote: voiceNote,\r\n        videoNote: videoNote,\r\n        supportsStreaming: supportsStreaming,\r\n        workers: workers,\r\n    });\r\n    if (media == undefined) {\r\n        throw new Error(`Cannot use ${file} as file.`);\r\n    }\r\n    const markup = client.buildReplyMarkup(buttons);\r\n    let replyObject = undefined;\r\n    if (replyTo != undefined) {\r\n        replyObject = new tl_1.Api.InputReplyToMessage({\r\n            replyToMsgId: (0, Utils_1.getMessageId)(replyTo),\r\n            topMsgId: (0, Utils_1.getMessageId)(topMsgId),\r\n        });\r\n    }\r\n    const request = new tl_1.Api.messages.SendMedia({\r\n        peer: entity,\r\n        media: media,\r\n        replyTo: replyObject,\r\n        message: caption,\r\n        entities: msgEntities,\r\n        replyMarkup: markup,\r\n        silent: silent,\r\n        scheduleDate: scheduleDate,\r\n        clearDraft: clearDraft,\r\n        noforwards: noforwards,\r\n    });\r\n    const result = await client.invoke(request);\r\n    return client._getResponseMessage(request, result, entity);\r\n}\r\nexports.sendFile = sendFile;\r\nfunction fileToBuffer(file) {\r\n    if (typeof File !== \"undefined\" && file instanceof File) {\r\n        return new Response(file).arrayBuffer();\r\n    }\r\n    else if (file instanceof CustomFile) {\r\n        if (file.buffer != undefined) {\r\n            return file.buffer;\r\n        }\r\n        else {\r\n            return fs_1.promises.readFile(file.path);\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(\"Could not create buffer from file \" + file);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}