{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._entityType = exports._EntityType = exports.TotalList = exports.crc32 = exports.bufferXor = exports.sleep = exports.getRandomInt = exports.getMinBigInt = exports.returnBigInt = exports.getByteArray = exports.modExp = exports.sha256 = exports.sha1 = exports.convertToLittle = exports.generateKeyDataFromNonce = exports.stripText = exports.generateRandomBytes = exports.bigIntMod = exports.mod = exports.generateRandomLong = exports.readBufferFromBigInt = exports.toSignedLittleBuffer = exports.isArrayLike = exports.betterConsoleLog = exports.groupBy = exports.escapeRegex = exports.generateRandomBigInt = exports.readBigIntFromBuffer = void 0;\nconst buffer_1 = require(\"buffer/\");\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst CryptoFile_1 = __importDefault(require(\"./CryptoFile\"));\nconst platform_1 = require(\"./platform\");\n/**\r\n * converts a buffer to big int\r\n * @param buffer\r\n * @param little\r\n * @param signed\r\n * @returns {bigInt.BigInteger}\r\n */\nfunction readBigIntFromBuffer(buffer, little = true, signed = false) {\n  let randBuffer = buffer_1.Buffer.from(buffer);\n  const bytesNumber = randBuffer.length;\n  if (little) {\n    randBuffer = randBuffer.reverse();\n  }\n  let bigIntVar = (0, big_integer_1.default)(randBuffer.toString(\"hex\"), 16);\n  if (signed && Math.floor(bigIntVar.toString(2).length / 8) >= bytesNumber) {\n    bigIntVar = bigIntVar.subtract((0, big_integer_1.default)(2).pow((0, big_integer_1.default)(bytesNumber * 8)));\n  }\n  return bigIntVar;\n}\nexports.readBigIntFromBuffer = readBigIntFromBuffer;\nfunction generateRandomBigInt() {\n  return readBigIntFromBuffer(generateRandomBytes(8), false);\n}\nexports.generateRandomBigInt = generateRandomBigInt;\nfunction escapeRegex(string) {\n  return string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\nexports.escapeRegex = escapeRegex;\nfunction groupBy(list, keyGetter) {\n  const map = new Map();\n  list.forEach(item => {\n    const key = keyGetter(item);\n    const collection = map.get(key);\n    if (!collection) {\n      map.set(key, [item]);\n    } else {\n      collection.push(item);\n    }\n  });\n  return map;\n}\nexports.groupBy = groupBy;\n/**\r\n * Outputs the object in a better way by hiding all the private methods/attributes.\r\n * @param object - the class to use\r\n */\nfunction betterConsoleLog(object) {\n  const toPrint = {};\n  for (const key in object) {\n    if (object.hasOwnProperty(key)) {\n      if (!key.startsWith(\"_\") && key != \"originalArgs\") {\n        toPrint[key] = object[key];\n      }\n    }\n  }\n  return toPrint;\n}\nexports.betterConsoleLog = betterConsoleLog;\n/**\r\n * Helper to find if a given object is an array (or similar)\r\n */\nconst isArrayLike = x => x && typeof x.length === \"number\" && typeof x !== \"function\" && typeof x !== \"string\";\nexports.isArrayLike = isArrayLike;\n/*\r\nexport function addSurrogate(text: string) {\r\n    let temp = \"\";\r\n    for (const letter of text) {\r\n        const t = letter.charCodeAt(0);\r\n        if (0x1000 < t && t < 0x10FFFF) {\r\n            const b = Buffer.from(letter, \"utf16le\");\r\n            const r = String.fromCharCode(b.readUInt16LE(0)) + String.fromCharCode(b.readUInt16LE(2));\r\n            temp += r;\r\n        } else {\r\n            text += letter;\r\n        }\r\n    }\r\n    return temp;\r\n}\r\n\r\n */\n/**\r\n * Special case signed little ints\r\n * @param big\r\n * @param number\r\n * @returns {Buffer}\r\n */\nfunction toSignedLittleBuffer(big, number = 8) {\n  const bigNumber = returnBigInt(big);\n  const byteArray = [];\n  for (let i = 0; i < number; i++) {\n    byteArray[i] = bigNumber.shiftRight(8 * i).and(255);\n  }\n  // smh hacks\n  return buffer_1.Buffer.from(byteArray);\n}\nexports.toSignedLittleBuffer = toSignedLittleBuffer;\n/**\r\n * converts a big int to a buffer\r\n * @param bigIntVar {BigInteger}\r\n * @param bytesNumber\r\n * @param little\r\n * @param signed\r\n * @returns {Buffer}\r\n */\nfunction readBufferFromBigInt(bigIntVar, bytesNumber, little = true, signed = false) {\n  bigIntVar = (0, big_integer_1.default)(bigIntVar);\n  const bitLength = bigIntVar.bitLength().toJSNumber();\n  const bytes = Math.ceil(bitLength / 8);\n  if (bytesNumber < bytes) {\n    throw new Error(\"OverflowError: int too big to convert\");\n  }\n  if (!signed && bigIntVar.lesser((0, big_integer_1.default)(0))) {\n    throw new Error(\"Cannot convert to unsigned\");\n  }\n  let below = false;\n  if (bigIntVar.lesser((0, big_integer_1.default)(0))) {\n    below = true;\n    bigIntVar = bigIntVar.abs();\n  }\n  const hex = bigIntVar.toString(16).padStart(bytesNumber * 2, \"0\");\n  let buffer = buffer_1.Buffer.from(hex, \"hex\");\n  if (signed && below) {\n    buffer[buffer.length - 1] = 256 - buffer[buffer.length - 1];\n    for (let i = 0; i < buffer.length - 1; i++) {\n      buffer[i] = 255 - buffer[i];\n    }\n  }\n  if (little) {\n    buffer = buffer.reverse();\n  }\n  return buffer;\n}\nexports.readBufferFromBigInt = readBufferFromBigInt;\n/**\r\n * Generates a random long integer (8 bytes), which is optionally signed\r\n * @returns {BigInteger}\r\n */\nfunction generateRandomLong(signed = true) {\n  return readBigIntFromBuffer(generateRandomBytes(8), true, signed);\n}\nexports.generateRandomLong = generateRandomLong;\n/**\r\n * .... really javascript\r\n * @param n {number}\r\n * @param m {number}\r\n * @returns {number}\r\n */\nfunction mod(n, m) {\n  return (n % m + m) % m;\n}\nexports.mod = mod;\n/**\r\n * returns a positive bigInt\r\n * @param n {bigInt.BigInteger}\r\n * @param m {bigInt.BigInteger}\r\n * @returns {bigInt.BigInteger}\r\n */\nfunction bigIntMod(n, m) {\n  return n.remainder(m).add(m).remainder(m);\n}\nexports.bigIntMod = bigIntMod;\n/**\r\n * Generates a random bytes array\r\n * @param count\r\n * @returns {Buffer}\r\n */\nfunction generateRandomBytes(count) {\n  return buffer_1.Buffer.from(CryptoFile_1.default.randomBytes(count));\n}\nexports.generateRandomBytes = generateRandomBytes;\n/**\r\n * Calculate the key based on Telegram guidelines, specifying whether it's the client or not\r\n * @param sharedKey\r\n * @param msgKey\r\n * @param client\r\n * @returns {{iv: Buffer, key: Buffer}}\r\n */\n/*CONTEST\r\nthis is mtproto 1 (mostly used for secret chats)\r\nasync function calcKey(sharedKey, msgKey, client) {\r\n    const x = client === true ? 0 : 8\r\n    const [sha1a, sha1b, sha1c, sha1d] = await Promise.all([\r\n        sha1(Buffer.concat([msgKey, sharedKey.slice(x, x + 32)])),\r\n        sha1(Buffer.concat([sharedKey.slice(x + 32, x + 48), msgKey, sharedKey.slice(x + 48, x + 64)])),\r\n        sha1(Buffer.concat([sharedKey.slice(x + 64, x + 96), msgKey])),\r\n        sha1(Buffer.concat([msgKey, sharedKey.slice(x + 96, x + 128)]))\r\n    ])\r\n    const key = Buffer.concat([sha1a.slice(0, 8), sha1b.slice(8, 20), sha1c.slice(4, 16)])\r\n    const iv = Buffer.concat([sha1a.slice(8, 20), sha1b.slice(0, 8), sha1c.slice(16, 20), sha1d.slice(0, 8)])\r\n    return {\r\n        key,\r\n        iv\r\n    }\r\n}\r\n\r\n */\nfunction stripText(text, entities) {\n  if (!entities || !entities.length) {\n    return text.trim();\n  }\n  while (text && text[text.length - 1].trim() === \"\") {\n    const e = entities[entities.length - 1];\n    if (e.offset + e.length == text.length) {\n      if (e.length == 1) {\n        entities.pop();\n        if (!entities.length) {\n          return text.trim();\n        }\n      } else {\n        e.length -= 1;\n      }\n    }\n    text = text.slice(0, -1);\n  }\n  while (text && text[0].trim() === \"\") {\n    for (let i = 0; i < entities.length; i++) {\n      const e = entities[i];\n      if (e.offset != 0) {\n        e.offset--;\n        continue;\n      }\n      if (e.length == 1) {\n        entities.shift();\n        if (!entities.length) {\n          return text.trimLeft();\n        }\n      } else {\n        e.length -= 1;\n      }\n    }\n    text = text.slice(1);\n  }\n  return text;\n}\nexports.stripText = stripText;\n/**\r\n * Generates the key data corresponding to the given nonces\r\n * @param serverNonceBigInt\r\n * @param newNonceBigInt\r\n * @returns {{key: Buffer, iv: Buffer}}\r\n */\nasync function generateKeyDataFromNonce(serverNonceBigInt, newNonceBigInt) {\n  const serverNonce = toSignedLittleBuffer(serverNonceBigInt, 16);\n  const newNonce = toSignedLittleBuffer(newNonceBigInt, 32);\n  const [hash1, hash2, hash3] = await Promise.all([sha1(buffer_1.Buffer.concat([newNonce, serverNonce])), sha1(buffer_1.Buffer.concat([serverNonce, newNonce])), sha1(buffer_1.Buffer.concat([newNonce, newNonce]))]);\n  const keyBuffer = buffer_1.Buffer.concat([hash1, hash2.slice(0, 12)]);\n  const ivBuffer = buffer_1.Buffer.concat([hash2.slice(12, 20), hash3, newNonce.slice(0, 4)]);\n  return {\n    key: keyBuffer,\n    iv: ivBuffer\n  };\n}\nexports.generateKeyDataFromNonce = generateKeyDataFromNonce;\nfunction convertToLittle(buf) {\n  const correct = buffer_1.Buffer.alloc(buf.length * 4);\n  for (let i = 0; i < buf.length; i++) {\n    correct.writeUInt32BE(buf[i], i * 4);\n  }\n  return correct;\n}\nexports.convertToLittle = convertToLittle;\n/**\r\n * Calculates the SHA1 digest for the given data\r\n * @param data\r\n * @returns {Promise}\r\n */\nfunction sha1(data) {\n  const shaSum = CryptoFile_1.default.createHash(\"sha1\");\n  shaSum.update(data);\n  // @ts-ignore\n  return shaSum.digest();\n}\nexports.sha1 = sha1;\n/**\r\n * Calculates the SHA256 digest for the given data\r\n * @param data\r\n * @returns {Promise}\r\n */\nfunction sha256(data) {\n  const shaSum = CryptoFile_1.default.createHash(\"sha256\");\n  shaSum.update(data);\n  // @ts-ignore\n  return shaSum.digest();\n}\nexports.sha256 = sha256;\n/**\r\n * Fast mod pow for RSA calculation. a^b % n\r\n * @param a\r\n * @param b\r\n * @param n\r\n * @returns {bigInt.BigInteger}\r\n */\nfunction modExp(a, b, n) {\n  a = a.remainder(n);\n  let result = big_integer_1.default.one;\n  let x = a;\n  while (b.greater(big_integer_1.default.zero)) {\n    const leastSignificantBit = b.remainder((0, big_integer_1.default)(2));\n    b = b.divide((0, big_integer_1.default)(2));\n    if (leastSignificantBit.eq(big_integer_1.default.one)) {\n      result = result.multiply(x);\n      result = result.remainder(n);\n    }\n    x = x.multiply(x);\n    x = x.remainder(n);\n  }\n  return result;\n}\nexports.modExp = modExp;\n/**\r\n * Gets the arbitrary-length byte array corresponding to the given integer\r\n * @param integer {number,BigInteger}\r\n * @param signed {boolean}\r\n * @returns {Buffer}\r\n */\nfunction getByteArray(integer, signed = false) {\n  const bits = integer.toString(2).length;\n  const byteLength = Math.floor((bits + 8 - 1) / 8);\n  return readBufferFromBigInt(typeof integer == \"number\" ? (0, big_integer_1.default)(integer) : integer, byteLength, false, signed);\n}\nexports.getByteArray = getByteArray;\nfunction returnBigInt(num) {\n  if (big_integer_1.default.isInstance(num)) {\n    return num;\n  }\n  if (typeof num == \"number\") {\n    return (0, big_integer_1.default)(num);\n  }\n  if (typeof num == \"bigint\") {\n    return (0, big_integer_1.default)(num);\n  }\n  return (0, big_integer_1.default)(num);\n}\nexports.returnBigInt = returnBigInt;\n/**\r\n * Helper function to return the smaller big int in an array\r\n * @param arrayOfBigInts\r\n */\nfunction getMinBigInt(arrayOfBigInts) {\n  if (arrayOfBigInts.length == 0) {\n    return big_integer_1.default.zero;\n  }\n  if (arrayOfBigInts.length == 1) {\n    return returnBigInt(arrayOfBigInts[0]);\n  }\n  let smallest = returnBigInt(arrayOfBigInts[0]);\n  for (let i = 1; i < arrayOfBigInts.length; i++) {\n    if (returnBigInt(arrayOfBigInts[i]).lesser(smallest)) {\n      smallest = returnBigInt(arrayOfBigInts[i]);\n    }\n  }\n  return smallest;\n}\nexports.getMinBigInt = getMinBigInt;\n/**\r\n * returns a random int from min (inclusive) and max (inclusive)\r\n * @param min\r\n * @param max\r\n * @returns {number}\r\n */\nfunction getRandomInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\nexports.getRandomInt = getRandomInt;\n/**\r\n * Sleeps a specified amount of time\r\n * @param ms time in milliseconds\r\n * @param isUnref make a timer unref'ed\r\n * @returns {Promise}\r\n */\nconst sleep = (ms, isUnref = false) => new Promise(resolve => isUnref && platform_1.isNode ? setTimeout(resolve, ms).unref() : setTimeout(resolve, ms));\nexports.sleep = sleep;\n/**\r\n * Helper to export two buffers of same length\r\n * @returns {Buffer}\r\n */\nfunction bufferXor(a, b) {\n  const res = [];\n  for (let i = 0; i < a.length; i++) {\n    res.push(a[i] ^ b[i]);\n  }\n  return buffer_1.Buffer.from(res);\n}\nexports.bufferXor = bufferXor;\n// Taken from https://stackoverflow.com/questions/18638900/javascript-crc32/18639999#18639999\nfunction makeCRCTable() {\n  let c;\n  const crcTable = [];\n  for (let n = 0; n < 256; n++) {\n    c = n;\n    for (let k = 0; k < 8; k++) {\n      c = c & 1 ? 0xedb88320 ^ c >>> 1 : c >>> 1;\n    }\n    crcTable[n] = c;\n  }\n  return crcTable;\n}\nlet crcTable = undefined;\nfunction crc32(buf) {\n  if (!crcTable) {\n    crcTable = makeCRCTable();\n  }\n  if (!buffer_1.Buffer.isBuffer(buf)) {\n    buf = buffer_1.Buffer.from(buf);\n  }\n  let crc = -1;\n  for (let index = 0; index < buf.length; index++) {\n    const byte = buf[index];\n    crc = crcTable[(crc ^ byte) & 0xff] ^ crc >>> 8;\n  }\n  return (crc ^ -1) >>> 0;\n}\nexports.crc32 = crc32;\nclass TotalList extends Array {\n  constructor() {\n    super();\n    this.total = 0;\n  }\n}\nexports.TotalList = TotalList;\nexports._EntityType = {\n  USER: 0,\n  CHAT: 1,\n  CHANNEL: 2\n};\nObject.freeze(exports._EntityType);\nfunction _entityType(entity) {\n  if (typeof entity !== \"object\" || !(\"SUBCLASS_OF_ID\" in entity)) {\n    throw new Error(`${entity} is not a TLObject, cannot determine entity type`);\n  }\n  if (![0x2d45687, 0xc91c90b6, 0xe669bf46, 0x40f202fd, 0x2da17977, 0xc5af5d94, 0x1f4661b9, 0xd49a2697 // crc32('ChatFull')\n  ].includes(entity.SUBCLASS_OF_ID)) {\n    throw new Error(`${entity} does not have any entity type`);\n  }\n  const name = entity.className;\n  if (name.includes(\"User\")) {\n    return exports._EntityType.USER;\n  } else if (name.includes(\"Chat\")) {\n    return exports._EntityType.CHAT;\n  } else if (name.includes(\"Channel\")) {\n    return exports._EntityType.CHANNEL;\n  } else if (name.includes(\"Self\")) {\n    return exports._EntityType.USER;\n  }\n  // 'Empty' in name or not found, we don't care, not a valid entity.\n  throw new Error(`${entity} does not have any entity type`);\n}\nexports._entityType = _entityType;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","_entityType","_EntityType","TotalList","crc32","bufferXor","sleep","getRandomInt","getMinBigInt","returnBigInt","getByteArray","modExp","sha256","sha1","convertToLittle","generateKeyDataFromNonce","stripText","generateRandomBytes","bigIntMod","generateRandomLong","readBufferFromBigInt","toSignedLittleBuffer","isArrayLike","betterConsoleLog","groupBy","escapeRegex","generateRandomBigInt","readBigIntFromBuffer","buffer_1","require","big_integer_1","CryptoFile_1","platform_1","buffer","little","signed","randBuffer","Buffer","from","bytesNumber","length","reverse","bigIntVar","default","toString","Math","floor","subtract","pow","string","replace","list","keyGetter","map","Map","forEach","item","key","collection","get","set","push","object","toPrint","hasOwnProperty","startsWith","x","big","number","bigNumber","byteArray","i","shiftRight","and","bitLength","toJSNumber","bytes","ceil","Error","lesser","below","abs","hex","padStart","n","m","remainder","add","count","randomBytes","text","entities","trim","e","offset","pop","slice","shift","trimLeft","serverNonceBigInt","newNonceBigInt","serverNonce","newNonce","hash1","hash2","hash3","Promise","all","concat","keyBuffer","ivBuffer","iv","buf","correct","alloc","writeUInt32BE","data","shaSum","createHash","update","digest","a","b","result","one","greater","zero","leastSignificantBit","divide","eq","multiply","integer","bits","byteLength","num","isInstance","arrayOfBigInts","smallest","min","max","random","ms","isUnref","resolve","isNode","setTimeout","unref","res","makeCRCTable","c","crcTable","k","undefined","isBuffer","crc","index","byte","Array","constructor","total","USER","CHAT","CHANNEL","freeze","entity","includes","SUBCLASS_OF_ID","name","className"],"sources":["C:/Users/Muhammed/Desktop/REACT_JS/dene-gramjs/node_modules/telegram/Helpers.js"],"sourcesContent":["\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports._entityType = exports._EntityType = exports.TotalList = exports.crc32 = exports.bufferXor = exports.sleep = exports.getRandomInt = exports.getMinBigInt = exports.returnBigInt = exports.getByteArray = exports.modExp = exports.sha256 = exports.sha1 = exports.convertToLittle = exports.generateKeyDataFromNonce = exports.stripText = exports.generateRandomBytes = exports.bigIntMod = exports.mod = exports.generateRandomLong = exports.readBufferFromBigInt = exports.toSignedLittleBuffer = exports.isArrayLike = exports.betterConsoleLog = exports.groupBy = exports.escapeRegex = exports.generateRandomBigInt = exports.readBigIntFromBuffer = void 0;\r\nconst buffer_1 = require(\"buffer/\");\r\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\r\nconst CryptoFile_1 = __importDefault(require(\"./CryptoFile\"));\r\nconst platform_1 = require(\"./platform\");\r\n/**\r\n * converts a buffer to big int\r\n * @param buffer\r\n * @param little\r\n * @param signed\r\n * @returns {bigInt.BigInteger}\r\n */\r\nfunction readBigIntFromBuffer(buffer, little = true, signed = false) {\r\n    let randBuffer = buffer_1.Buffer.from(buffer);\r\n    const bytesNumber = randBuffer.length;\r\n    if (little) {\r\n        randBuffer = randBuffer.reverse();\r\n    }\r\n    let bigIntVar = (0, big_integer_1.default)(randBuffer.toString(\"hex\"), 16);\r\n    if (signed && Math.floor(bigIntVar.toString(2).length / 8) >= bytesNumber) {\r\n        bigIntVar = bigIntVar.subtract((0, big_integer_1.default)(2).pow((0, big_integer_1.default)(bytesNumber * 8)));\r\n    }\r\n    return bigIntVar;\r\n}\r\nexports.readBigIntFromBuffer = readBigIntFromBuffer;\r\nfunction generateRandomBigInt() {\r\n    return readBigIntFromBuffer(generateRandomBytes(8), false);\r\n}\r\nexports.generateRandomBigInt = generateRandomBigInt;\r\nfunction escapeRegex(string) {\r\n    return string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\r\n}\r\nexports.escapeRegex = escapeRegex;\r\nfunction groupBy(list, keyGetter) {\r\n    const map = new Map();\r\n    list.forEach((item) => {\r\n        const key = keyGetter(item);\r\n        const collection = map.get(key);\r\n        if (!collection) {\r\n            map.set(key, [item]);\r\n        }\r\n        else {\r\n            collection.push(item);\r\n        }\r\n    });\r\n    return map;\r\n}\r\nexports.groupBy = groupBy;\r\n/**\r\n * Outputs the object in a better way by hiding all the private methods/attributes.\r\n * @param object - the class to use\r\n */\r\nfunction betterConsoleLog(object) {\r\n    const toPrint = {};\r\n    for (const key in object) {\r\n        if (object.hasOwnProperty(key)) {\r\n            if (!key.startsWith(\"_\") && key != \"originalArgs\") {\r\n                toPrint[key] = object[key];\r\n            }\r\n        }\r\n    }\r\n    return toPrint;\r\n}\r\nexports.betterConsoleLog = betterConsoleLog;\r\n/**\r\n * Helper to find if a given object is an array (or similar)\r\n */\r\nconst isArrayLike = (x) => x &&\r\n    typeof x.length === \"number\" &&\r\n    typeof x !== \"function\" &&\r\n    typeof x !== \"string\";\r\nexports.isArrayLike = isArrayLike;\r\n/*\r\nexport function addSurrogate(text: string) {\r\n    let temp = \"\";\r\n    for (const letter of text) {\r\n        const t = letter.charCodeAt(0);\r\n        if (0x1000 < t && t < 0x10FFFF) {\r\n            const b = Buffer.from(letter, \"utf16le\");\r\n            const r = String.fromCharCode(b.readUInt16LE(0)) + String.fromCharCode(b.readUInt16LE(2));\r\n            temp += r;\r\n        } else {\r\n            text += letter;\r\n        }\r\n    }\r\n    return temp;\r\n}\r\n\r\n */\r\n/**\r\n * Special case signed little ints\r\n * @param big\r\n * @param number\r\n * @returns {Buffer}\r\n */\r\nfunction toSignedLittleBuffer(big, number = 8) {\r\n    const bigNumber = returnBigInt(big);\r\n    const byteArray = [];\r\n    for (let i = 0; i < number; i++) {\r\n        byteArray[i] = bigNumber.shiftRight(8 * i).and(255);\r\n    }\r\n    // smh hacks\r\n    return buffer_1.Buffer.from(byteArray);\r\n}\r\nexports.toSignedLittleBuffer = toSignedLittleBuffer;\r\n/**\r\n * converts a big int to a buffer\r\n * @param bigIntVar {BigInteger}\r\n * @param bytesNumber\r\n * @param little\r\n * @param signed\r\n * @returns {Buffer}\r\n */\r\nfunction readBufferFromBigInt(bigIntVar, bytesNumber, little = true, signed = false) {\r\n    bigIntVar = (0, big_integer_1.default)(bigIntVar);\r\n    const bitLength = bigIntVar.bitLength().toJSNumber();\r\n    const bytes = Math.ceil(bitLength / 8);\r\n    if (bytesNumber < bytes) {\r\n        throw new Error(\"OverflowError: int too big to convert\");\r\n    }\r\n    if (!signed && bigIntVar.lesser((0, big_integer_1.default)(0))) {\r\n        throw new Error(\"Cannot convert to unsigned\");\r\n    }\r\n    let below = false;\r\n    if (bigIntVar.lesser((0, big_integer_1.default)(0))) {\r\n        below = true;\r\n        bigIntVar = bigIntVar.abs();\r\n    }\r\n    const hex = bigIntVar.toString(16).padStart(bytesNumber * 2, \"0\");\r\n    let buffer = buffer_1.Buffer.from(hex, \"hex\");\r\n    if (signed && below) {\r\n        buffer[buffer.length - 1] = 256 - buffer[buffer.length - 1];\r\n        for (let i = 0; i < buffer.length - 1; i++) {\r\n            buffer[i] = 255 - buffer[i];\r\n        }\r\n    }\r\n    if (little) {\r\n        buffer = buffer.reverse();\r\n    }\r\n    return buffer;\r\n}\r\nexports.readBufferFromBigInt = readBufferFromBigInt;\r\n/**\r\n * Generates a random long integer (8 bytes), which is optionally signed\r\n * @returns {BigInteger}\r\n */\r\nfunction generateRandomLong(signed = true) {\r\n    return readBigIntFromBuffer(generateRandomBytes(8), true, signed);\r\n}\r\nexports.generateRandomLong = generateRandomLong;\r\n/**\r\n * .... really javascript\r\n * @param n {number}\r\n * @param m {number}\r\n * @returns {number}\r\n */\r\nfunction mod(n, m) {\r\n    return ((n % m) + m) % m;\r\n}\r\nexports.mod = mod;\r\n/**\r\n * returns a positive bigInt\r\n * @param n {bigInt.BigInteger}\r\n * @param m {bigInt.BigInteger}\r\n * @returns {bigInt.BigInteger}\r\n */\r\nfunction bigIntMod(n, m) {\r\n    return n.remainder(m).add(m).remainder(m);\r\n}\r\nexports.bigIntMod = bigIntMod;\r\n/**\r\n * Generates a random bytes array\r\n * @param count\r\n * @returns {Buffer}\r\n */\r\nfunction generateRandomBytes(count) {\r\n    return buffer_1.Buffer.from(CryptoFile_1.default.randomBytes(count));\r\n}\r\nexports.generateRandomBytes = generateRandomBytes;\r\n/**\r\n * Calculate the key based on Telegram guidelines, specifying whether it's the client or not\r\n * @param sharedKey\r\n * @param msgKey\r\n * @param client\r\n * @returns {{iv: Buffer, key: Buffer}}\r\n */\r\n/*CONTEST\r\nthis is mtproto 1 (mostly used for secret chats)\r\nasync function calcKey(sharedKey, msgKey, client) {\r\n    const x = client === true ? 0 : 8\r\n    const [sha1a, sha1b, sha1c, sha1d] = await Promise.all([\r\n        sha1(Buffer.concat([msgKey, sharedKey.slice(x, x + 32)])),\r\n        sha1(Buffer.concat([sharedKey.slice(x + 32, x + 48), msgKey, sharedKey.slice(x + 48, x + 64)])),\r\n        sha1(Buffer.concat([sharedKey.slice(x + 64, x + 96), msgKey])),\r\n        sha1(Buffer.concat([msgKey, sharedKey.slice(x + 96, x + 128)]))\r\n    ])\r\n    const key = Buffer.concat([sha1a.slice(0, 8), sha1b.slice(8, 20), sha1c.slice(4, 16)])\r\n    const iv = Buffer.concat([sha1a.slice(8, 20), sha1b.slice(0, 8), sha1c.slice(16, 20), sha1d.slice(0, 8)])\r\n    return {\r\n        key,\r\n        iv\r\n    }\r\n}\r\n\r\n */\r\nfunction stripText(text, entities) {\r\n    if (!entities || !entities.length) {\r\n        return text.trim();\r\n    }\r\n    while (text && text[text.length - 1].trim() === \"\") {\r\n        const e = entities[entities.length - 1];\r\n        if (e.offset + e.length == text.length) {\r\n            if (e.length == 1) {\r\n                entities.pop();\r\n                if (!entities.length) {\r\n                    return text.trim();\r\n                }\r\n            }\r\n            else {\r\n                e.length -= 1;\r\n            }\r\n        }\r\n        text = text.slice(0, -1);\r\n    }\r\n    while (text && text[0].trim() === \"\") {\r\n        for (let i = 0; i < entities.length; i++) {\r\n            const e = entities[i];\r\n            if (e.offset != 0) {\r\n                e.offset--;\r\n                continue;\r\n            }\r\n            if (e.length == 1) {\r\n                entities.shift();\r\n                if (!entities.length) {\r\n                    return text.trimLeft();\r\n                }\r\n            }\r\n            else {\r\n                e.length -= 1;\r\n            }\r\n        }\r\n        text = text.slice(1);\r\n    }\r\n    return text;\r\n}\r\nexports.stripText = stripText;\r\n/**\r\n * Generates the key data corresponding to the given nonces\r\n * @param serverNonceBigInt\r\n * @param newNonceBigInt\r\n * @returns {{key: Buffer, iv: Buffer}}\r\n */\r\nasync function generateKeyDataFromNonce(serverNonceBigInt, newNonceBigInt) {\r\n    const serverNonce = toSignedLittleBuffer(serverNonceBigInt, 16);\r\n    const newNonce = toSignedLittleBuffer(newNonceBigInt, 32);\r\n    const [hash1, hash2, hash3] = await Promise.all([\r\n        sha1(buffer_1.Buffer.concat([newNonce, serverNonce])),\r\n        sha1(buffer_1.Buffer.concat([serverNonce, newNonce])),\r\n        sha1(buffer_1.Buffer.concat([newNonce, newNonce])),\r\n    ]);\r\n    const keyBuffer = buffer_1.Buffer.concat([hash1, hash2.slice(0, 12)]);\r\n    const ivBuffer = buffer_1.Buffer.concat([\r\n        hash2.slice(12, 20),\r\n        hash3,\r\n        newNonce.slice(0, 4),\r\n    ]);\r\n    return {\r\n        key: keyBuffer,\r\n        iv: ivBuffer,\r\n    };\r\n}\r\nexports.generateKeyDataFromNonce = generateKeyDataFromNonce;\r\nfunction convertToLittle(buf) {\r\n    const correct = buffer_1.Buffer.alloc(buf.length * 4);\r\n    for (let i = 0; i < buf.length; i++) {\r\n        correct.writeUInt32BE(buf[i], i * 4);\r\n    }\r\n    return correct;\r\n}\r\nexports.convertToLittle = convertToLittle;\r\n/**\r\n * Calculates the SHA1 digest for the given data\r\n * @param data\r\n * @returns {Promise}\r\n */\r\nfunction sha1(data) {\r\n    const shaSum = CryptoFile_1.default.createHash(\"sha1\");\r\n    shaSum.update(data);\r\n    // @ts-ignore\r\n    return shaSum.digest();\r\n}\r\nexports.sha1 = sha1;\r\n/**\r\n * Calculates the SHA256 digest for the given data\r\n * @param data\r\n * @returns {Promise}\r\n */\r\nfunction sha256(data) {\r\n    const shaSum = CryptoFile_1.default.createHash(\"sha256\");\r\n    shaSum.update(data);\r\n    // @ts-ignore\r\n    return shaSum.digest();\r\n}\r\nexports.sha256 = sha256;\r\n/**\r\n * Fast mod pow for RSA calculation. a^b % n\r\n * @param a\r\n * @param b\r\n * @param n\r\n * @returns {bigInt.BigInteger}\r\n */\r\nfunction modExp(a, b, n) {\r\n    a = a.remainder(n);\r\n    let result = big_integer_1.default.one;\r\n    let x = a;\r\n    while (b.greater(big_integer_1.default.zero)) {\r\n        const leastSignificantBit = b.remainder((0, big_integer_1.default)(2));\r\n        b = b.divide((0, big_integer_1.default)(2));\r\n        if (leastSignificantBit.eq(big_integer_1.default.one)) {\r\n            result = result.multiply(x);\r\n            result = result.remainder(n);\r\n        }\r\n        x = x.multiply(x);\r\n        x = x.remainder(n);\r\n    }\r\n    return result;\r\n}\r\nexports.modExp = modExp;\r\n/**\r\n * Gets the arbitrary-length byte array corresponding to the given integer\r\n * @param integer {number,BigInteger}\r\n * @param signed {boolean}\r\n * @returns {Buffer}\r\n */\r\nfunction getByteArray(integer, signed = false) {\r\n    const bits = integer.toString(2).length;\r\n    const byteLength = Math.floor((bits + 8 - 1) / 8);\r\n    return readBufferFromBigInt(typeof integer == \"number\" ? (0, big_integer_1.default)(integer) : integer, byteLength, false, signed);\r\n}\r\nexports.getByteArray = getByteArray;\r\nfunction returnBigInt(num) {\r\n    if (big_integer_1.default.isInstance(num)) {\r\n        return num;\r\n    }\r\n    if (typeof num == \"number\") {\r\n        return (0, big_integer_1.default)(num);\r\n    }\r\n    if (typeof num == \"bigint\") {\r\n        return (0, big_integer_1.default)(num);\r\n    }\r\n    return (0, big_integer_1.default)(num);\r\n}\r\nexports.returnBigInt = returnBigInt;\r\n/**\r\n * Helper function to return the smaller big int in an array\r\n * @param arrayOfBigInts\r\n */\r\nfunction getMinBigInt(arrayOfBigInts) {\r\n    if (arrayOfBigInts.length == 0) {\r\n        return big_integer_1.default.zero;\r\n    }\r\n    if (arrayOfBigInts.length == 1) {\r\n        return returnBigInt(arrayOfBigInts[0]);\r\n    }\r\n    let smallest = returnBigInt(arrayOfBigInts[0]);\r\n    for (let i = 1; i < arrayOfBigInts.length; i++) {\r\n        if (returnBigInt(arrayOfBigInts[i]).lesser(smallest)) {\r\n            smallest = returnBigInt(arrayOfBigInts[i]);\r\n        }\r\n    }\r\n    return smallest;\r\n}\r\nexports.getMinBigInt = getMinBigInt;\r\n/**\r\n * returns a random int from min (inclusive) and max (inclusive)\r\n * @param min\r\n * @param max\r\n * @returns {number}\r\n */\r\nfunction getRandomInt(min, max) {\r\n    min = Math.ceil(min);\r\n    max = Math.floor(max);\r\n    return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\nexports.getRandomInt = getRandomInt;\r\n/**\r\n * Sleeps a specified amount of time\r\n * @param ms time in milliseconds\r\n * @param isUnref make a timer unref'ed\r\n * @returns {Promise}\r\n */\r\nconst sleep = (ms, isUnref = false) => new Promise((resolve) => isUnref && platform_1.isNode\r\n    ? setTimeout(resolve, ms).unref()\r\n    : setTimeout(resolve, ms));\r\nexports.sleep = sleep;\r\n/**\r\n * Helper to export two buffers of same length\r\n * @returns {Buffer}\r\n */\r\nfunction bufferXor(a, b) {\r\n    const res = [];\r\n    for (let i = 0; i < a.length; i++) {\r\n        res.push(a[i] ^ b[i]);\r\n    }\r\n    return buffer_1.Buffer.from(res);\r\n}\r\nexports.bufferXor = bufferXor;\r\n// Taken from https://stackoverflow.com/questions/18638900/javascript-crc32/18639999#18639999\r\nfunction makeCRCTable() {\r\n    let c;\r\n    const crcTable = [];\r\n    for (let n = 0; n < 256; n++) {\r\n        c = n;\r\n        for (let k = 0; k < 8; k++) {\r\n            c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;\r\n        }\r\n        crcTable[n] = c;\r\n    }\r\n    return crcTable;\r\n}\r\nlet crcTable = undefined;\r\nfunction crc32(buf) {\r\n    if (!crcTable) {\r\n        crcTable = makeCRCTable();\r\n    }\r\n    if (!buffer_1.Buffer.isBuffer(buf)) {\r\n        buf = buffer_1.Buffer.from(buf);\r\n    }\r\n    let crc = -1;\r\n    for (let index = 0; index < buf.length; index++) {\r\n        const byte = buf[index];\r\n        crc = crcTable[(crc ^ byte) & 0xff] ^ (crc >>> 8);\r\n    }\r\n    return (crc ^ -1) >>> 0;\r\n}\r\nexports.crc32 = crc32;\r\nclass TotalList extends Array {\r\n    constructor() {\r\n        super();\r\n        this.total = 0;\r\n    }\r\n}\r\nexports.TotalList = TotalList;\r\nexports._EntityType = {\r\n    USER: 0,\r\n    CHAT: 1,\r\n    CHANNEL: 2,\r\n};\r\nObject.freeze(exports._EntityType);\r\nfunction _entityType(entity) {\r\n    if (typeof entity !== \"object\" || !(\"SUBCLASS_OF_ID\" in entity)) {\r\n        throw new Error(`${entity} is not a TLObject, cannot determine entity type`);\r\n    }\r\n    if (![\r\n        0x2d45687,\r\n        0xc91c90b6,\r\n        0xe669bf46,\r\n        0x40f202fd,\r\n        0x2da17977,\r\n        0xc5af5d94,\r\n        0x1f4661b9,\r\n        0xd49a2697, // crc32('ChatFull')\r\n    ].includes(entity.SUBCLASS_OF_ID)) {\r\n        throw new Error(`${entity} does not have any entity type`);\r\n    }\r\n    const name = entity.className;\r\n    if (name.includes(\"User\")) {\r\n        return exports._EntityType.USER;\r\n    }\r\n    else if (name.includes(\"Chat\")) {\r\n        return exports._EntityType.CHAT;\r\n    }\r\n    else if (name.includes(\"Channel\")) {\r\n        return exports._EntityType.CHANNEL;\r\n    }\r\n    else if (name.includes(\"Self\")) {\r\n        return exports._EntityType.USER;\r\n    }\r\n    // 'Empty' in name or not found, we don't care, not a valid entity.\r\n    throw new Error(`${entity} does not have any entity type`);\r\n}\r\nexports._entityType = _entityType;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}