{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MTProtoPlainSender = void 0;\nconst buffer_1 = require(\"buffer/\");\n/**\r\n *  This module contains the class used to communicate with Telegram's servers\r\n *  in plain text, when no authorization key has been created yet.\r\n */\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\nconst MTProtoState_1 = require(\"./MTProtoState\");\nconst Helpers_1 = require(\"../Helpers\");\nconst errors_1 = require(\"../errors\");\nconst extensions_1 = require(\"../extensions\");\n/**\r\n * MTProto Mobile Protocol plain sender (https://core.telegram.org/mtproto/description#unencrypted-messages)\r\n */\nclass MTProtoPlainSender {\n  /**\r\n   * Initializes the MTProto plain sender.\r\n   * @param connection connection: the Connection to be used.\r\n   * @param loggers\r\n   */\n  constructor(connection, loggers) {\n    this._state = new MTProtoState_1.MTProtoState(undefined, loggers);\n    this._connection = connection;\n  }\n  /**\r\n   * Sends and receives the result for the given request.\r\n   * @param request\r\n   */\n  async send(request) {\n    let body = request.getBytes();\n    let msgId = this._state._getNewMsgId();\n    const m = (0, Helpers_1.toSignedLittleBuffer)(msgId, 8);\n    const b = buffer_1.Buffer.alloc(4);\n    b.writeInt32LE(body.length, 0);\n    const res = buffer_1.Buffer.concat([buffer_1.Buffer.concat([buffer_1.Buffer.alloc(8), m, b]), body]);\n    await this._connection.send(res);\n    body = await this._connection.recv();\n    if (body.length < 8) {\n      throw new errors_1.InvalidBufferError(body);\n    }\n    const reader = new extensions_1.BinaryReader(body);\n    const authKeyId = reader.readLong();\n    if (authKeyId.neq((0, big_integer_1.default)(0))) {\n      throw new Error(\"Bad authKeyId\");\n    }\n    msgId = reader.readLong();\n    if (msgId.eq((0, big_integer_1.default)(0))) {\n      throw new Error(\"Bad msgId\");\n    }\n    /** ^ We should make sure that the read ``msg_id`` is greater\r\n     * than our own ``msg_id``. However, under some circumstances\r\n     * (bad system clock/working behind proxies) this seems to not\r\n     * be the case, which would cause endless assertion errors.\r\n     */\n    const length = reader.readInt();\n    if (length <= 0) {\n      throw new Error(\"Bad length\");\n    }\n    /**\r\n     * We could read length bytes and use those in a new reader to read\r\n     * the next TLObject without including the padding, but since the\r\n     * reader isn't used for anything else after this, it's unnecessary.\r\n     */\n    return reader.tgReadObject();\n  }\n}\nexports.MTProtoPlainSender = MTProtoPlainSender;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","MTProtoPlainSender","buffer_1","require","big_integer_1","MTProtoState_1","Helpers_1","errors_1","extensions_1","constructor","connection","loggers","_state","MTProtoState","undefined","_connection","send","request","body","getBytes","msgId","_getNewMsgId","m","toSignedLittleBuffer","b","Buffer","alloc","writeInt32LE","length","res","concat","recv","InvalidBufferError","reader","BinaryReader","authKeyId","readLong","neq","default","Error","eq","readInt","tgReadObject"],"sources":["C:/Users/Muhammed/Desktop/REACT_JS/dene-gramjs/node_modules/telegram/network/MTProtoPlainSender.js"],"sourcesContent":["\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MTProtoPlainSender = void 0;\r\nconst buffer_1 = require(\"buffer/\");\r\n/**\r\n *  This module contains the class used to communicate with Telegram's servers\r\n *  in plain text, when no authorization key has been created yet.\r\n */\r\nconst big_integer_1 = __importDefault(require(\"big-integer\"));\r\nconst MTProtoState_1 = require(\"./MTProtoState\");\r\nconst Helpers_1 = require(\"../Helpers\");\r\nconst errors_1 = require(\"../errors\");\r\nconst extensions_1 = require(\"../extensions\");\r\n/**\r\n * MTProto Mobile Protocol plain sender (https://core.telegram.org/mtproto/description#unencrypted-messages)\r\n */\r\nclass MTProtoPlainSender {\r\n    /**\r\n     * Initializes the MTProto plain sender.\r\n     * @param connection connection: the Connection to be used.\r\n     * @param loggers\r\n     */\r\n    constructor(connection, loggers) {\r\n        this._state = new MTProtoState_1.MTProtoState(undefined, loggers);\r\n        this._connection = connection;\r\n    }\r\n    /**\r\n     * Sends and receives the result for the given request.\r\n     * @param request\r\n     */\r\n    async send(request) {\r\n        let body = request.getBytes();\r\n        let msgId = this._state._getNewMsgId();\r\n        const m = (0, Helpers_1.toSignedLittleBuffer)(msgId, 8);\r\n        const b = buffer_1.Buffer.alloc(4);\r\n        b.writeInt32LE(body.length, 0);\r\n        const res = buffer_1.Buffer.concat([\r\n            buffer_1.Buffer.concat([buffer_1.Buffer.alloc(8), m, b]),\r\n            body,\r\n        ]);\r\n        await this._connection.send(res);\r\n        body = await this._connection.recv();\r\n        if (body.length < 8) {\r\n            throw new errors_1.InvalidBufferError(body);\r\n        }\r\n        const reader = new extensions_1.BinaryReader(body);\r\n        const authKeyId = reader.readLong();\r\n        if (authKeyId.neq((0, big_integer_1.default)(0))) {\r\n            throw new Error(\"Bad authKeyId\");\r\n        }\r\n        msgId = reader.readLong();\r\n        if (msgId.eq((0, big_integer_1.default)(0))) {\r\n            throw new Error(\"Bad msgId\");\r\n        }\r\n        /** ^ We should make sure that the read ``msg_id`` is greater\r\n         * than our own ``msg_id``. However, under some circumstances\r\n         * (bad system clock/working behind proxies) this seems to not\r\n         * be the case, which would cause endless assertion errors.\r\n         */\r\n        const length = reader.readInt();\r\n        if (length <= 0) {\r\n            throw new Error(\"Bad length\");\r\n        }\r\n        /**\r\n         * We could read length bytes and use those in a new reader to read\r\n         * the next TLObject without including the padding, but since the\r\n         * reader isn't used for anything else after this, it's unnecessary.\r\n         */\r\n        return reader.tgReadObject();\r\n    }\r\n}\r\nexports.MTProtoPlainSender = MTProtoPlainSender;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}